var s = new Array()

s[0] = "asn1util^asn1util.html^Utilities for handling ASN.1 BER encoding^ By this unit you can parse ASN.1 BER encoded data to elements or build back any elements to ASN.1 BER encoded buffer. You can dump ASN.1 BER encoded data to human readable form for easy debugging, too.    <p>Supported element types are: ASN1_BOOL, ASN1_INT, ASN1_OCTSTR, ASN1_NULL, ASN1_OBJID, ASN1_ENUM, ASN1_SEQ, ASN1_SETOF, ASN1_IPADDR, ASN1_COUNTER, ASN1_GAUGE, ASN1_TIMETICKS, ASN1_OPAQUE    <p>For sample of using, look to <a class=\"normal\" href=\"snmpsend.TSNMPSend.html\">TSNMPSend</a> or <a class=\"normal\" href=\"ldapsend.TLDAPSend.html\">TLDAPSend</a>class. ^0"
s[1] = "asn1util.ASN1_BOOL^asn1util.html#ASN1_BOOL^^ ^0"
s[2] = "asn1util.ASN1_INT^asn1util.html#ASN1_INT^^ ^0"
s[3] = "asn1util.ASN1_OCTSTR^asn1util.html#ASN1_OCTSTR^^ ^0"
s[4] = "asn1util.ASN1_NULL^asn1util.html#ASN1_NULL^^ ^0"
s[5] = "asn1util.ASN1_OBJID^asn1util.html#ASN1_OBJID^^ ^0"
s[6] = "asn1util.ASN1_ENUM^asn1util.html#ASN1_ENUM^^ ^0"
s[7] = "asn1util.ASN1_SEQ^asn1util.html#ASN1_SEQ^^ ^0"
s[8] = "asn1util.ASN1_SETOF^asn1util.html#ASN1_SETOF^^ ^0"
s[9] = "asn1util.ASN1_IPADDR^asn1util.html#ASN1_IPADDR^^ ^0"
s[10] = "asn1util.ASN1_COUNTER^asn1util.html#ASN1_COUNTER^^ ^0"
s[11] = "asn1util.ASN1_GAUGE^asn1util.html#ASN1_GAUGE^^ ^0"
s[12] = "asn1util.ASN1_TIMETICKS^asn1util.html#ASN1_TIMETICKS^^ ^0"
s[13] = "asn1util.ASN1_OPAQUE^asn1util.html#ASN1_OPAQUE^^ ^0"
s[14] = "asn1util.ASNEncOIDItem^asn1util.html#ASNEncOIDItem^^Encodes OID item to binary form.    ^0"
s[15] = "asn1util.ASNDecOIDItem^asn1util.html#ASNDecOIDItem^^Decodes an OID item of the next element in the &quot;Buffer&quot; from the &quot;Start&quot; position.    ^0"
s[16] = "asn1util.ASNEncLen^asn1util.html#ASNEncLen^^Encodes the length of ASN.1 element to binary.    ^0"
s[17] = "asn1util.ASNDecLen^asn1util.html#ASNDecLen^^Decodes length of next element in &quot;Buffer&quot; from the &quot;Start&quot; position.    ^0"
s[18] = "asn1util.ASNEncInt^asn1util.html#ASNEncInt^^Encodes a signed integer to ASN.1 binary    ^0"
s[19] = "asn1util.ASNEncUInt^asn1util.html#ASNEncUInt^^Encodes unsigned integer into ASN.1 binary    ^0"
s[20] = "asn1util.ASNObject^asn1util.html#ASNObject^^Encodes ASN.1 object to binary form.    ^0"
s[21] = "asn1util.ASNItem^asn1util.html#ASNItem^^Beginning with the &quot;Start&quot; position, decode the ASN.1 item of the next element in &quot;Buffer&quot;. Type of item is stored in &quot;ValueType.&quot;    ^0"
s[22] = "asn1util.MibToId^asn1util.html#MibToId^^Encodes an MIB OID string to binary form.    ^0"
s[23] = "asn1util.IdToMib^asn1util.html#IdToMib^^Decodes MIB OID from binary form to string form.    ^0"
s[24] = "asn1util.IntMibToStr^asn1util.html#IntMibToStr^^Encodes an one number from MIB OID to binary form. (used internally from <a class=\"normal\" href=\"asn1util.html#MibToId\">MibToId</a>)    ^0"
s[25] = "asn1util.ASNdump^asn1util.html#ASNdump^^Convert ASN.1 BER encoded buffer to human readable form for debugging.    ^0"
s[26] = "blcksock^blcksock.html^^ ^0"
s[27] = "blcksock.ESynapseError^blcksock.ESynapseError.html^Exception clas used by Synapse^ When you enable generating of exceptions, this exception is raised by Synapse's units. ^0"
s[28] = "blcksock.ESynapseError.ErrorCode^blcksock.ESynapseError.html#ErrorCode^^Code of error. Value depending on used operating system ^0"
s[29] = "blcksock.ESynapseError.ErrorMessage^blcksock.ESynapseError.html#ErrorMessage^^Human readable description of error. ^0"
s[30] = "blcksock.TSynaOption^blcksock.TSynaOption.html^this object is used for remember delayed socket option set.^ ^0"
s[31] = "blcksock.TSynaOption.Option^blcksock.TSynaOption.html#Option^^ ^0"
s[32] = "blcksock.TSynaOption.Enabled^blcksock.TSynaOption.html#Enabled^^ ^0"
s[33] = "blcksock.TSynaOption.Value^blcksock.TSynaOption.html#Value^^ ^0"
s[34] = "blcksock.TBlockSocket^blcksock.TBlockSocket.html^Basic IP object.^ This is parent class for other class with protocol implementations. Do not use this class directly! Use <a class=\"normal\" href=\"blcksock.TICMPBlockSocket.html\">TICMPBlockSocket</a>, <a class=\"normal\" href=\"blcksock.TRAWBlockSocket.html\">TRAWBlockSocket</a>, <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a> or <a class=\"normal\" href=\"blcksock.TUDPBlockSocket.html\">TUDPBlockSocket</a> instead. ^0"
s[35] = "blcksock.TBlockSocket.Create^blcksock.TBlockSocket.html#Create^^    ^0"
s[36] = "blcksock.TBlockSocket.CreateAlternate^blcksock.TBlockSocket.html#CreateAlternate^^Create object and load all necessary socket library. What library is loaded is described by STUB parameter. If STUB is empty string, then is loaded default libraries.    ^0"
s[37] = "blcksock.TBlockSocket.Destroy^blcksock.TBlockSocket.html#Destroy^^    ^0"
s[38] = "blcksock.TBlockSocket.CreateSocket^blcksock.TBlockSocket.html#CreateSocket^^If <a class=\"normal\" href=\"blcksock.TBlockSocket.html#Family\">Family</a> is not SF_Any, then create socket with type defined in <a class=\"normal\" href=\"blcksock.TBlockSocket.html#Family\">Family</a> property. If family is SF_Any, then do nothing! (socket is created automaticly when you know what type of socket you need to create. (i.e. inside <a class=\"normal\" href=\"blcksock.TBlockSocket.html#Connect\">Connect</a> or <a class=\"normal\" href=\"blcksock.TBlockSocket.html#Bind\">Bind</a> call.) When socket is created, then is aplyed all stored delayed socket options.    ^0"
s[39] = "blcksock.TBlockSocket.CreateSocketByName^blcksock.TBlockSocket.html#CreateSocketByName^^It create socket. Address resolving of Value tells what type of socket is created. If Value is resolved as IPv4 IP, then is created IPv4 socket. If value is resolved as IPv6 address, then is created IPv6 socket.    ^0"
s[40] = "blcksock.TBlockSocket.CloseSocket^blcksock.TBlockSocket.html#CloseSocket^^Destroy socket in use. This method is also automatically called from object destructor.    ^0"
s[41] = "blcksock.TBlockSocket.AbortSocket^blcksock.TBlockSocket.html#AbortSocket^^Abort any work on Socket and destroy them.    ^0"
s[42] = "blcksock.TBlockSocket.Bind^blcksock.TBlockSocket.html#Bind^^Connects socket to local IP address and PORT. IP address may be numeric or symbolic ('192.168.74.50', 'cosi.nekde.cz', 'ff08::1'). The same for PORT - it may be number or mnemonic port ('23', 'telnet').    <p>If port value is '0', system chooses itself and conects unused port in the range 1024 to 4096 (this depending by operating system!). Structure LocalSin is filled after calling this method.    <p>Note: If you call this on non-created socket, then socket is created automaticly.    <p>Warning: when you call : Bind('0.0.0.0','0'); then is nothing done! In this case is used implicit system bind instead.    ^0"
s[43] = "blcksock.TBlockSocket.Connect^blcksock.TBlockSocket.html#Connect^^Connects socket to remote IP address and PORT. The same rules as with <a class=\"normal\" href=\"blcksock.TBlockSocket.html#Bind\">Bind</a> method are valid. The only exception is that PORT with 0 value will not be connected!    <p>Structures LocalSin and RemoteSin will be filled with valid values.    <p>When you call this on non-created socket, then socket is created automaticly. Type of created socket is by <a class=\"normal\" href=\"blcksock.TBlockSocket.html#Family\">Family</a> property. If is used SF_IP4, then is created socket for IPv4. If is used SF_IP6, then is created socket for IPv6. When you have family on SF_Any (default!), then type of created socket is determined by address resolving of destination address. (Not work properly on prilimitary winsock IPv6 support!)    ^0"
s[44] = "blcksock.TBlockSocket.Listen^blcksock.TBlockSocket.html#Listen^^Sets socket to receive mode for new incoming connections. It is necessary to use <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#Bind\">Bind</a> function call before this method to select receiving port!    ^0"
s[45] = "blcksock.TBlockSocket.Accept^blcksock.TBlockSocket.html#Accept^^Waits until new incoming connection comes. After it comes a new socket is automatically created (socket handler is returned by this function as result).    ^0"
s[46] = "blcksock.TBlockSocket.SendBuffer^blcksock.TBlockSocket.html#SendBuffer^^Sends data of LENGTH from BUFFER address via connected socket. System automatically splits data to packets.    ^0"
s[47] = "blcksock.TBlockSocket.SendByte^blcksock.TBlockSocket.html#SendByte^^One data BYTE is sent via connected socket.    ^0"
s[48] = "blcksock.TBlockSocket.SendString^blcksock.TBlockSocket.html#SendString^^Send data string via connected socket. Any terminator is not added! If you need send true string with CR-LF termination, you must add CR-LF characters to sended string! Because any termination is not added automaticly, you can use this function for sending any binary data in binary string.    ^0"
s[49] = "blcksock.TBlockSocket.SendInteger^blcksock.TBlockSocket.html#SendInteger^^Send integer as four bytes to socket.    ^0"
s[50] = "blcksock.TBlockSocket.SendBlock^blcksock.TBlockSocket.html#SendBlock^^Send data as one block to socket. Each block begin with 4 bytes with length of data in block. This 4 bytes is added automaticly by this function.    ^0"
s[51] = "blcksock.TBlockSocket.SendStreamRaw^blcksock.TBlockSocket.html#SendStreamRaw^^Send data from stream to socket.    ^0"
s[52] = "blcksock.TBlockSocket.SendStream^blcksock.TBlockSocket.html#SendStream^^Send content of stream to socket. It using <a class=\"normal\" href=\"blcksock.TBlockSocket.html#SendBlock\">SendBlock</a> method    ^0"
s[53] = "blcksock.TBlockSocket.SendStreamIndy^blcksock.TBlockSocket.html#SendStreamIndy^^Send content of stream to socket. It using <a class=\"normal\" href=\"blcksock.TBlockSocket.html#SendBlock\">SendBlock</a> method and this is compatible with streams in Indy library.    ^0"
s[54] = "blcksock.TBlockSocket.RecvBuffer^blcksock.TBlockSocket.html#RecvBuffer^^Note: This is low-level receive function. You must be sure if data is waiting for read before call this function for avoid deadlock!    <p>Waits until allocated buffer is filled by received data. Returns number of data received, which equals to LENGTH value under normal operation. If it is not equal the communication channel is possibly broken.    <p>On stream oriented sockets if is received 0 bytes, it mean 'socket is closed!&quot;    <p>On datagram socket is readed first waiting datagram.    ^0"
s[55] = "blcksock.TBlockSocket.RecvBufferEx^blcksock.TBlockSocket.html#RecvBufferEx^^Note: This is high-level receive function. It using internal <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LineBuffer\">LineBuffer</a> and you can combine this function freely with other high-level functions!    <p>Method waits until data is received. If no data is received within TIMEOUT (in milliseconds) period, <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a> is set to WSAETIMEDOUT. Methods serves for reading any size of data (i.e. one megabyte...). This method is preffered for reading from stream sockets (like TCP).    ^0"
s[56] = "blcksock.TBlockSocket.RecvBufferStr^blcksock.TBlockSocket.html#RecvBufferStr^^Similar to <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvBufferEx\">RecvBufferEx</a>, but readed data is stored in binary string, not in memory buffer.    ^0"
s[57] = "blcksock.TBlockSocket.RecvByte^blcksock.TBlockSocket.html#RecvByte^^Note: This is high-level receive function. It using internal <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LineBuffer\">LineBuffer</a> and you can combine this function freely with other high-level functions.    <p>Waits until one data byte is received which is also returned as function result. If no data is received within TIMEOUT (in milliseconds)period, <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a> is set to WSAETIMEDOUT and result have value 0.    ^0"
s[58] = "blcksock.TBlockSocket.RecvInteger^blcksock.TBlockSocket.html#RecvInteger^^Note: This is high-level receive function. It using internal <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LineBuffer\">LineBuffer</a> and you can combine this function freely with other high-level functions.    <p>Waits until one four bytes are received and return it as one Ineger Value. If no data is received within TIMEOUT (in milliseconds)period, <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a> is set to WSAETIMEDOUT and result have value 0.    ^0"
s[59] = "blcksock.TBlockSocket.RecvString^blcksock.TBlockSocket.html#RecvString^^Note: This is high-level receive function. It using internal <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LineBuffer\">LineBuffer</a> and you can combine this function freely with other high-level functions.    <p>Method waits until data string is received. This string is terminated by CR-LF characters. The resulting string is returned without this termination (CR-LF)! If <a class=\"normal\" href=\"blcksock.TBlockSocket.html#ConvertLineEnd\">ConvertLineEnd</a> is used, then CR-LF sequence may not be exactly CR-LF. See <a class=\"normal\" href=\"blcksock.TBlockSocket.html#ConvertLineEnd\">ConvertLineEnd</a> description. If no data is received within TIMEOUT (in milliseconds) period, <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a> is set to WSAETIMEDOUT. You may also specify maximum length of reading data by <a class=\"normal\" href=\"blcksock.TBlockSocket.html#MaxLineLength\">MaxLineLength</a> property.    ^0"
s[60] = "blcksock.TBlockSocket.RecvTerminated^blcksock.TBlockSocket.html#RecvTerminated^^Note: This is high-level receive function. It using internal <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LineBuffer\">LineBuffer</a> and you can combine this function freely with other high-level functions.    <p>Method waits until data string is received. This string is terminated by Terminator string. The resulting string is returned without this termination. If no data is received within TIMEOUT (in milliseconds) period, <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a> is set to WSAETIMEDOUT. You may also specify maximum length of reading data by <a class=\"normal\" href=\"blcksock.TBlockSocket.html#MaxLineLength\">MaxLineLength</a> property.    ^0"
s[61] = "blcksock.TBlockSocket.RecvPacket^blcksock.TBlockSocket.html#RecvPacket^^Note: This is high-level receive function. It using internal <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LineBuffer\">LineBuffer</a> and you can combine this function freely with other high-level functions.    <p>Method reads all data waiting for read. If no data is received within TIMEOUT (in milliseconds) period, <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a> is set to WSAETIMEDOUT. Methods serves for reading unknown size of data. Because before call this function you don't know size of received data, returned data is stored in dynamic size binary string. This method is preffered for reading from stream sockets (like TCP). It is very goot for receiving datagrams too! (UDP protocol)    ^0"
s[62] = "blcksock.TBlockSocket.RecvBlock^blcksock.TBlockSocket.html#RecvBlock^^Read one block of data from socket. Each block begin with 4 bytes with length of data in block. This function read first 4 bytes for get lenght, then it wait for reported count of bytes.    ^0"
s[63] = "blcksock.TBlockSocket.RecvStreamRaw^blcksock.TBlockSocket.html#RecvStreamRaw^^Read all data from socket to stream until socket is closed (or any error occured.)    ^0"
s[64] = "blcksock.TBlockSocket.RecvStreamSize^blcksock.TBlockSocket.html#RecvStreamSize^^Read requested count of bytes from socket to stream.    ^0"
s[65] = "blcksock.TBlockSocket.RecvStream^blcksock.TBlockSocket.html#RecvStream^^Receive data to stream. It using <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvBlock\">RecvBlock</a> method.    ^0"
s[66] = "blcksock.TBlockSocket.RecvStreamIndy^blcksock.TBlockSocket.html#RecvStreamIndy^^Receive data to stream. This function is compatible with similar function in Indy library. It using <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvBlock\">RecvBlock</a> method.    ^0"
s[67] = "blcksock.TBlockSocket.PeekBuffer^blcksock.TBlockSocket.html#PeekBuffer^^Same as <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvBuffer\">RecvBuffer</a>, but readed data stays in system input buffer. Warning: this function not respect data in <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LineBuffer\">LineBuffer</a>! Is not recommended to use this function!    ^0"
s[68] = "blcksock.TBlockSocket.PeekByte^blcksock.TBlockSocket.html#PeekByte^^Same as <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvByte\">RecvByte</a>, but readed data stays in input system buffer. Warning: this function not respect data in <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LineBuffer\">LineBuffer</a>! Is not recommended to use this function!    ^0"
s[69] = "blcksock.TBlockSocket.WaitingData^blcksock.TBlockSocket.html#WaitingData^^On stream sockets it returns number of received bytes waiting for picking. 0 is returned when there is no such data. On datagram socket it returns length of the first waiting datagram. Returns 0 if no datagram is waiting.    ^0"
s[70] = "blcksock.TBlockSocket.WaitingDataEx^blcksock.TBlockSocket.html#WaitingDataEx^^Same as <a class=\"normal\" href=\"blcksock.TBlockSocket.html#WaitingData\">WaitingData</a>, but if exists some of data in <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LineBuffer\">LineBuffer</a>, return their length instead.    ^0"
s[71] = "blcksock.TBlockSocket.Purge^blcksock.TBlockSocket.html#Purge^^Clear all waiting data for read from buffers.    ^0"
s[72] = "blcksock.TBlockSocket.SetLinger^blcksock.TBlockSocket.html#SetLinger^^Sets linger. Enabled linger means that the system waits another LINGER (in milliseconds) time for delivery of sent data. This function is only for stream type of socket! (TCP)    ^0"
s[73] = "blcksock.TBlockSocket.GetSinLocal^blcksock.TBlockSocket.html#GetSinLocal^^Actualize values in <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LocalSin\">LocalSin</a>.    ^0"
s[74] = "blcksock.TBlockSocket.GetSinRemote^blcksock.TBlockSocket.html#GetSinRemote^^Actualize values in <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RemoteSin\">RemoteSin</a>.    ^0"
s[75] = "blcksock.TBlockSocket.GetSins^blcksock.TBlockSocket.html#GetSins^^Actualize values in <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LocalSin\">LocalSin</a> and <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RemoteSin\">RemoteSin</a>.    ^0"
s[76] = "blcksock.TBlockSocket.ResetLastError^blcksock.TBlockSocket.html#ResetLastError^^Reset <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a> and <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastErrorDesc\">LastErrorDesc</a> to non-error state.    ^0"
s[77] = "blcksock.TBlockSocket.SockCheck^blcksock.TBlockSocket.html#SockCheck^^If you &quot;manually&quot; call Socket API functions, forward their return code as parameter to this function, which evaluates it, eventually calls GetLastError and found error code returns and stores to <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a>.    ^0"
s[78] = "blcksock.TBlockSocket.ExceptCheck^blcksock.TBlockSocket.html#ExceptCheck^^If <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a> contains some error code and <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RaiseExcept\">RaiseExcept</a> property is <code>True</code>, raise adequate exception.    ^0"
s[79] = "blcksock.TBlockSocket.LocalName^blcksock.TBlockSocket.html#LocalName^^Returns local computer name as numerical or symbolic value. It try get fully qualified domain name. Name is returned in the format acceptable by functions demanding IP as input parameter.    ^0"
s[80] = "blcksock.TBlockSocket.ResolveNameToIP^blcksock.TBlockSocket.html#ResolveNameToIP^^Try resolve name to all possible IP address. i.e. If you pass as name result of <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LocalName\">LocalName</a> method, you get all IP addresses used by local system.    ^0"
s[81] = "blcksock.TBlockSocket.ResolveName^blcksock.TBlockSocket.html#ResolveName^^Try resolve name to primary IP address. i.e. If you pass as name result of <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LocalName\">LocalName</a> method, you get primary IP addresses used by local system.    ^0"
s[82] = "blcksock.TBlockSocket.ResolveIPToName^blcksock.TBlockSocket.html#ResolveIPToName^^Try resolve IP to their primary domain name. If IP not have domain name, then is returned original IP.    ^0"
s[83] = "blcksock.TBlockSocket.ResolvePort^blcksock.TBlockSocket.html#ResolvePort^^Try resolve symbolic port name to port number. (i.e. 'Echo' to 8)    ^0"
s[84] = "blcksock.TBlockSocket.SetRemoteSin^blcksock.TBlockSocket.html#SetRemoteSin^^Set information about remote side socket. It is good for seting remote side for sending UDP packet, etc.    ^0"
s[85] = "blcksock.TBlockSocket.GetLocalSinIP^blcksock.TBlockSocket.html#GetLocalSinIP^^Picks IP socket address from <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LocalSin\">LocalSin</a>.    ^0"
s[86] = "blcksock.TBlockSocket.GetRemoteSinIP^blcksock.TBlockSocket.html#GetRemoteSinIP^^Picks IP socket address from <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RemoteSin\">RemoteSin</a>.    ^0"
s[87] = "blcksock.TBlockSocket.GetLocalSinPort^blcksock.TBlockSocket.html#GetLocalSinPort^^Picks socket PORT number from <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LocalSin\">LocalSin</a>.    ^0"
s[88] = "blcksock.TBlockSocket.GetRemoteSinPort^blcksock.TBlockSocket.html#GetRemoteSinPort^^Picks socket PORT number from <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RemoteSin\">RemoteSin</a>.    ^0"
s[89] = "blcksock.TBlockSocket.CanRead^blcksock.TBlockSocket.html#CanRead^^Return <code>True</code>, if you can read any data from socket or is incoming connection on TCP based socket. Status is tested for time Timeout (in milliseconds). If value in Timeout is 0, status is only tested and continue. If value in Timeout is -1, run is breaked and waiting for read data maybe forever.    <p>This function is need only on special cases, when you need use <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvBuffer\">RecvBuffer</a> function directly! read functioms what have timeout as calling parameter, calling this function internally.    ^0"
s[90] = "blcksock.TBlockSocket.CanReadEx^blcksock.TBlockSocket.html#CanReadEx^^Same as <a class=\"normal\" href=\"blcksock.TBlockSocket.html#CanRead\">CanRead</a>, but additionally return <code>True</code> if is some data in <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LineBuffer\">LineBuffer</a>.    ^0"
s[91] = "blcksock.TBlockSocket.CanWrite^blcksock.TBlockSocket.html#CanWrite^^Return <code>True</code>, if you can to socket write any data (not full sending buffer). Status is tested for time Timeout (in milliseconds). If value in Timeout is 0, status is only tested and continue. If value in Timeout is -1, run is breaked and waiting for write data maybe forever.    <p>This function is need only on special cases!    ^0"
s[92] = "blcksock.TBlockSocket.SendBufferTo^blcksock.TBlockSocket.html#SendBufferTo^^Same as <a class=\"normal\" href=\"blcksock.TBlockSocket.html#SendBuffer\">SendBuffer</a>, but send datagram to address from <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RemoteSin\">RemoteSin</a>. Usefull for sending reply to datagram received by function <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvBufferFrom\">RecvBufferFrom</a>.    ^0"
s[93] = "blcksock.TBlockSocket.RecvBufferFrom^blcksock.TBlockSocket.html#RecvBufferFrom^^Note: This is low-lever receive function. You must be sure if data is waiting for read before call this function for avoid deadlock!    <p>Receives first waiting datagram to allocated buffer. If there is no waiting one, then waits until one comes. Returns length of datagram stored in BUFFER. If length exceeds buffer datagram is truncated. After this <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RemoteSin\">RemoteSin</a> structure contains information about sender of UDP packet.    ^0"
s[94] = "blcksock.TBlockSocket.GroupCanRead^blcksock.TBlockSocket.html#GroupCanRead^^This function is for check for incoming data on set of sockets. Whitch sockets is checked is decribed by SocketList Tlist with TBlockSocket objects. TList may have maximal number of objects defined by FD_SETSIZE constant. Return <code>True</code>, if you can from some socket read any data or is incoming connection on TCP based socket. Status is tested for time Timeout (in milliseconds). If value in Timeout is 0, status is only tested and continue. If value in Timeout is -1, run is breaked and waiting for read data maybe forever. If is returned <code>True</code>, CanReadList TList is filled by all TBlockSocket objects what waiting for read.    ^0"
s[95] = "blcksock.TBlockSocket.EnableReuse^blcksock.TBlockSocket.html#EnableReuse^^By this method you may turn address reuse mode for local <a class=\"normal\" href=\"blcksock.TBlockSocket.html#Bind\">Bind</a>. It is good specially for UDP protocol. Using this with TCP protocol is hazardous!    ^0"
s[96] = "blcksock.TBlockSocket.SetTimeout^blcksock.TBlockSocket.html#SetTimeout^^Try set timeout for all sending and receiving operations, if socket provider can do it. (It not supported by all socket providers!)    ^0"
s[97] = "blcksock.TBlockSocket.SetSendTimeout^blcksock.TBlockSocket.html#SetSendTimeout^^Try set timeout for all sending operations, if socket provider can do it. (It not supported by all socket providers!)    ^0"
s[98] = "blcksock.TBlockSocket.SetRecvTimeout^blcksock.TBlockSocket.html#SetRecvTimeout^^Try set timeout for all receiving operations, if socket provider can do it. (It not supported by all socket providers!)    ^0"
s[99] = "blcksock.TBlockSocket.GetSocketType^blcksock.TBlockSocket.html#GetSocketType^^Return value of socket type.    ^0"
s[100] = "blcksock.TBlockSocket.GetSocketProtocol^blcksock.TBlockSocket.html#GetSocketProtocol^^Return value of protocol type for socket creation.    ^0"
s[101] = "blcksock.TBlockSocket.GetErrorDesc^blcksock.TBlockSocket.html#GetErrorDesc^^Return descriptive string for given error code. This is class function. You may call it without created object!    ^0"
s[102] = "blcksock.TBlockSocket.GetErrorDescEx^blcksock.TBlockSocket.html#GetErrorDescEx^^Return descriptive string for <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a>.    ^0"
s[103] = "blcksock.TBlockSocket.WSAData^blcksock.TBlockSocket.html#WSAData^^WSA structure with information about socket provider. On non-windows platforms this structure is simulated! ^0"
s[104] = "blcksock.TBlockSocket.FDset^blcksock.TBlockSocket.html#FDset^^FDset structure prepared for usage with this socket. ^0"
s[105] = "blcksock.TBlockSocket.LocalSin^blcksock.TBlockSocket.html#LocalSin^^Structure describing local socket side. ^0"
s[106] = "blcksock.TBlockSocket.RemoteSin^blcksock.TBlockSocket.html#RemoteSin^^Structure describing remote socket side. ^0"
s[107] = "blcksock.TBlockSocket.Socket^blcksock.TBlockSocket.html#Socket^^Socket handler. Suitable for &quot;manual&quot; calls to socket API or manual connection of socket to a previously created socket (i.e by Accept method on TCP socket) ^0"
s[108] = "blcksock.TBlockSocket.LastError^blcksock.TBlockSocket.html#LastError^^Last socket operation error code. Error codes are described in socket documentation. Human readable error description is stored in <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastErrorDesc\">LastErrorDesc</a> property. ^0"
s[109] = "blcksock.TBlockSocket.LastErrorDesc^blcksock.TBlockSocket.html#LastErrorDesc^^Human readable error description of <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a> code. ^0"
s[110] = "blcksock.TBlockSocket.LineBuffer^blcksock.TBlockSocket.html#LineBuffer^^Buffer used by all high-level receiving functions. This buffer is used for optimized reading of data from socket. In normal cases you not need access to this buffer directly! ^0"
s[111] = "blcksock.TBlockSocket.SizeRecvBuffer^blcksock.TBlockSocket.html#SizeRecvBuffer^^Size of Winsock receive buffer. If it is not supported by socket provider, it return as size one kilobyte. ^0"
s[112] = "blcksock.TBlockSocket.SizeSendBuffer^blcksock.TBlockSocket.html#SizeSendBuffer^^Size of Winsock send buffer. If it is not supported by socket provider, it return as size one kilobyte. ^0"
s[113] = "blcksock.TBlockSocket.NonBlockMode^blcksock.TBlockSocket.html#NonBlockMode^^If <code>True</code>, turn class to non-blocking mode. Not all functions are working properly in this mode, you must know exactly what you are doing! However when you have big experience with non-blocking programming, then you can optimise your program by non-block mode! ^0"
s[114] = "blcksock.TBlockSocket.TTL^blcksock.TBlockSocket.html#TTL^^Set Time-to-live value. (if system supporting it!) ^0"
s[115] = "blcksock.TBlockSocket.IP6used^blcksock.TBlockSocket.html#IP6used^^If is <code>True</code>, then class in in IPv6 mode. ^0"
s[116] = "blcksock.TBlockSocket.RecvCounter^blcksock.TBlockSocket.html#RecvCounter^^Return count of received bytes on this socket from begin of current connection. ^0"
s[117] = "blcksock.TBlockSocket.SendCounter^blcksock.TBlockSocket.html#SendCounter^^Return count of sended bytes on this socket from begin of current connection. ^0"
s[118] = "blcksock.TBlockSocket.Tag^blcksock.TBlockSocket.html#Tag^^this value is for free use. ^0"
s[119] = "blcksock.TBlockSocket.RaiseExcept^blcksock.TBlockSocket.html#RaiseExcept^^If <code>True</code>, winsock errors raises exception. Otherwise is setted <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LastError\">LastError</a> value only and you must check it from your program! Default value is <code>False</code>. ^0"
s[120] = "blcksock.TBlockSocket.MaxLineLength^blcksock.TBlockSocket.html#MaxLineLength^^Define maximum length in bytes of <a class=\"normal\" href=\"blcksock.TBlockSocket.html#LineBuffer\">LineBuffer</a> for high-level receiving functions. If this functions try to read more data then this limit, error is returned! If value is 0 (default), no limitation is used. This is very good protection for stupid attacks to your server by sending lot of data without proper terminator... until all your memory is allocated by LineBuffer!    <p>Note: This maximum length is checked only in functions, what read unknown number of bytes! (like <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvString\">RecvString</a> or <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvTerminated\">RecvTerminated</a>) ^0"
s[121] = "blcksock.TBlockSocket.MaxSendBandwidth^blcksock.TBlockSocket.html#MaxSendBandwidth^^Define maximal bandwidth for all sending operations in bytes per second. If value is 0 (default), bandwidth limitation is not used. ^0"
s[122] = "blcksock.TBlockSocket.MaxRecvBandwidth^blcksock.TBlockSocket.html#MaxRecvBandwidth^^Define maximal bandwidth for all receiving operations in bytes per second. If value is 0 (default), bandwidth limitation is not used. ^0"
s[123] = "blcksock.TBlockSocket.MaxBandwidth^blcksock.TBlockSocket.html#MaxBandwidth^^Define maximal bandwidth for all sending and receiving operations in bytes per second. If value is 0 (default), bandwidth limitation is not used. ^0"
s[124] = "blcksock.TBlockSocket.ConvertLineEnd^blcksock.TBlockSocket.html#ConvertLineEnd^^Do a conversion of non-standard line terminators to CRLF. (Off by default) If <code>True</code>, then terminators like sigle CR, single LF or LFCR are converted to CRLF internally. This have effect only in <a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvString\">RecvString</a> method! ^0"
s[125] = "blcksock.TBlockSocket.Family^blcksock.TBlockSocket.html#Family^^Specified Family of this socket. When you are using Windows preliminary support for IPv6, then I recommend to set this property! ^0"
s[126] = "blcksock.TBlockSocket.PreferIP4^blcksock.TBlockSocket.html#PreferIP4^^When resolving of domain name return both IPv4 and IPv6 addresses, then specify if is used IPv4 (dafault - <code>True</code>) or IPv6. ^0"
s[127] = "blcksock.TBlockSocket.InterPacketTimeout^blcksock.TBlockSocket.html#InterPacketTimeout^^By default (<code>True</code>) is all timeouts used as timeout between two packets in reading operations. If you set this to <code>False</code>, then Timeouts is for overall reading operation! ^0"
s[128] = "blcksock.TBlockSocket.SendMaxChunk^blcksock.TBlockSocket.html#SendMaxChunk^^All sended datas was splitted by this value. ^0"
s[129] = "blcksock.TBlockSocket.StopFlag^blcksock.TBlockSocket.html#StopFlag^^By setting this property to <code>True</code> you can stop any communication. You can use this property for soft abort of communication. ^0"
s[130] = "blcksock.TBlockSocket.NonblockSendTimeout^blcksock.TBlockSocket.html#NonblockSendTimeout^^Timeout for data sending by non-blocking socket mode. ^0"
s[131] = "blcksock.TBlockSocket.OnStatus^blcksock.TBlockSocket.html#OnStatus^^This event is called by various reasons. It is good for monitoring socket, create gauges for data transfers, etc. ^0"
s[132] = "blcksock.TBlockSocket.OnReadFilter^blcksock.TBlockSocket.html#OnReadFilter^^this event is good for some internal thinks about filtering readed datas. It is used by telnet client by example. ^0"
s[133] = "blcksock.TBlockSocket.OnCreateSocket^blcksock.TBlockSocket.html#OnCreateSocket^^This event is called after real socket creation for setting special socket options, because you not know when socket is created. (it is depended on Ipv4, IPv6 or automatic mode) ^0"
s[134] = "blcksock.TBlockSocket.OnMonitor^blcksock.TBlockSocket.html#OnMonitor^^This event is good for monitoring content of readed or writed datas. ^0"
s[135] = "blcksock.TBlockSocket.OnHeartbeat^blcksock.TBlockSocket.html#OnHeartbeat^^This event is good for calling your code during long socket operations. (Example, for refresing UI if class in not called within the thread.) Rate of heartbeats can be modified by <a class=\"normal\" href=\"blcksock.TBlockSocket.html#HeartbeatRate\">HeartbeatRate</a> property. ^0"
s[136] = "blcksock.TBlockSocket.HeartbeatRate^blcksock.TBlockSocket.html#HeartbeatRate^^Specify typical rate of <a class=\"normal\" href=\"blcksock.TBlockSocket.html#OnHeartbeat\">OnHeartbeat</a> event and <a class=\"normal\" href=\"blcksock.TBlockSocket.html#StopFlag\">StopFlag</a> testing. Default value 0 disabling heartbeats! Value is in milliseconds. Real rate can be higher or smaller then this value, because it depending on real socket operations too! Note: Each heartbeat slowing socket processing. ^0"
s[137] = "blcksock.TBlockSocket.Owner^blcksock.TBlockSocket.html#Owner^^What class own this socket? Used by protocol implementation classes. ^0"
s[138] = "blcksock.TSocksBlockSocket^blcksock.TSocksBlockSocket.html^Support for SOCKS4 and SOCKS5 proxy^ Layer with definition all necessary properties and functions for implementation SOCKS proxy client. Do not use this class directly. ^0"
s[139] = "blcksock.TSocksBlockSocket.Create^blcksock.TSocksBlockSocket.html#Create^^    ^0"
s[140] = "blcksock.TSocksBlockSocket.SocksOpen^blcksock.TSocksBlockSocket.html#SocksOpen^^Open connection to SOCKS proxy and if <a class=\"normal\" href=\"blcksock.TSocksBlockSocket.html#SocksUsername\">SocksUsername</a> is set, do authorisation to proxy. This is needed only in special cases! (it is called internally!)    ^0"
s[141] = "blcksock.TSocksBlockSocket.SocksRequest^blcksock.TSocksBlockSocket.html#SocksRequest^^Send specified request to SOCKS proxy. This is needed only in special cases! (it is called internally!)    ^0"
s[142] = "blcksock.TSocksBlockSocket.SocksResponse^blcksock.TSocksBlockSocket.html#SocksResponse^^Receive response to previosly sended request. This is needed only in special cases! (it is called internally!)    ^0"
s[143] = "blcksock.TSocksBlockSocket.UsingSocks^blcksock.TSocksBlockSocket.html#UsingSocks^^Is <code>True</code> when class is using SOCKS proxy. ^0"
s[144] = "blcksock.TSocksBlockSocket.SocksLastError^blcksock.TSocksBlockSocket.html#SocksLastError^^If SOCKS proxy failed, here is error code returned from SOCKS proxy. ^0"
s[145] = "blcksock.TSocksBlockSocket.SocksIP^blcksock.TSocksBlockSocket.html#SocksIP^^Address of SOCKS server. If value is empty string, SOCKS support is disabled. Assingning any value to this property enable SOCKS mode. Warning: You cannot combine this mode with HTTP-tunneling mode! ^0"
s[146] = "blcksock.TSocksBlockSocket.SocksPort^blcksock.TSocksBlockSocket.html#SocksPort^^Port of SOCKS server. Default value is '1080'. ^0"
s[147] = "blcksock.TSocksBlockSocket.SocksUsername^blcksock.TSocksBlockSocket.html#SocksUsername^^If you need authorisation on SOCKS server, set username here. ^0"
s[148] = "blcksock.TSocksBlockSocket.SocksPassword^blcksock.TSocksBlockSocket.html#SocksPassword^^If you need authorisation on SOCKS server, set password here. ^0"
s[149] = "blcksock.TSocksBlockSocket.SocksTimeout^blcksock.TSocksBlockSocket.html#SocksTimeout^^Specify timeout for communicatin with SOCKS server. Default is one minute. ^0"
s[150] = "blcksock.TSocksBlockSocket.SocksResolver^blcksock.TSocksBlockSocket.html#SocksResolver^^If <code>True</code>, all symbolic names of target hosts is not translated to IP's locally, but resolving is by SOCKS proxy. Default is <code>True</code>. ^0"
s[151] = "blcksock.TSocksBlockSocket.SocksType^blcksock.TSocksBlockSocket.html#SocksType^^Specify SOCKS type. By default is used SOCKS5, but you can use SOCKS4 too. When you select SOCKS4, then if <a class=\"normal\" href=\"blcksock.TSocksBlockSocket.html#SocksResolver\">SocksResolver</a> is enabled, then is used SOCKS4a. Othervise is used pure SOCKS4. ^0"
s[152] = "blcksock.TTCPBlockSocket^blcksock.TTCPBlockSocket.html^Implementation of TCP socket.^ Supported features: IPv4, IPv6, SSL/TLS or SSH (depending on used plugin), SOCKS5 proxy (outgoing connections and limited incomming), SOCKS4/4a proxy (outgoing connections and limited incomming), TCP through HTTP proxy tunnel. ^0"
s[153] = "blcksock.TTCPBlockSocket.Create^blcksock.TTCPBlockSocket.html#Create^^Create TCP socket class with default plugin for SSL/TSL/SSH implementation (see <a class=\"normal\" href=\"blcksock.html#SSLImplementation\">SSLImplementation</a>)    ^0"
s[154] = "blcksock.TTCPBlockSocket.CreateWithSSL^blcksock.TTCPBlockSocket.html#CreateWithSSL^^Create TCP socket class with desired plugin for SSL/TSL/SSH implementation    ^0"
s[155] = "blcksock.TTCPBlockSocket.Destroy^blcksock.TTCPBlockSocket.html#Destroy^^    ^0"
s[156] = "blcksock.TTCPBlockSocket.CloseSocket^blcksock.TTCPBlockSocket.html#CloseSocket^^See <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#CloseSocket\">CloseSocket</a>    ^0"
s[157] = "blcksock.TTCPBlockSocket.WaitingData^blcksock.TTCPBlockSocket.html#WaitingData^^See <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#WaitingData\">WaitingData</a>    ^0"
s[158] = "blcksock.TTCPBlockSocket.Listen^blcksock.TTCPBlockSocket.html#Listen^^Sets socket to receive mode for new incoming connections. It is necessary to use <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#Bind\">Bind</a> function call before this method to select receiving port!    <p>If you use SOCKS, activate incoming TCP connection by this proxy. (By BIND method of SOCKS.)    ^0"
s[159] = "blcksock.TTCPBlockSocket.Accept^blcksock.TTCPBlockSocket.html#Accept^^Waits until new incoming connection comes. After it comes a new socket is automatically created (socket handler is returned by this function as result).    <p>If you use SOCKS, new socket is not created! In this case is used same socket as socket for listening! So, you can accept only one connection in SOCKS mode.    ^0"
s[160] = "blcksock.TTCPBlockSocket.Connect^blcksock.TTCPBlockSocket.html#Connect^^Connects socket to remote IP address and PORT. The same rules as with <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#Bind\">Bind</a> method are valid. The only exception is that PORT with 0 value will not be connected. After call to this method a communication channel between local and remote socket is created. Local socket is assigned automatically if not controlled by previous call to <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#Bind\">Bind</a> method. Structures <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#LocalSin\">LocalSin</a> and <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#RemoteSin\">RemoteSin</a> will be filled with valid values.    <p>If you use SOCKS, activate outgoing TCP connection by SOCKS proxy specified in <a class=\"normal\" href=\"blcksock.TSocksBlockSocket.html\">TSocksBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TSocksBlockSocket.html#SocksIP\">SocksIP</a>. (By CONNECT method of SOCKS.)    <p>If you use HTTP-tunnel mode, activate outgoing TCP connection by HTTP tunnel specified in <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html#HTTPTunnelIP\">HTTPTunnelIP</a>. (By CONNECT method of HTTP protocol.)    <p>Note: If you call this on non-created socket, then socket is created automaticly.    ^0"
s[161] = "blcksock.TTCPBlockSocket.SSLDoConnect^blcksock.TTCPBlockSocket.html#SSLDoConnect^^If you need upgrade existing TCP connection to SSL/TLS (or SSH2, if plugin allows it) mode, then call this method. This method switch this class to SSL mode and do SSL/TSL handshake.    ^0"
s[162] = "blcksock.TTCPBlockSocket.SSLDoShutdown^blcksock.TTCPBlockSocket.html#SSLDoShutdown^^By this method you can downgrade existing SSL/TLS connection to normal TCP connection.    ^0"
s[163] = "blcksock.TTCPBlockSocket.SSLAcceptConnection^blcksock.TTCPBlockSocket.html#SSLAcceptConnection^^If you need use this component as SSL/TLS TCP server, then after accepting of inbound connection you need start SSL/TLS session by this method. Before call this function, you must have assigned all neeeded certificates and keys!    ^0"
s[164] = "blcksock.TTCPBlockSocket.GetLocalSinIP^blcksock.TTCPBlockSocket.html#GetLocalSinIP^^See <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#GetLocalSinIP\">GetLocalSinIP</a>    ^0"
s[165] = "blcksock.TTCPBlockSocket.GetRemoteSinIP^blcksock.TTCPBlockSocket.html#GetRemoteSinIP^^See <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#GetRemoteSinIP\">GetRemoteSinIP</a>    ^0"
s[166] = "blcksock.TTCPBlockSocket.GetLocalSinPort^blcksock.TTCPBlockSocket.html#GetLocalSinPort^^See <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#GetLocalSinPort\">GetLocalSinPort</a>    ^0"
s[167] = "blcksock.TTCPBlockSocket.GetRemoteSinPort^blcksock.TTCPBlockSocket.html#GetRemoteSinPort^^See <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#GetRemoteSinPort\">GetRemoteSinPort</a>    ^0"
s[168] = "blcksock.TTCPBlockSocket.SendBuffer^blcksock.TTCPBlockSocket.html#SendBuffer^^See <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#SendBuffer\">SendBuffer</a>    ^0"
s[169] = "blcksock.TTCPBlockSocket.RecvBuffer^blcksock.TTCPBlockSocket.html#RecvBuffer^^See <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvBuffer\">RecvBuffer</a>    ^0"
s[170] = "blcksock.TTCPBlockSocket.GetSocketType^blcksock.TTCPBlockSocket.html#GetSocketType^^Return value of socket type. For TCP return SOCK_STREAM.    ^0"
s[171] = "blcksock.TTCPBlockSocket.GetSocketProtocol^blcksock.TTCPBlockSocket.html#GetSocketProtocol^^Return value of protocol type for socket creation. For TCP return IPPROTO_TCP.    ^0"
s[172] = "blcksock.TTCPBlockSocket.GetErrorDescEx^blcksock.TTCPBlockSocket.html#GetErrorDescEx^^Return descriptive string for <code>LastError</code>. On case of error in SSL/TLS subsystem, it returns right error description.    ^0"
s[173] = "blcksock.TTCPBlockSocket.SSL^blcksock.TTCPBlockSocket.html#SSL^^Class implementing SSL/TLS support. It is allways some descendant of <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a> class. When programmer not select some SSL plugin class, then is used <a class=\"normal\" href=\"blcksock.TSSLNone.html\">TSSLNone</a> ^0"
s[174] = "blcksock.TTCPBlockSocket.HTTPTunnel^blcksock.TTCPBlockSocket.html#HTTPTunnel^^<code>True</code> if is used HTTP tunnel mode. ^0"
s[175] = "blcksock.TTCPBlockSocket.HTTPTunnelIP^blcksock.TTCPBlockSocket.html#HTTPTunnelIP^^Specify IP address of HTTP proxy. Assingning non-empty value to this property enable HTTP-tunnel mode. This mode is for tunnelling any outgoing TCP connection through HTTP proxy server. (If policy on HTTP proxy server allow this!) Warning: You cannot combine this mode with SOCK5 mode! ^0"
s[176] = "blcksock.TTCPBlockSocket.HTTPTunnelPort^blcksock.TTCPBlockSocket.html#HTTPTunnelPort^^Specify port of HTTP proxy for HTTP-tunneling. ^0"
s[177] = "blcksock.TTCPBlockSocket.HTTPTunnelUser^blcksock.TTCPBlockSocket.html#HTTPTunnelUser^^Specify authorisation username for access to HTTP proxy in HTTP-tunnel mode. If you not need authorisation, then let this property empty. ^0"
s[178] = "blcksock.TTCPBlockSocket.HTTPTunnelPass^blcksock.TTCPBlockSocket.html#HTTPTunnelPass^^Specify authorisation password for access to HTTP proxy in HTTP-tunnel mode. ^0"
s[179] = "blcksock.TTCPBlockSocket.HTTPTunnelTimeout^blcksock.TTCPBlockSocket.html#HTTPTunnelTimeout^^Specify timeout for communication with HTTP proxy in HTTPtunnel mode. ^0"
s[180] = "blcksock.TTCPBlockSocket.OnAfterConnect^blcksock.TTCPBlockSocket.html#OnAfterConnect^^This event is called after sucessful TCP socket connection. ^0"
s[181] = "blcksock.TDgramBlockSocket^blcksock.TDgramBlockSocket.html^Datagram based communication^ This class implementing datagram based communication instead default stream based communication style. ^0"
s[182] = "blcksock.TDgramBlockSocket.Connect^blcksock.TDgramBlockSocket.html#Connect^^Fill <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#RemoteSin\">RemoteSin</a> structure. This address is used for sending data.    ^0"
s[183] = "blcksock.TDgramBlockSocket.SendBuffer^blcksock.TDgramBlockSocket.html#SendBuffer^^Silently redirected to <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#SendBufferTo\">SendBufferTo</a>.    ^0"
s[184] = "blcksock.TDgramBlockSocket.RecvBuffer^blcksock.TDgramBlockSocket.html#RecvBuffer^^Silently redirected to <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvBufferFrom\">RecvBufferFrom</a>.    ^0"
s[185] = "blcksock.TUDPBlockSocket^blcksock.TUDPBlockSocket.html^Implementation of UDP socket.^ NOTE: in this class is all receiving redirected to RecvBufferFrom. You can use for reading any receive function. Preffered is RecvPacket! Similary all sending is redirected to SendbufferTo. You can use for sending UDP packet any sending function, like SendString.    <p>Supported features: IPv4, IPv6, unicasts, broadcasts, multicasts, SOCKS5 proxy (only unicasts! Outgoing and incomming.) ^0"
s[186] = "blcksock.TUDPBlockSocket.Destroy^blcksock.TUDPBlockSocket.html#Destroy^^    ^0"
s[187] = "blcksock.TUDPBlockSocket.EnableBroadcast^blcksock.TUDPBlockSocket.html#EnableBroadcast^^Enable or disable sending of broadcasts. If seting OK, result is <code>True</code>. This method is not supported in SOCKS5 mode! IPv6 does not support broadcasts! In this case you must use Multicasts instead.    ^0"
s[188] = "blcksock.TUDPBlockSocket.SendBufferTo^blcksock.TUDPBlockSocket.html#SendBufferTo^^See <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#SendBufferTo\">SendBufferTo</a>    ^0"
s[189] = "blcksock.TUDPBlockSocket.RecvBufferFrom^blcksock.TUDPBlockSocket.html#RecvBufferFrom^^See <a class=\"normal\" href=\"blcksock.TBlockSocket.html\">TBlockSocket</a>.<a class=\"normal\" href=\"blcksock.TBlockSocket.html#RecvBufferFrom\">RecvBufferFrom</a>    ^0"
s[190] = "blcksock.TUDPBlockSocket.AddMulticast^blcksock.TUDPBlockSocket.html#AddMulticast^^Add this socket to given multicast group. You cannot use Multicasts in SOCKS mode!    ^0"
s[191] = "blcksock.TUDPBlockSocket.DropMulticast^blcksock.TUDPBlockSocket.html#DropMulticast^^Remove this socket from given multicast group.    ^0"
s[192] = "blcksock.TUDPBlockSocket.EnableMulticastLoop^blcksock.TUDPBlockSocket.html#EnableMulticastLoop^^All sended multicast datagrams is loopbacked to your interface too. (you can read your sended datas.) You can disable this feature by this function. This function not working on some Windows systems!    ^0"
s[193] = "blcksock.TUDPBlockSocket.GetSocketType^blcksock.TUDPBlockSocket.html#GetSocketType^^Return value of socket type. For UDP return SOCK_DGRAM.    ^0"
s[194] = "blcksock.TUDPBlockSocket.GetSocketProtocol^blcksock.TUDPBlockSocket.html#GetSocketProtocol^^Return value of protocol type for socket creation. For UDP return IPPROTO_UDP.    ^0"
s[195] = "blcksock.TUDPBlockSocket.MulticastTTL^blcksock.TUDPBlockSocket.html#MulticastTTL^^Set Time-to-live value for multicasts packets. It define number of routers for transfer of datas. If you set this to 1 (dafault system value), then multicasts packet goes only to you local network. If you need transport multicast packet to worldwide, then increase this value, but be carefull, lot of routers on internet does not transport multicasts packets! ^0"
s[196] = "blcksock.TICMPBlockSocket^blcksock.TICMPBlockSocket.html^Implementation of RAW ICMP socket.^ For this object you must have rights for creating RAW sockets! ^0"
s[197] = "blcksock.TICMPBlockSocket.GetSocketType^blcksock.TICMPBlockSocket.html#GetSocketType^^Return value of socket type. For RAW and ICMP return SOCK_RAW.    ^0"
s[198] = "blcksock.TICMPBlockSocket.GetSocketProtocol^blcksock.TICMPBlockSocket.html#GetSocketProtocol^^Return value of protocol type for socket creation. For ICMP returns IPPROTO_ICMP or IPPROTO_ICMPV6    ^0"
s[199] = "blcksock.TRAWBlockSocket^blcksock.TRAWBlockSocket.html^Implementation of RAW socket.^ For this object you must have rights for creating RAW sockets! ^0"
s[200] = "blcksock.TRAWBlockSocket.GetSocketType^blcksock.TRAWBlockSocket.html#GetSocketType^^Return value of socket type. For RAW and ICMP return SOCK_RAW.    ^0"
s[201] = "blcksock.TRAWBlockSocket.GetSocketProtocol^blcksock.TRAWBlockSocket.html#GetSocketProtocol^^Return value of protocol type for socket creation. For RAW returns IPPROTO_RAW.    ^0"
s[202] = "blcksock.TPGMMessageBlockSocket^blcksock.TPGMMessageBlockSocket.html^Implementation of PGM-message socket.^ Not all systems supports this protocol! ^0"
s[203] = "blcksock.TPGMMessageBlockSocket.GetSocketType^blcksock.TPGMMessageBlockSocket.html#GetSocketType^^Return value of socket type. For PGM-message return SOCK_RDM.    ^0"
s[204] = "blcksock.TPGMMessageBlockSocket.GetSocketProtocol^blcksock.TPGMMessageBlockSocket.html#GetSocketProtocol^^Return value of protocol type for socket creation. For PGM-message returns IPPROTO_RM.    ^0"
s[205] = "blcksock.TPGMStreamBlockSocket^blcksock.TPGMStreamBlockSocket.html^Implementation of PGM-stream socket.^ Not all systems supports this protocol! ^0"
s[206] = "blcksock.TPGMStreamBlockSocket.GetSocketType^blcksock.TPGMStreamBlockSocket.html#GetSocketType^^Return value of socket type. For PGM-stream return SOCK_STREAM.    ^0"
s[207] = "blcksock.TPGMStreamBlockSocket.GetSocketProtocol^blcksock.TPGMStreamBlockSocket.html#GetSocketProtocol^^Return value of protocol type for socket creation. For PGM-stream returns IPPROTO_RM.    ^0"
s[208] = "blcksock.TCustomSSL^blcksock.TCustomSSL.html^Parent class for all SSL plugins.^ This is abstract class defining interface for other SSL plugins.    <p>Instance of this class will be created for each <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>.    <p>Warning: not all methods and propertis can work in all existing SSL plugins! Please, read documentation of used SSL plugin. ^0"
s[209] = "blcksock.TCustomSSL.Create^blcksock.TCustomSSL.html#Create^^Create plugin class. it is called internally from <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>    ^0"
s[210] = "blcksock.TCustomSSL.Assign^blcksock.TCustomSSL.html#Assign^^Assign settings (certificates and configuration) from another SSL plugin class.    ^0"
s[211] = "blcksock.TCustomSSL.LibVersion^blcksock.TCustomSSL.html#LibVersion^^return description of used plugin. It usually return name and version of used SSL library.    ^0"
s[212] = "blcksock.TCustomSSL.LibName^blcksock.TCustomSSL.html#LibName^^return name of used plugin.    ^0"
s[213] = "blcksock.TCustomSSL.Connect^blcksock.TCustomSSL.html#Connect^^Do not call this directly. It is used internally by <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>!    <p>Here is needed code for start SSL connection.    ^0"
s[214] = "blcksock.TCustomSSL.Accept^blcksock.TCustomSSL.html#Accept^^Do not call this directly. It is used internally by <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>!    <p>Here is needed code for acept new SSL connection.    ^0"
s[215] = "blcksock.TCustomSSL.Shutdown^blcksock.TCustomSSL.html#Shutdown^^Do not call this directly. It is used internally by <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>!    <p>Here is needed code for hard shutdown of SSL connection. (for example, before socket is closed)    ^0"
s[216] = "blcksock.TCustomSSL.BiShutdown^blcksock.TCustomSSL.html#BiShutdown^^Do not call this directly. It is used internally by <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>!    <p>Here is needed code for soft shutdown of SSL connection. (for example, when you need to continue with unprotected connection.)    ^0"
s[217] = "blcksock.TCustomSSL.SendBuffer^blcksock.TCustomSSL.html#SendBuffer^^Do not call this directly. It is used internally by <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>!    <p>Here is needed code for sending some datas by SSL connection.    ^0"
s[218] = "blcksock.TCustomSSL.RecvBuffer^blcksock.TCustomSSL.html#RecvBuffer^^Do not call this directly. It is used internally by <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>!    <p>Here is needed code for receiving some datas by SSL connection.    ^0"
s[219] = "blcksock.TCustomSSL.WaitingData^blcksock.TCustomSSL.html#WaitingData^^Do not call this directly. It is used internally by <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>!    <p>Here is needed code for getting count of datas what waiting for read. If SSL plugin not allows this, then it should return 0.    ^0"
s[220] = "blcksock.TCustomSSL.GetSSLVersion^blcksock.TCustomSSL.html#GetSSLVersion^^Return string with identificator of SSL/TLS version of existing connection.    ^0"
s[221] = "blcksock.TCustomSSL.GetPeerSubject^blcksock.TCustomSSL.html#GetPeerSubject^^Return subject of remote SSL peer.    ^0"
s[222] = "blcksock.TCustomSSL.GetPeerSerialNo^blcksock.TCustomSSL.html#GetPeerSerialNo^^Return Serial number if remote X509 certificate.    ^0"
s[223] = "blcksock.TCustomSSL.GetPeerIssuer^blcksock.TCustomSSL.html#GetPeerIssuer^^Return issuer certificate of remote SSL peer.    ^0"
s[224] = "blcksock.TCustomSSL.GetPeerName^blcksock.TCustomSSL.html#GetPeerName^^Return peer name from remote side certificate. This is good for verify, if certificate is generated for remote side IP name.    ^0"
s[225] = "blcksock.TCustomSSL.GetPeerNameHash^blcksock.TCustomSSL.html#GetPeerNameHash^^Returns has of peer name from remote side certificate. This is good for fast remote side authentication.    ^0"
s[226] = "blcksock.TCustomSSL.GetPeerFingerprint^blcksock.TCustomSSL.html#GetPeerFingerprint^^Return fingerprint of remote SSL peer.    ^0"
s[227] = "blcksock.TCustomSSL.GetCertInfo^blcksock.TCustomSSL.html#GetCertInfo^^Return all detailed information about certificate from remote side of SSL/TLS connection. Result string can be multilined! Each plugin can return this informations in different format!    ^0"
s[228] = "blcksock.TCustomSSL.GetCipherName^blcksock.TCustomSSL.html#GetCipherName^^Return currently used Cipher.    ^0"
s[229] = "blcksock.TCustomSSL.GetCipherBits^blcksock.TCustomSSL.html#GetCipherBits^^Return currently used number of bits in current Cipher algorythm.    ^0"
s[230] = "blcksock.TCustomSSL.GetCipherAlgBits^blcksock.TCustomSSL.html#GetCipherAlgBits^^Return number of bits in current Cipher algorythm.    ^0"
s[231] = "blcksock.TCustomSSL.GetVerifyCert^blcksock.TCustomSSL.html#GetVerifyCert^^Return result value of verify remote side certificate. Look to OpenSSL documentation for possible values. For example 0 is successfuly verified certificate, or 18 is self-signed certificate.    ^0"
s[232] = "blcksock.TCustomSSL.SSLEnabled^blcksock.TCustomSSL.html#SSLEnabled^^Resurn <code>True</code> if SSL mode is enabled on existing cvonnection. ^0"
s[233] = "blcksock.TCustomSSL.LastError^blcksock.TCustomSSL.html#LastError^^Return error code of last SSL operation. 0 is OK. ^0"
s[234] = "blcksock.TCustomSSL.LastErrorDesc^blcksock.TCustomSSL.html#LastErrorDesc^^Return error description of last SSL operation. ^0"
s[235] = "blcksock.TCustomSSL.SSLType^blcksock.TCustomSSL.html#SSLType^^Here you can specify requested SSL/TLS mode. Default is autodetection, but on some servers autodetection not working properly. In this case you must specify requested SSL/TLS mode by your hand! ^0"
s[236] = "blcksock.TCustomSSL.KeyPassword^blcksock.TCustomSSL.html#KeyPassword^^Password for decrypting of encoded certificate or key. ^0"
s[237] = "blcksock.TCustomSSL.Username^blcksock.TCustomSSL.html#Username^^Username for possible credentials. ^0"
s[238] = "blcksock.TCustomSSL.Password^blcksock.TCustomSSL.html#Password^^password for possible credentials. ^0"
s[239] = "blcksock.TCustomSSL.Ciphers^blcksock.TCustomSSL.html#Ciphers^^By this property you can modify default set of SSL/TLS ciphers. ^0"
s[240] = "blcksock.TCustomSSL.CertificateFile^blcksock.TCustomSSL.html#CertificateFile^^Used for loading certificate from disk file. See to plugin documentation if this method is supported and how! ^0"
s[241] = "blcksock.TCustomSSL.PrivateKeyFile^blcksock.TCustomSSL.html#PrivateKeyFile^^Used for loading private key from disk file. See to plugin documentation if this method is supported and how! ^0"
s[242] = "blcksock.TCustomSSL.Certificate^blcksock.TCustomSSL.html#Certificate^^Used for loading certificate from binary string. See to plugin documentation if this method is supported and how! ^0"
s[243] = "blcksock.TCustomSSL.PrivateKey^blcksock.TCustomSSL.html#PrivateKey^^Used for loading private key from binary string. See to plugin documentation if this method is supported and how! ^0"
s[244] = "blcksock.TCustomSSL.PFX^blcksock.TCustomSSL.html#PFX^^Used for loading PFX from binary string. See to plugin documentation if this method is supported and how! ^0"
s[245] = "blcksock.TCustomSSL.PFXfile^blcksock.TCustomSSL.html#PFXfile^^Used for loading PFX from disk file. See to plugin documentation if this method is supported and how! ^0"
s[246] = "blcksock.TCustomSSL.TrustCertificateFile^blcksock.TCustomSSL.html#TrustCertificateFile^^Used for loading trusted certificates from disk file. See to plugin documentation if this method is supported and how! ^0"
s[247] = "blcksock.TCustomSSL.TrustCertificate^blcksock.TCustomSSL.html#TrustCertificate^^Used for loading trusted certificates from binary string. See to plugin documentation if this method is supported and how! ^0"
s[248] = "blcksock.TCustomSSL.CertCA^blcksock.TCustomSSL.html#CertCA^^Used for loading CA certificates from binary string. See to plugin documentation if this method is supported and how! ^0"
s[249] = "blcksock.TCustomSSL.CertCAFile^blcksock.TCustomSSL.html#CertCAFile^^Used for loading CA certificates from disk file. See to plugin documentation if this method is supported and how! ^0"
s[250] = "blcksock.TCustomSSL.VerifyCert^blcksock.TCustomSSL.html#VerifyCert^^If <code>True</code>, then is verified client certificate. (it is good for writing SSL/TLS servers.) When you are not server, but you are client, then if this property is <code>True</code>, verify servers certificate. ^0"
s[251] = "blcksock.TCustomSSL.SSHChannelType^blcksock.TCustomSSL.html#SSHChannelType^^channel type for possible SSH connections ^0"
s[252] = "blcksock.TCustomSSL.SSHChannelArg1^blcksock.TCustomSSL.html#SSHChannelArg1^^First argument of channel type for possible SSH connections ^0"
s[253] = "blcksock.TCustomSSL.SSHChannelArg2^blcksock.TCustomSSL.html#SSHChannelArg2^^Second argument of channel type for possible SSH connections ^0"
s[254] = "blcksock.TCustomSSL.CertComplianceLevel^blcksock.TCustomSSL.html#CertComplianceLevel^^Level of standards compliance level (CryptLib: values in cryptlib.pas, -1: use default value ) ^0"
s[255] = "blcksock.TCustomSSL.OnVerifyCert^blcksock.TCustomSSL.html#OnVerifyCert^^This event is called when verifying the server certificate immediatally after a successfull verification in the ssl library. ^0"
s[256] = "blcksock.TCustomSSL.SNIHost^blcksock.TCustomSSL.html#SNIHost^^Server Name Identification. Host name to send to server. If empty the host name found in URL will be used, which should be the normal use (http Header Host = SNI Host). The value is cleared after the connection is established. (SNI support requires OpenSSL 0.9.8k or later. Cryptlib not supported, yet ) ^0"
s[257] = "blcksock.TSSLNone^blcksock.TSSLNone.html^Default SSL plugin with no SSL support.^ Dummy SSL plugin implementation for applications without SSL/TLS support. ^0"
s[258] = "blcksock.TSSLNone.LibVersion^blcksock.TSSLNone.html#LibVersion^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#LibVersion\">LibVersion</a>    ^0"
s[259] = "blcksock.TSSLNone.LibName^blcksock.TSSLNone.html#LibName^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#LibName\">LibName</a>    ^0"
s[260] = "blcksock.TIPHeader^blcksock.TIPHeader.html^Record with definition of IP packet header.^ For reading data from ICMP or RAW sockets. ^0"
s[261] = "blcksock.TIPHeader.VerLen^blcksock.TIPHeader.html#VerLen^^ ^0"
s[262] = "blcksock.TIPHeader.TOS^blcksock.TIPHeader.html#TOS^^ ^0"
s[263] = "blcksock.TIPHeader.TotalLen^blcksock.TIPHeader.html#TotalLen^^ ^0"
s[264] = "blcksock.TIPHeader.Identifer^blcksock.TIPHeader.html#Identifer^^ ^0"
s[265] = "blcksock.TIPHeader.FragOffsets^blcksock.TIPHeader.html#FragOffsets^^ ^0"
s[266] = "blcksock.TIPHeader.TTL^blcksock.TIPHeader.html#TTL^^ ^0"
s[267] = "blcksock.TIPHeader.Protocol^blcksock.TIPHeader.html#Protocol^^ ^0"
s[268] = "blcksock.TIPHeader.CheckSum^blcksock.TIPHeader.html#CheckSum^^ ^0"
s[269] = "blcksock.TIPHeader.SourceIp^blcksock.TIPHeader.html#SourceIp^^ ^0"
s[270] = "blcksock.TIPHeader.DestIp^blcksock.TIPHeader.html#DestIp^^ ^0"
s[271] = "blcksock.TIPHeader.Options^blcksock.TIPHeader.html#Options^^ ^0"
s[272] = "blcksock.TSynaClient^blcksock.TSynaClient.html^Parent class of application protocol implementations.^ By this class is defined common properties. ^0"
s[273] = "blcksock.TSynaClient.Create^blcksock.TSynaClient.html#Create^^    ^0"
s[274] = "blcksock.TSynaClient.TargetHost^blcksock.TSynaClient.html#TargetHost^^Specify terget server IP (or symbolic name). Default is 'localhost'. ^0"
s[275] = "blcksock.TSynaClient.TargetPort^blcksock.TSynaClient.html#TargetPort^^Specify terget server port (or symbolic name). ^0"
s[276] = "blcksock.TSynaClient.IPInterface^blcksock.TSynaClient.html#IPInterface^^Defined local socket address. (outgoing IP address). By default is used '0.0.0.0' as wildcard for default IP. ^0"
s[277] = "blcksock.TSynaClient.Timeout^blcksock.TSynaClient.html#Timeout^^Specify default timeout for socket operations. ^0"
s[278] = "blcksock.TSynaClient.UserName^blcksock.TSynaClient.html#UserName^^If protocol need user authorization, then fill here username. ^0"
s[279] = "blcksock.TSynaClient.Password^blcksock.TSynaClient.html#Password^^If protocol need user authorization, then fill here password. ^0"
s[280] = "blcksock.SynapseRelease^blcksock.html#SynapseRelease^^ ^0"
s[281] = "blcksock.cLocalhost^blcksock.html#cLocalhost^^ ^0"
s[282] = "blcksock.cAnyHost^blcksock.html#cAnyHost^^ ^0"
s[283] = "blcksock.cBroadcast^blcksock.html#cBroadcast^^ ^0"
s[284] = "blcksock.c6Localhost^blcksock.html#c6Localhost^^ ^0"
s[285] = "blcksock.c6AnyHost^blcksock.html#c6AnyHost^^ ^0"
s[286] = "blcksock.c6Broadcast^blcksock.html#c6Broadcast^^ ^0"
s[287] = "blcksock.cAnyPort^blcksock.html#cAnyPort^^ ^0"
s[288] = "blcksock.CR^blcksock.html#CR^^ ^0"
s[289] = "blcksock.LF^blcksock.html#LF^^ ^0"
s[290] = "blcksock.CRLF^blcksock.html#CRLF^^ ^0"
s[291] = "blcksock.c64k^blcksock.html#c64k^^ ^0"
s[292] = "blcksock.THookSocketReason^blcksock.html#THookSocketReason^^Types of OnStatus events  HR_ResolvingBegin  Resolving is begin. Resolved IP and port is in parameter in format like: 'localhost.somewhere.com:25'.  HR_ResolvingEnd  Resolving is done. Resolved IP and port is in parameter in format like: 'localhost.somewhere.com:25'. It is always same as in HR_ResolvingBegin!  HR_SocketCreate  Socket created by CreateSocket method. It reporting Family of created socket too!  HR_SocketClose  Socket closed by CloseSocket method.  HR_Bind  Socket binded to IP and Port. Binded IP and Port is in parameter in format like: 'localhost.somewhere.com:25'.  HR_Connect  Socket connected to IP and Port. Connected IP and Port is in parameter in format like: 'localhost.somewhere.com:25'.  HR_CanRead  Called when CanRead method is used with <code>True</code> result.  HR_CanWrite  Called when CanWrite method is used with <code>True</code> result.  HR_Listen  Socket is swithed to Listen mode. (TCP socket only)  HR_Accept  Socket Accepting client connection. (TCP socket only)  HR_ReadCount  report count of bytes readed from socket. Number is in parameter string. If you need is in integer, you must use StrToInt function!  HR_WriteCount  report count of bytes writed to socket. Number is in parameter string. If you need is in integer, you must use StrToInt function!  HR_Wait  If is limiting of bandwidth on, then this reason is called when sending or receiving is stopped for satisfy bandwidth limit. Parameter is count of waiting milliseconds.  HR_Error  report situation where communication error occured. When raiseexcept is <code>True</code>, then exception is called after this Hook reason. ^0"
s[293] = "blcksock.THookSocketStatus^blcksock.html#THookSocketStatus^^Procedural type for OnStatus event. Sender is calling TBlockSocket object, Reason is one of set Status events and value is optional data.    ^0"
s[294] = "blcksock.THookDataFilter^blcksock.html#THookDataFilter^^This procedural type is used for DataFilter hooks.    ^0"
s[295] = "blcksock.THookCreateSocket^blcksock.html#THookCreateSocket^^This procedural type is used for hook OnCreateSocket. By this hook you can insert your code after initialisation of socket. (you can set special socket options, etc.)    ^0"
s[296] = "blcksock.THookMonitor^blcksock.html#THookMonitor^^This procedural type is used for monitoring of communication.    ^0"
s[297] = "blcksock.THookAfterConnect^blcksock.html#THookAfterConnect^^This procedural type is used for hook OnAfterConnect. By this hook you can insert your code after TCP socket has been sucessfully connected.    ^0"
s[298] = "blcksock.THookVerifyCert^blcksock.html#THookVerifyCert^^This procedural type is used for hook OnVerifyCert. By this hook you can insert your additional certificate verification code. Usefull to verify server CN against URL.    ^0"
s[299] = "blcksock.THookHeartbeat^blcksock.html#THookHeartbeat^^This procedural type is used for hook OnHeartbeat. By this hook you can call your code repeately during long socket operations. You must enable heartbeats by <code>HeartbeatRate</code> property!    ^0"
s[300] = "blcksock.TSocketFamily^blcksock.html#TSocketFamily^^Specify family of socket.  SF_Any  Default mode. Socket family is defined by target address for connection. It allows instant access to IPv4 and IPv6 nodes. When you need IPv6 address as destination, then is used IPv6 mode. othervise is used IPv4 mode. However this mode not working properly with preliminary IPv6 supports!  SF_IP4  Turn this class to pure IPv4 mode. This mode is totally compatible with previous Synapse releases.  SF_IP6  Turn to only IPv6 mode. ^0"
s[301] = "blcksock.TSocksType^blcksock.html#TSocksType^^specify possible values of SOCKS modes.  ST_Socks5    ST_Socks4   ^0"
s[302] = "blcksock.TSSLType^blcksock.html#TSSLType^^Specify requested SSL/TLS version for secure connection.  LT_all    LT_SSLv2    LT_SSLv3    LT_TLSv1    LT_TLSv1_1    LT_SSHv2   ^0"
s[303] = "blcksock.TSynaOptionType^blcksock.html#TSynaOptionType^^Specify type of socket delayed option.  SOT_Linger    SOT_RecvBuff    SOT_SendBuff    SOT_NonBlock    SOT_RecvTimeout    SOT_SendTimeout    SOT_Reuse    SOT_TTL    SOT_Broadcast    SOT_MulticastTTL    SOT_MulticastLoop   ^0"
s[304] = "blcksock.TSSLClass^blcksock.html#TSSLClass^^ ^0"
s[305] = "blcksock.SSLImplementation^blcksock.html#SSLImplementation^^Selected SSL plugin. Default is <a class=\"normal\" href=\"blcksock.TSSLNone.html\">TSSLNone</a>.    <p>Do not change this value directly!!!    <p>Just add your plugin unit to your project uses instead. Each plugin unit have initialization code what modify this variable. ^0"
s[306] = "clamsend^clamsend.html^ ClamAV-daemon client^    <p>This unit is capable to do antivirus scan of your data by TCP channel to ClamD daemon from ClamAV. See more about ClamAV on UNKNOWN ^0"
s[307] = "clamsend.TClamSend^clamsend.TClamSend.html^Implementation of ClamAV-daemon client protocol^ By this class you can scan any your data by ClamAV opensource antivirus.    <p>This class can connect to ClamD by TCP channel, send your data to ClamD and read result. ^0"
s[308] = "clamsend.TClamSend.Create^clamsend.TClamSend.html#Create^^    ^0"
s[309] = "clamsend.TClamSend.Destroy^clamsend.TClamSend.html#Destroy^^    ^0"
s[310] = "clamsend.TClamSend.DoCommand^clamsend.TClamSend.html#DoCommand^^Call any command to ClamD. Used internally by other methods.    ^0"
s[311] = "clamsend.TClamSend.GetVersion^clamsend.TClamSend.html#GetVersion^^Return ClamAV version and version of loaded databases.    ^0"
s[312] = "clamsend.TClamSend.ScanStrings^clamsend.TClamSend.html#ScanStrings^^Scan content of TStrings.    ^0"
s[313] = "clamsend.TClamSend.ScanStream^clamsend.TClamSend.html#ScanStream^^Scan content of TStream.    ^0"
s[314] = "clamsend.TClamSend.ScanStrings2^clamsend.TClamSend.html#ScanStrings2^^Scan content of TStrings by new 0.95 API.    ^0"
s[315] = "clamsend.TClamSend.ScanStream2^clamsend.TClamSend.html#ScanStream2^^Scan content of TStream by new 0.95 API.    ^0"
s[316] = "clamsend.TClamSend.Sock^clamsend.TClamSend.html#Sock^^Socket object used for TCP/IP operation. Good for seting OnStatus hook, etc. ^0"
s[317] = "clamsend.TClamSend.DSock^clamsend.TClamSend.html#DSock^^Socket object used for TCP data transfer operation. Good for seting OnStatus hook, etc. ^0"
s[318] = "clamsend.TClamSend.Session^clamsend.TClamSend.html#Session^^Can turn-on session mode of communication with ClamD. Default is <code>False</code>, because ClamAV developers design their TCP code very badly and session mode is broken now (CVS-20051031). Maybe ClamAV developers fix their bugs and this mode will be possible in future. ^0"
s[319] = "clamsend.cClamProtocol^clamsend.html#cClamProtocol^^ ^0"
s[320] = "dnssend^dnssend.html^DNS client by UDP or TCP^ Support for sending DNS queries by UDP or TCP protocol. It can retrieve zone transfers too!    <p>Used RFC: RFC-1035, RFC-1183, RFC1706, RFC1712, RFC2163, RFC2230 ^0"
s[321] = "dnssend.TDNSSend^dnssend.TDNSSend.html^Implementation of DNS protocol by UDP or TCP protocol.^    <p>Note: Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[322] = "dnssend.TDNSSend.Create^dnssend.TDNSSend.html#Create^^    ^0"
s[323] = "dnssend.TDNSSend.Destroy^dnssend.TDNSSend.html#Destroy^^    ^0"
s[324] = "dnssend.TDNSSend.DNSQuery^dnssend.TDNSSend.html#DNSQuery^^Query a DNSHost for QType resources correspond to a name. Supported QType values are: Qtype_A, Qtype_NS, Qtype_MD, Qtype_MF, Qtype_CNAME, Qtype_SOA, Qtype_MB, Qtype_MG, Qtype_MR, Qtype_NULL, Qtype_PTR, Qtype_HINFO, Qtype_MINFO, Qtype_MX, Qtype_TXT, Qtype_RP, Qtype_AFSDB, Qtype_X25, Qtype_ISDN, Qtype_RT, Qtype_NSAP, Qtype_NSAPPTR, Qtype_PX, Qtype_GPOS, Qtype_KX.    <p>Type for zone transfers QTYPE_AXFR is supported too, but only in TCP mode!    <p>&quot;Name&quot; is domain name or host name for queried resource. If &quot;name&quot; is IP address, automatically convert to reverse domain form (.in-addr.arpa).    <p>If result is <code>True</code>, Reply contains resource records. One record on one line. If Resource record have multiple fields, they are stored on line divided by comma. (example: MX record contains value 'rs.cesnet.cz' with preference number 10, string in Reply is: '10,rs.cesnet.cz'). All numbers or IP address in resource are converted to string form.    ^0"
s[325] = "dnssend.TDNSSend.Sock^dnssend.TDNSSend.html#Sock^^Socket object used for UDP operation. Good for seting OnStatus hook, etc. ^0"
s[326] = "dnssend.TDNSSend.TCPSock^dnssend.TDNSSend.html#TCPSock^^Socket object used for TCP operation. Good for seting OnStatus hook, etc. ^0"
s[327] = "dnssend.TDNSSend.UseTCP^dnssend.TDNSSend.html#UseTCP^^if <code>True</code>, then is used TCP protocol instead UDP. It is needed for zone transfers, etc. ^0"
s[328] = "dnssend.TDNSSend.RCode^dnssend.TDNSSend.html#RCode^^After DNS operation contains ResultCode of DNS operation. Values are: 0-no error, 1-format error, 2-server failure, 3-name error, 4-not implemented, 5-refused. ^0"
s[329] = "dnssend.TDNSSend.Authoritative^dnssend.TDNSSend.html#Authoritative^^<code>True</code>, if answer is authoritative. ^0"
s[330] = "dnssend.TDNSSend.Truncated^dnssend.TDNSSend.html#Truncated^^<code>True</code>, if answer is truncated to 512 bytes. ^0"
s[331] = "dnssend.TDNSSend.AnswerInfo^dnssend.TDNSSend.html#AnswerInfo^^Detailed informations from name server reply. One record per line. Record have comma delimited entries with type number, TTL and data filelds. This information contains detailed information about query reply. ^0"
s[332] = "dnssend.TDNSSend.NameserverInfo^dnssend.TDNSSend.html#NameserverInfo^^Detailed informations from name server reply. One record per line. Record have comma delimited entries with type number, TTL and data filelds. This information contains detailed information about nameserver. ^0"
s[333] = "dnssend.TDNSSend.AdditionalInfo^dnssend.TDNSSend.html#AdditionalInfo^^Detailed informations from name server reply. One record per line. Record have comma delimited entries with type number, TTL and data filelds. This information contains detailed additional information. ^0"
s[334] = "dnssend.cDnsProtocol^dnssend.html#cDnsProtocol^^ ^0"
s[335] = "dnssend.QTYPE_A^dnssend.html#QTYPE_A^^ ^0"
s[336] = "dnssend.QTYPE_NS^dnssend.html#QTYPE_NS^^ ^0"
s[337] = "dnssend.QTYPE_MD^dnssend.html#QTYPE_MD^^ ^0"
s[338] = "dnssend.QTYPE_MF^dnssend.html#QTYPE_MF^^ ^0"
s[339] = "dnssend.QTYPE_CNAME^dnssend.html#QTYPE_CNAME^^ ^0"
s[340] = "dnssend.QTYPE_SOA^dnssend.html#QTYPE_SOA^^ ^0"
s[341] = "dnssend.QTYPE_MB^dnssend.html#QTYPE_MB^^ ^0"
s[342] = "dnssend.QTYPE_MG^dnssend.html#QTYPE_MG^^ ^0"
s[343] = "dnssend.QTYPE_MR^dnssend.html#QTYPE_MR^^ ^0"
s[344] = "dnssend.QTYPE_NULL^dnssend.html#QTYPE_NULL^^ ^0"
s[345] = "dnssend.QTYPE_WKS^dnssend.html#QTYPE_WKS^^ ^0"
s[346] = "dnssend.QTYPE_PTR^dnssend.html#QTYPE_PTR^^ ^0"
s[347] = "dnssend.QTYPE_HINFO^dnssend.html#QTYPE_HINFO^^ ^0"
s[348] = "dnssend.QTYPE_MINFO^dnssend.html#QTYPE_MINFO^^ ^0"
s[349] = "dnssend.QTYPE_MX^dnssend.html#QTYPE_MX^^ ^0"
s[350] = "dnssend.QTYPE_TXT^dnssend.html#QTYPE_TXT^^ ^0"
s[351] = "dnssend.QTYPE_RP^dnssend.html#QTYPE_RP^^ ^0"
s[352] = "dnssend.QTYPE_AFSDB^dnssend.html#QTYPE_AFSDB^^ ^0"
s[353] = "dnssend.QTYPE_X25^dnssend.html#QTYPE_X25^^ ^0"
s[354] = "dnssend.QTYPE_ISDN^dnssend.html#QTYPE_ISDN^^ ^0"
s[355] = "dnssend.QTYPE_RT^dnssend.html#QTYPE_RT^^ ^0"
s[356] = "dnssend.QTYPE_NSAP^dnssend.html#QTYPE_NSAP^^ ^0"
s[357] = "dnssend.QTYPE_NSAPPTR^dnssend.html#QTYPE_NSAPPTR^^ ^0"
s[358] = "dnssend.QTYPE_SIG^dnssend.html#QTYPE_SIG^^ ^0"
s[359] = "dnssend.QTYPE_KEY^dnssend.html#QTYPE_KEY^^ ^0"
s[360] = "dnssend.QTYPE_PX^dnssend.html#QTYPE_PX^^ ^0"
s[361] = "dnssend.QTYPE_GPOS^dnssend.html#QTYPE_GPOS^^ ^0"
s[362] = "dnssend.QTYPE_AAAA^dnssend.html#QTYPE_AAAA^^ ^0"
s[363] = "dnssend.QTYPE_LOC^dnssend.html#QTYPE_LOC^^ ^0"
s[364] = "dnssend.QTYPE_NXT^dnssend.html#QTYPE_NXT^^ ^0"
s[365] = "dnssend.QTYPE_SRV^dnssend.html#QTYPE_SRV^^ ^0"
s[366] = "dnssend.QTYPE_NAPTR^dnssend.html#QTYPE_NAPTR^^ ^0"
s[367] = "dnssend.QTYPE_KX^dnssend.html#QTYPE_KX^^ ^0"
s[368] = "dnssend.QTYPE_SPF^dnssend.html#QTYPE_SPF^^ ^0"
s[369] = "dnssend.QTYPE_AXFR^dnssend.html#QTYPE_AXFR^^ ^0"
s[370] = "dnssend.QTYPE_MAILB^dnssend.html#QTYPE_MAILB^^ ^0"
s[371] = "dnssend.QTYPE_MAILA^dnssend.html#QTYPE_MAILA^^ ^0"
s[372] = "dnssend.QTYPE_ALL^dnssend.html#QTYPE_ALL^^ ^0"
s[373] = "dnssend.GetMailServers^dnssend.html#GetMailServers^^A very useful function, and example of it's use is found in the TDNSSend object. This function is used to get mail servers for a domain and sort them by preference numbers. &quot;Servers&quot; contains only the domain names of the mail servers in the right order (without preference number!). The first domain name will always be the highest preferenced mail server. Returns boolean <code>True</code> if all went well.    ^0"
s[374] = "ftpsend^ftpsend.html^^ ^0"
s[375] = "ftpsend.TFTPListRec^ftpsend.TFTPListRec.html^Object for holding file information^ parsed from directory listing of FTP server. ^0"
s[376] = "ftpsend.TFTPListRec.Assign^ftpsend.TFTPListRec.html#Assign^^You can assign another TFTPListRec to this object.    ^0"
s[377] = "ftpsend.TFTPListRec.FileName^ftpsend.TFTPListRec.html#FileName^^name of file ^0"
s[378] = "ftpsend.TFTPListRec.Directory^ftpsend.TFTPListRec.html#Directory^^if name is subdirectory not file. ^0"
s[379] = "ftpsend.TFTPListRec.Readable^ftpsend.TFTPListRec.html#Readable^^if you have rights to read ^0"
s[380] = "ftpsend.TFTPListRec.FileSize^ftpsend.TFTPListRec.html#FileSize^^size of file in bytes ^0"
s[381] = "ftpsend.TFTPListRec.FileTime^ftpsend.TFTPListRec.html#FileTime^^date and time of file. Local server timezone is used. Any timezone conversions was not done! ^0"
s[382] = "ftpsend.TFTPListRec.OriginalLine^ftpsend.TFTPListRec.html#OriginalLine^^original unparsed line ^0"
s[383] = "ftpsend.TFTPListRec.Mask^ftpsend.TFTPListRec.html#Mask^^mask what was used for parsing ^0"
s[384] = "ftpsend.TFTPListRec.Permission^ftpsend.TFTPListRec.html#Permission^^permission string (depending on used mask!) ^0"
s[385] = "ftpsend.TFTPList^ftpsend.TFTPList.html^This is TList of TFTPListRec objects.^ This object is used for holding lististing of all files information in listed directory on FTP server. ^0"
s[386] = "ftpsend.TFTPList.Create^ftpsend.TFTPList.html#Create^^Constructor. You not need create this object, it is created by TFTPSend class as their property.    ^0"
s[387] = "ftpsend.TFTPList.Destroy^ftpsend.TFTPList.html#Destroy^^    ^0"
s[388] = "ftpsend.TFTPList.Clear^ftpsend.TFTPList.html#Clear^^Clear list.    ^0"
s[389] = "ftpsend.TFTPList.Count^ftpsend.TFTPList.html#Count^^count of holded <a class=\"normal\" href=\"ftpsend.TFTPListRec.html\">TFTPListRec</a> objects    ^0"
s[390] = "ftpsend.TFTPList.Assign^ftpsend.TFTPList.html#Assign^^Assigns one list to another    ^0"
s[391] = "ftpsend.TFTPList.ParseLines^ftpsend.TFTPList.html#ParseLines^^try to parse raw directory listing in <a class=\"normal\" href=\"ftpsend.TFTPList.html#Lines\">Lines</a> to list of <a class=\"normal\" href=\"ftpsend.TFTPListRec.html\">TFTPListRec</a>.    ^0"
s[392] = "ftpsend.TFTPList.List^ftpsend.TFTPList.html#List^^By this property you have access to list of <a class=\"normal\" href=\"ftpsend.TFTPListRec.html\">TFTPListRec</a>. This is for compatibility only. Please, use <a class=\"normal\" href=\"ftpsend.TFTPList.html#Items\">Items</a> instead. ^0"
s[393] = "ftpsend.TFTPList.Items^ftpsend.TFTPList.html#Items^^By this property you have access to list of <a class=\"normal\" href=\"ftpsend.TFTPListRec.html\">TFTPListRec</a>. ^0"
s[394] = "ftpsend.TFTPList.Lines^ftpsend.TFTPList.html#Lines^^Set of lines with RAW directory listing for <a class=\"normal\" href=\"ftpsend.TFTPList.html#ParseLines\">ParseLines</a> ^0"
s[395] = "ftpsend.TFTPList.Masks^ftpsend.TFTPList.html#Masks^^Set of masks for directory listing parser. It is predefined by default, however you can modify it as you need. (for example, you can add your own definition mask.) Mask is same as mask used in TotalCommander. ^0"
s[396] = "ftpsend.TFTPList.UnparsedLines^ftpsend.TFTPList.html#UnparsedLines^^After <a class=\"normal\" href=\"ftpsend.TFTPList.html#ParseLines\">ParseLines</a> it holding lines what was not sucessfully parsed. ^0"
s[397] = "ftpsend.TFTPSend^ftpsend.TFTPSend.html^Implementation of FTP protocol.^ Note: Are you missing properties for setting Username and Password? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> object! (Username and Password have default values for &quot;anonymous&quot; FTP login)    <p>Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[398] = "ftpsend.TFTPSend.CustomLogon^ftpsend.TFTPSend.html#CustomLogon^^Custom definition of login sequence. You can use this when you set <a class=\"normal\" href=\"ftpsend.TFTPSend.html#FWMode\">FWMode</a> to value -1. ^0"
s[399] = "ftpsend.TFTPSend.Create^ftpsend.TFTPSend.html#Create^^    ^0"
s[400] = "ftpsend.TFTPSend.Destroy^ftpsend.TFTPSend.html#Destroy^^    ^0"
s[401] = "ftpsend.TFTPSend.ReadResult^ftpsend.TFTPSend.html#ReadResult^^Waits and read FTP server response. You need this only in special cases!    ^0"
s[402] = "ftpsend.TFTPSend.ParseRemote^ftpsend.TFTPSend.html#ParseRemote^^Parse remote side information of data channel from value string (returned by PASV command). This function you need only in special cases!    ^0"
s[403] = "ftpsend.TFTPSend.ParseRemoteEPSV^ftpsend.TFTPSend.html#ParseRemoteEPSV^^Parse remote side information of data channel from value string (returned by EPSV command). This function you need only in special cases!    ^0"
s[404] = "ftpsend.TFTPSend.FTPCommand^ftpsend.TFTPSend.html#FTPCommand^^Send Value as FTP command to FTP server. Returned result code is result of this function. This command is good for sending site specific command, or non-standard commands.    ^0"
s[405] = "ftpsend.TFTPSend.Login^ftpsend.TFTPSend.html#Login^^Connect and logon to FTP server. If you specify any FireWall, connect to firewall and throw them connect to FTP server. Login sequence depending on <a class=\"normal\" href=\"ftpsend.TFTPSend.html#FWMode\">FWMode</a>.    ^0"
s[406] = "ftpsend.TFTPSend.Logout^ftpsend.TFTPSend.html#Logout^^Logoff and disconnect from FTP server.    ^0"
s[407] = "ftpsend.TFTPSend.Abort^ftpsend.TFTPSend.html#Abort^^Break current transmission of data. (You can call this method from Sock.OnStatus event, or from another thread.)    ^0"
s[408] = "ftpsend.TFTPSend.TelnetAbort^ftpsend.TFTPSend.html#TelnetAbort^^Break current transmission of data. It is same as Abort, but it send abort telnet commands prior ABOR FTP command. Some servers need it. (You can call this method from Sock.OnStatus event, or from another thread.)    ^0"
s[409] = "ftpsend.TFTPSend.List^ftpsend.TFTPSend.html#List^^Download directory listing of Directory on FTP server. If Directory is empty string, download listing of current working directory. If NameList is <code>True</code>, download only names of files in directory. (internally use NLST command instead LIST command) If NameList is <code>False</code>, returned list is also parsed to <a class=\"normal\" href=\"ftpsend.TFTPSend.html#FtpList\">FtpList</a> property.    ^0"
s[410] = "ftpsend.TFTPSend.RetrieveFile^ftpsend.TFTPSend.html#RetrieveFile^^Read data from FileName on FTP server. If Restore is <code>True</code> and server supports resume dowloads, download is resumed. (received is only rest of file)    ^0"
s[411] = "ftpsend.TFTPSend.StoreFile^ftpsend.TFTPSend.html#StoreFile^^Send data to FileName on FTP server. If Restore is <code>True</code> and server supports resume upload, upload is resumed. (send only rest of file) In this case if remote file is same length as local file, nothing will be done. If remote file is larger then local, resume is disabled and file is transfered from begin!    ^0"
s[412] = "ftpsend.TFTPSend.StoreUniqueFile^ftpsend.TFTPSend.html#StoreUniqueFile^^Send data to FTP server and assing unique name for this file.    ^0"
s[413] = "ftpsend.TFTPSend.AppendFile^ftpsend.TFTPSend.html#AppendFile^^Append data to FileName on FTP server.    ^0"
s[414] = "ftpsend.TFTPSend.RenameFile^ftpsend.TFTPSend.html#RenameFile^^Rename on FTP server file with OldName to NewName.    ^0"
s[415] = "ftpsend.TFTPSend.DeleteFile^ftpsend.TFTPSend.html#DeleteFile^^Delete file FileName on FTP server.    ^0"
s[416] = "ftpsend.TFTPSend.FileSize^ftpsend.TFTPSend.html#FileSize^^Return size of Filename file on FTP server. If command failed (i.e. not implemented), return -1.    ^0"
s[417] = "ftpsend.TFTPSend.NoOp^ftpsend.TFTPSend.html#NoOp^^Send NOOP command to FTP server for preserve of disconnect by inactivity timeout.    ^0"
s[418] = "ftpsend.TFTPSend.ChangeWorkingDir^ftpsend.TFTPSend.html#ChangeWorkingDir^^Change currect working directory to Directory on FTP server.    ^0"
s[419] = "ftpsend.TFTPSend.ChangeToParentDir^ftpsend.TFTPSend.html#ChangeToParentDir^^walk to upper directory on FTP server.    ^0"
s[420] = "ftpsend.TFTPSend.ChangeToRootDir^ftpsend.TFTPSend.html#ChangeToRootDir^^walk to root directory on FTP server. (May not work with all servers properly!)    ^0"
s[421] = "ftpsend.TFTPSend.DeleteDir^ftpsend.TFTPSend.html#DeleteDir^^Delete Directory on FTP server.    ^0"
s[422] = "ftpsend.TFTPSend.CreateDir^ftpsend.TFTPSend.html#CreateDir^^Create Directory on FTP server.    ^0"
s[423] = "ftpsend.TFTPSend.GetCurrentDir^ftpsend.TFTPSend.html#GetCurrentDir^^Return current working directory on FTP server.    ^0"
s[424] = "ftpsend.TFTPSend.DataRead^ftpsend.TFTPSend.html#DataRead^^Establish data channel to FTP server and retrieve data. This function you need only in special cases, i.e. when you need to implement some special unsupported FTP command!    ^0"
s[425] = "ftpsend.TFTPSend.DataWrite^ftpsend.TFTPSend.html#DataWrite^^Establish data channel to FTP server and send data. This function you need only in special cases, i.e. when you need to implement some special unsupported FTP command.    ^0"
s[426] = "ftpsend.TFTPSend.ResultCode^ftpsend.TFTPSend.html#ResultCode^^After FTP command contains result number of this operation. ^0"
s[427] = "ftpsend.TFTPSend.ResultString^ftpsend.TFTPSend.html#ResultString^^After FTP command contains main line of result. ^0"
s[428] = "ftpsend.TFTPSend.FullResult^ftpsend.TFTPSend.html#FullResult^^After any FTP command it contains all lines of FTP server reply. ^0"
s[429] = "ftpsend.TFTPSend.Account^ftpsend.TFTPSend.html#Account^^Account information used in some cases inside login sequence. ^0"
s[430] = "ftpsend.TFTPSend.FWHost^ftpsend.TFTPSend.html#FWHost^^Address of firewall. If empty string (default), firewall not used. ^0"
s[431] = "ftpsend.TFTPSend.FWPort^ftpsend.TFTPSend.html#FWPort^^port of firewall. standard value is same port as ftp server used. (21) ^0"
s[432] = "ftpsend.TFTPSend.FWUsername^ftpsend.TFTPSend.html#FWUsername^^Username for login to firewall. (if needed) ^0"
s[433] = "ftpsend.TFTPSend.FWPassword^ftpsend.TFTPSend.html#FWPassword^^password for login to firewall. (if needed) ^0"
s[434] = "ftpsend.TFTPSend.FWMode^ftpsend.TFTPSend.html#FWMode^^Type of Firewall. Used only if you set some firewall address. Supported predefined firewall login sequences are described by comments in source file where you can see pseudocode decribing each sequence. ^0"
s[435] = "ftpsend.TFTPSend.Sock^ftpsend.TFTPSend.html#Sock^^Socket object used for TCP/IP operation on control channel. Good for seting OnStatus hook, etc. ^0"
s[436] = "ftpsend.TFTPSend.DSock^ftpsend.TFTPSend.html#DSock^^Socket object used for TCP/IP operation on data channel. Good for seting OnStatus hook, etc. ^0"
s[437] = "ftpsend.TFTPSend.DataStream^ftpsend.TFTPSend.html#DataStream^^If you not use <a class=\"normal\" href=\"ftpsend.TFTPSend.html#DirectFile\">DirectFile</a> mode, all data transfers is made to or from this stream. ^0"
s[438] = "ftpsend.TFTPSend.DataIP^ftpsend.TFTPSend.html#DataIP^^After data connection is established, contains remote side IP of this connection. ^0"
s[439] = "ftpsend.TFTPSend.DataPort^ftpsend.TFTPSend.html#DataPort^^After data connection is established, contains remote side port of this connection. ^0"
s[440] = "ftpsend.TFTPSend.DirectFile^ftpsend.TFTPSend.html#DirectFile^^Mode of data handling by data connection. If <code>False</code>, all data operations are made to or from <a class=\"normal\" href=\"ftpsend.TFTPSend.html#DataStream\">DataStream</a> TMemoryStream. If <code>True</code>, data operations is made directly to file in your disk. (filename is specified by <a class=\"normal\" href=\"ftpsend.TFTPSend.html#DirectFileName\">DirectFileName</a> property.) Dafault is <code>False</code>! ^0"
s[441] = "ftpsend.TFTPSend.DirectFileName^ftpsend.TFTPSend.html#DirectFileName^^Filename for direct disk data operations. ^0"
s[442] = "ftpsend.TFTPSend.CanResume^ftpsend.TFTPSend.html#CanResume^^Indicate after <a class=\"normal\" href=\"ftpsend.TFTPSend.html#Login\">Login</a> if remote server support resume downloads and uploads. ^0"
s[443] = "ftpsend.TFTPSend.PassiveMode^ftpsend.TFTPSend.html#PassiveMode^^If true (default value), all transfers is made by passive method. It is safer method for various firewalls. ^0"
s[444] = "ftpsend.TFTPSend.ForceDefaultPort^ftpsend.TFTPSend.html#ForceDefaultPort^^Force to listen for dataconnection on standard port (20). Default is <code>False</code>, dataconnections will be made to any non-standard port reported by PORT FTP command. This setting is not used, if you use passive mode. ^0"
s[445] = "ftpsend.TFTPSend.ForceOldPort^ftpsend.TFTPSend.html#ForceOldPort^^When is <code>True</code>, then is disabled EPSV and EPRT support. However without this commands you cannot use IPv6! (Disabling of this commands is needed only when you are behind some crap firewall/NAT. ^0"
s[446] = "ftpsend.TFTPSend.OnStatus^ftpsend.TFTPSend.html#OnStatus^^You may set this hook for monitoring FTP commands and replies. ^0"
s[447] = "ftpsend.TFTPSend.FtpList^ftpsend.TFTPSend.html#FtpList^^After LIST command is here parsed list of files in given directory. ^0"
s[448] = "ftpsend.TFTPSend.BinaryMode^ftpsend.TFTPSend.html#BinaryMode^^if <code>True</code> (default), then data transfers is in binary mode. If this is set to <code>False</code>, then ASCII mode is used. ^0"
s[449] = "ftpsend.TFTPSend.AutoTLS^ftpsend.TFTPSend.html#AutoTLS^^if is true, then if server support upgrade to SSL/TLS mode, then use them. ^0"
s[450] = "ftpsend.TFTPSend.FullSSL^ftpsend.TFTPSend.html#FullSSL^^if server listen on SSL/TLS port, then you set this to true. ^0"
s[451] = "ftpsend.TFTPSend.IsTLS^ftpsend.TFTPSend.html#IsTLS^^Signalise, if control channel is in SSL/TLS mode. ^0"
s[452] = "ftpsend.TFTPSend.IsDataTLS^ftpsend.TFTPSend.html#IsDataTLS^^Signalise, if data transfers is in SSL/TLS mode. ^0"
s[453] = "ftpsend.TFTPSend.TLSonData^ftpsend.TFTPSend.html#TLSonData^^If <code>True</code> (default), then try to use SSL/TLS on data transfers too. If <code>False</code>, then SSL/TLS is used only for control connection. ^0"
s[454] = "ftpsend.cFtpProtocol^ftpsend.html#cFtpProtocol^^ ^0"
s[455] = "ftpsend.cFtpDataProtocol^ftpsend.html#cFtpDataProtocol^^ ^0"
s[456] = "ftpsend.FTP_OK^ftpsend.html#FTP_OK^^Terminating value for TLogonActions ^0"
s[457] = "ftpsend.FTP_ERR^ftpsend.html#FTP_ERR^^Terminating value for TLogonActions ^0"
s[458] = "ftpsend.FtpGetFile^ftpsend.html#FtpGetFile^^A very useful function, and example of use can be found in the TFtpSend object. Dowload specified file from FTP server to LocalFile.    ^0"
s[459] = "ftpsend.FtpPutFile^ftpsend.html#FtpPutFile^^A very useful function, and example of use can be found in the TFtpSend object. Upload specified LocalFile to FTP server.    ^0"
s[460] = "ftpsend.FtpInterServerTransfer^ftpsend.html#FtpInterServerTransfer^^A very useful function, and example of use can be found in the TFtpSend object. Initiate transfer of file between two FTP servers.    ^0"
s[461] = "ftpsend.TLogonActions^ftpsend.html#TLogonActions^^Array for holding definition of logon sequence. ^0"
s[462] = "ftpsend.TFTPStatus^ftpsend.html#TFTPStatus^^Procedural type for OnStatus event. Sender is calling <a class=\"normal\" href=\"ftpsend.TFTPSend.html\">TFTPSend</a> object. Value is FTP command or reply to this comand. (if it is reply, Response is <code>True</code>).    ^0"
s[463] = "ftptsend^ftptsend.html^TFTP client and server protocol^    <p>Used RFC: RFC-1350 ^0"
s[464] = "ftptsend.TTFTPSend^ftptsend.TTFTPSend.html^Implementation of TFTP client and server^ Note: Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[465] = "ftptsend.TTFTPSend.Create^ftptsend.TTFTPSend.html#Create^^    ^0"
s[466] = "ftptsend.TTFTPSend.Destroy^ftptsend.TTFTPSend.html#Destroy^^    ^0"
s[467] = "ftptsend.TTFTPSend.SendFile^ftptsend.TTFTPSend.html#SendFile^^Upload <a class=\"normal\" href=\"ftptsend.TTFTPSend.html#Data\">Data</a> as file to TFTP server.    ^0"
s[468] = "ftptsend.TTFTPSend.RecvFile^ftptsend.TTFTPSend.html#RecvFile^^Download file from TFTP server to <a class=\"normal\" href=\"ftptsend.TTFTPSend.html#Data\">Data</a>.    ^0"
s[469] = "ftptsend.TTFTPSend.WaitForRequest^ftptsend.TTFTPSend.html#WaitForRequest^^Acts as TFTP server and wait for client request. When some request incoming within Timeout, result is <code>True</code> and parametres is filled with information from request. You must handle this request, validate it, and call <a class=\"normal\" href=\"ftptsend.TTFTPSend.html#ReplyError\">ReplyError</a>, <a class=\"normal\" href=\"ftptsend.TTFTPSend.html#ReplyRecv\">ReplyRecv</a> or <a class=\"normal\" href=\"ftptsend.TTFTPSend.html#ReplySend\">ReplySend</a> for send reply to TFTP Client.    ^0"
s[470] = "ftptsend.TTFTPSend.ReplyError^ftptsend.TTFTPSend.html#ReplyError^^send error to TFTP client, when you acts as TFTP server.    ^0"
s[471] = "ftptsend.TTFTPSend.ReplyRecv^ftptsend.TTFTPSend.html#ReplyRecv^^Accept uploaded file from TFTP client to <a class=\"normal\" href=\"ftptsend.TTFTPSend.html#Data\">Data</a>, when you acts as TFTP server.    ^0"
s[472] = "ftptsend.TTFTPSend.ReplySend^ftptsend.TTFTPSend.html#ReplySend^^Accept download request file from TFTP client and send content of <a class=\"normal\" href=\"ftptsend.TTFTPSend.html#Data\">Data</a>, when you acts as TFTP server.    ^0"
s[473] = "ftptsend.TTFTPSend.ErrorCode^ftptsend.TTFTPSend.html#ErrorCode^^Code of TFTP error. ^0"
s[474] = "ftptsend.TTFTPSend.ErrorString^ftptsend.TTFTPSend.html#ErrorString^^Human readable decription of TFTP error. (if is sended by remote side) ^0"
s[475] = "ftptsend.TTFTPSend.Data^ftptsend.TTFTPSend.html#Data^^MemoryStream with datas for sending or receiving ^0"
s[476] = "ftptsend.TTFTPSend.RequestIP^ftptsend.TTFTPSend.html#RequestIP^^Address of TFTP remote side. ^0"
s[477] = "ftptsend.TTFTPSend.RequestPort^ftptsend.TTFTPSend.html#RequestPort^^Port of TFTP remote side. ^0"
s[478] = "ftptsend.cTFTPProtocol^ftptsend.html#cTFTPProtocol^^ ^0"
s[479] = "ftptsend.cTFTP_RRQ^ftptsend.html#cTFTP_RRQ^^ ^0"
s[480] = "ftptsend.cTFTP_WRQ^ftptsend.html#cTFTP_WRQ^^ ^0"
s[481] = "ftptsend.cTFTP_DTA^ftptsend.html#cTFTP_DTA^^ ^0"
s[482] = "ftptsend.cTFTP_ACK^ftptsend.html#cTFTP_ACK^^ ^0"
s[483] = "ftptsend.cTFTP_ERR^ftptsend.html#cTFTP_ERR^^ ^0"
s[484] = "httpsend^httpsend.html^^ ^0"
s[485] = "httpsend.THTTPSend^httpsend.THTTPSend.html^^abstract(Implementation of HTTP protocol.) ^0"
s[486] = "httpsend.THTTPSend.Create^httpsend.THTTPSend.html#Create^^    ^0"
s[487] = "httpsend.THTTPSend.Destroy^httpsend.THTTPSend.html#Destroy^^    ^0"
s[488] = "httpsend.THTTPSend.Clear^httpsend.THTTPSend.html#Clear^^Reset headers and document and Mimetype.    ^0"
s[489] = "httpsend.THTTPSend.DecodeStatus^httpsend.THTTPSend.html#DecodeStatus^^Decode ResultCode and ResultString from Value.    ^0"
s[490] = "httpsend.THTTPSend.HTTPMethod^httpsend.THTTPSend.html#HTTPMethod^^Connects to host define in URL and access to resource defined in URL by method. If Document is not empty, send it to server as part of HTTP request. Server response is in Document and headers. Connection may be authorised by username and password in URL. If you define proxy properties, connection is made by this proxy. If all OK, result is <code>True</code>, else result is <code>False</code>.    <p>If you use in URL 'https:' instead only 'http:', then your request is made by SSL/TLS connection (if you not specify port, then port 443 is used instead standard port 80). If you use SSL/TLS request and you have defined HTTP proxy, then HTTP-tunnel mode is automaticly used .    ^0"
s[491] = "httpsend.THTTPSend.Abort^httpsend.THTTPSend.html#Abort^^You can call this method from OnStatus event for break current data transfer. (or from another thread.)    ^0"
s[492] = "httpsend.THTTPSend.Headers^httpsend.THTTPSend.html#Headers^^Before HTTP operation you may define any non-standard headers for HTTP request, except of: 'Expect: 100-continue', 'Content-Length', 'Content-Type', 'Connection', 'Authorization', 'Proxy-Authorization' and 'Host' headers. After HTTP operation contains full headers of returned document. ^0"
s[493] = "httpsend.THTTPSend.Cookies^httpsend.THTTPSend.html#Cookies^^This is stringlist with name-value stringlist pairs. Each this pair is one cookie. After HTTP request is returned cookies parsed to this stringlist. You can leave this cookies untouched for next HTTP request. You can also save this stringlist for later use. ^0"
s[494] = "httpsend.THTTPSend.Document^httpsend.THTTPSend.html#Document^^Stream with document to send (before request, or with document received from HTTP server (after request). ^0"
s[495] = "httpsend.THTTPSend.RangeStart^httpsend.THTTPSend.html#RangeStart^^If you need download only part of requested document, here specify possition of subpart begin. If here 0, then is requested full document. ^0"
s[496] = "httpsend.THTTPSend.RangeEnd^httpsend.THTTPSend.html#RangeEnd^^If you need download only part of requested document, here specify possition of subpart end. If here 0, then is requested document from rangeStart to end of document. (for broken download restoration, for example.) ^0"
s[497] = "httpsend.THTTPSend.MimeType^httpsend.THTTPSend.html#MimeType^^Mime type of sending data. Default is: 'text/html'. ^0"
s[498] = "httpsend.THTTPSend.Protocol^httpsend.THTTPSend.html#Protocol^^Define protocol version. Possible values are: '1.1', '1.0' (default) and '0.9'. ^0"
s[499] = "httpsend.THTTPSend.KeepAlive^httpsend.THTTPSend.html#KeepAlive^^If <code>True</code> (default value), keepalives in HTTP protocol 1.1 is enabled. ^0"
s[500] = "httpsend.THTTPSend.KeepAliveTimeout^httpsend.THTTPSend.html#KeepAliveTimeout^^Define timeout for keepalives in seconds! ^0"
s[501] = "httpsend.THTTPSend.Status100^httpsend.THTTPSend.html#Status100^^if <code>True</code>, then server is requested for 100status capability when uploading data. Default is <code>False</code> (off). ^0"
s[502] = "httpsend.THTTPSend.ProxyHost^httpsend.THTTPSend.html#ProxyHost^^Address of proxy server (IP address or domain name) where you want to connect in <a class=\"normal\" href=\"httpsend.THTTPSend.html#HTTPMethod\">HTTPMethod</a> method. ^0"
s[503] = "httpsend.THTTPSend.ProxyPort^httpsend.THTTPSend.html#ProxyPort^^Port number for proxy connection. Default value is 8080. ^0"
s[504] = "httpsend.THTTPSend.ProxyUser^httpsend.THTTPSend.html#ProxyUser^^Username for connect to proxy server where you want to connect in HTTPMethod method. ^0"
s[505] = "httpsend.THTTPSend.ProxyPass^httpsend.THTTPSend.html#ProxyPass^^Password for connect to proxy server where you want to connect in HTTPMethod method. ^0"
s[506] = "httpsend.THTTPSend.UserAgent^httpsend.THTTPSend.html#UserAgent^^Here you can specify custom User-Agent indentification. By default is used: 'Mozilla/4.0 (compatible; Synapse)' ^0"
s[507] = "httpsend.THTTPSend.ResultCode^httpsend.THTTPSend.html#ResultCode^^After successful <a class=\"normal\" href=\"httpsend.THTTPSend.html#HTTPMethod\">HTTPMethod</a> method contains result code of operation. ^0"
s[508] = "httpsend.THTTPSend.ResultString^httpsend.THTTPSend.html#ResultString^^After successful <a class=\"normal\" href=\"httpsend.THTTPSend.html#HTTPMethod\">HTTPMethod</a> method contains string after result code. ^0"
s[509] = "httpsend.THTTPSend.DownloadSize^httpsend.THTTPSend.html#DownloadSize^^if this value is not 0, then data download pending. In this case you have here total sice of downloaded data. It is good for draw download progressbar from OnStatus event. ^0"
s[510] = "httpsend.THTTPSend.UploadSize^httpsend.THTTPSend.html#UploadSize^^if this value is not 0, then data upload pending. In this case you have here total sice of uploaded data. It is good for draw upload progressbar from OnStatus event. ^0"
s[511] = "httpsend.THTTPSend.Sock^httpsend.THTTPSend.html#Sock^^Socket object used for TCP/IP operation. Good for seting OnStatus hook, etc. ^0"
s[512] = "httpsend.THTTPSend.AddPortNumberToHost^httpsend.THTTPSend.html#AddPortNumberToHost^^To have possibility to switch off port number in 'Host:' HTTP header, by default <code>True</code>. Some buggy servers not like port informations in this header. ^0"
s[513] = "httpsend.cHttpProtocol^httpsend.html#cHttpProtocol^^ ^0"
s[514] = "httpsend.HttpGetText^httpsend.html#HttpGetText^^A very usefull function, and example of use can be found in the THTTPSend object. It implements the GET method of the HTTP protocol. This function sends the GET method for URL document to an HTTP server. Returned document is in the &quot;Response&quot; stringlist (without any headers). Returns boolean TRUE if all went well.    ^0"
s[515] = "httpsend.HttpGetBinary^httpsend.html#HttpGetBinary^^A very usefull function, and example of use can be found in the THTTPSend object. It implements the GET method of the HTTP protocol. This function sends the GET method for URL document to an HTTP server. Returned document is in the &quot;Response&quot; stream. Returns boolean TRUE if all went well.    ^0"
s[516] = "httpsend.HttpPostBinary^httpsend.html#HttpPostBinary^^A very useful function, and example of use can be found in the THTTPSend object. It implements the POST method of the HTTP protocol. This function sends the SEND method for a URL document to an HTTP server. The document to be sent is located in &quot;Data&quot; stream. The returned document is in the &quot;Data&quot; stream. Returns boolean TRUE if all went well.    ^0"
s[517] = "httpsend.HttpPostURL^httpsend.html#HttpPostURL^^A very useful function, and example of use can be found in the THTTPSend object. It implements the POST method of the HTTP protocol. This function is good for POSTing form data. It sends the POST method for a URL document to an HTTP server. You must prepare the form data in the same manner as you would the URL data, and pass this prepared data to &quot;URLdata&quot;. The following is a sample of how the data would appear: 'name=Lukas&amp;field1=some%20data'. The information in the field must be encoded by EncodeURLElement function. The returned document is in the &quot;Data&quot; stream. Returns boolean TRUE if all went well.    ^0"
s[518] = "httpsend.HttpPostFile^httpsend.html#HttpPostFile^^A very useful function, and example of use can be found in the THTTPSend object. It implements the POST method of the HTTP protocol. This function sends the POST method for a URL document to an HTTP server. This function simulate posting of file by HTML form used method 'multipart/form-data'. Posting file is in DATA stream. Its name is Filename string. Fieldname is for name of formular field with file. (simulate HTML INPUT FILE) The returned document is in the ResultData Stringlist. Returns boolean TRUE if all went well.    ^0"
s[519] = "httpsend.TTransferEncoding^httpsend.html#TTransferEncoding^^These encoding types are used internally by the THTTPSend object to identify the transfer data types.  TE_UNKNOWN    TE_IDENTITY    TE_CHUNKED   ^0"
s[520] = "imapsend^imapsend.html^IMAP4 rev1 protocol client^    <p>Used RFC: RFC-2060, RFC-2595 ^0"
s[521] = "imapsend.TIMAPSend^imapsend.TIMAPSend.html^Implementation of IMAP4 protocol.^ Note: Are you missing properties for setting Username and Password? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> object!    <p>Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[522] = "imapsend.TIMAPSend.Create^imapsend.TIMAPSend.html#Create^^    ^0"
s[523] = "imapsend.TIMAPSend.Destroy^imapsend.TIMAPSend.html#Destroy^^    ^0"
s[524] = "imapsend.TIMAPSend.IMAPcommand^imapsend.TIMAPSend.html#IMAPcommand^^By this function you can call any IMAP command. Result of this command is in adequate properties.    ^0"
s[525] = "imapsend.TIMAPSend.IMAPuploadCommand^imapsend.TIMAPSend.html#IMAPuploadCommand^^By this function you can call any IMAP command what need upload any data. Result of this command is in adequate properties.    ^0"
s[526] = "imapsend.TIMAPSend.Capability^imapsend.TIMAPSend.html#Capability^^Call CAPABILITY command and fill IMAPcap property by new values.    ^0"
s[527] = "imapsend.TIMAPSend.Login^imapsend.TIMAPSend.html#Login^^Connect to IMAP server and do login to this server. This command begin session.    ^0"
s[528] = "imapsend.TIMAPSend.Logout^imapsend.TIMAPSend.html#Logout^^Disconnect from IMAP server and terminate session session. If exists some deleted and non-purged messages, these messages are not deleted!    ^0"
s[529] = "imapsend.TIMAPSend.NoOp^imapsend.TIMAPSend.html#NoOp^^Do NOOP. It is for prevent disconnect by timeout.    ^0"
s[530] = "imapsend.TIMAPSend.List^imapsend.TIMAPSend.html#List^^Lists folder names. You may specify level of listing. If you specify FromFolder as empty string, return is all folders in system.    ^0"
s[531] = "imapsend.TIMAPSend.ListSearch^imapsend.TIMAPSend.html#ListSearch^^Lists folder names what match search criteria. You may specify level of listing. If you specify FromFolder as empty string, return is all folders in system.    ^0"
s[532] = "imapsend.TIMAPSend.ListSubscribed^imapsend.TIMAPSend.html#ListSubscribed^^Lists subscribed folder names. You may specify level of listing. If you specify FromFolder as empty string, return is all subscribed folders in system.    ^0"
s[533] = "imapsend.TIMAPSend.ListSearchSubscribed^imapsend.TIMAPSend.html#ListSearchSubscribed^^Lists subscribed folder names what matching search criteria. You may specify level of listing. If you specify FromFolder as empty string, return is all subscribed folders in system.    ^0"
s[534] = "imapsend.TIMAPSend.CreateFolder^imapsend.TIMAPSend.html#CreateFolder^^Create a new folder.    ^0"
s[535] = "imapsend.TIMAPSend.DeleteFolder^imapsend.TIMAPSend.html#DeleteFolder^^Delete a folder.    ^0"
s[536] = "imapsend.TIMAPSend.RenameFolder^imapsend.TIMAPSend.html#RenameFolder^^Rename folder names.    ^0"
s[537] = "imapsend.TIMAPSend.SubscribeFolder^imapsend.TIMAPSend.html#SubscribeFolder^^Subscribe folder.    ^0"
s[538] = "imapsend.TIMAPSend.UnsubscribeFolder^imapsend.TIMAPSend.html#UnsubscribeFolder^^Unsubscribe folder.    ^0"
s[539] = "imapsend.TIMAPSend.SelectFolder^imapsend.TIMAPSend.html#SelectFolder^^Select folder.    ^0"
s[540] = "imapsend.TIMAPSend.SelectROFolder^imapsend.TIMAPSend.html#SelectROFolder^^Select folder, but only for reading. Any changes are not allowed!    ^0"
s[541] = "imapsend.TIMAPSend.CloseFolder^imapsend.TIMAPSend.html#CloseFolder^^Close a folder. (end of Selected state)    ^0"
s[542] = "imapsend.TIMAPSend.StatusFolder^imapsend.TIMAPSend.html#StatusFolder^^Ask for given status of folder. I.e. if you specify as value 'UNSEEN', result is number of unseen messages in folder. For another status indentificator check IMAP documentation and documentation of your IMAP server (each IMAP server can have their own statuses.)    ^0"
s[543] = "imapsend.TIMAPSend.ExpungeFolder^imapsend.TIMAPSend.html#ExpungeFolder^^Hardly delete all messages marked as 'deleted' in current selected folder.    ^0"
s[544] = "imapsend.TIMAPSend.CheckFolder^imapsend.TIMAPSend.html#CheckFolder^^Touch to folder. (use as update status of folder, etc.)    ^0"
s[545] = "imapsend.TIMAPSend.AppendMess^imapsend.TIMAPSend.html#AppendMess^^Append given message to specified folder.    ^0"
s[546] = "imapsend.TIMAPSend.DeleteMess^imapsend.TIMAPSend.html#DeleteMess^^'Delete' message from current selected folder. It mark message as Deleted. Real deleting will be done after sucessfull <a class=\"normal\" href=\"imapsend.TIMAPSend.html#CloseFolder\">CloseFolder</a> or <a class=\"normal\" href=\"imapsend.TIMAPSend.html#ExpungeFolder\">ExpungeFolder</a>    ^0"
s[547] = "imapsend.TIMAPSend.FetchMess^imapsend.TIMAPSend.html#FetchMess^^Get full message from specified message in selected folder.    ^0"
s[548] = "imapsend.TIMAPSend.FetchHeader^imapsend.TIMAPSend.html#FetchHeader^^Get message headers only from specified message in selected folder.    ^0"
s[549] = "imapsend.TIMAPSend.MessageSize^imapsend.TIMAPSend.html#MessageSize^^Return message size of specified message from current selected folder.    ^0"
s[550] = "imapsend.TIMAPSend.CopyMess^imapsend.TIMAPSend.html#CopyMess^^Copy message from current selected folder to another folder.    ^0"
s[551] = "imapsend.TIMAPSend.SearchMess^imapsend.TIMAPSend.html#SearchMess^^Return message numbers from currently selected folder as result of searching. Search criteria is very complex language (see to IMAP specification) similar to SQL (but not same syntax!).    ^0"
s[552] = "imapsend.TIMAPSend.SetFlagsMess^imapsend.TIMAPSend.html#SetFlagsMess^^Sets flags of message from current selected folder.    ^0"
s[553] = "imapsend.TIMAPSend.GetFlagsMess^imapsend.TIMAPSend.html#GetFlagsMess^^Gets flags of message from current selected folder.    ^0"
s[554] = "imapsend.TIMAPSend.AddFlagsMess^imapsend.TIMAPSend.html#AddFlagsMess^^Add flags to message's flags.    ^0"
s[555] = "imapsend.TIMAPSend.DelFlagsMess^imapsend.TIMAPSend.html#DelFlagsMess^^Remove flags from message's flags.    ^0"
s[556] = "imapsend.TIMAPSend.StartTLS^imapsend.TIMAPSend.html#StartTLS^^Call STARTTLS command for upgrade connection to SSL/TLS mode.    ^0"
s[557] = "imapsend.TIMAPSend.GetUID^imapsend.TIMAPSend.html#GetUID^^return UID of requested message ID.    ^0"
s[558] = "imapsend.TIMAPSend.FindCap^imapsend.TIMAPSend.html#FindCap^^Try to find given capabily in capabilty string returned from IMAP server.    ^0"
s[559] = "imapsend.TIMAPSend.ResultString^imapsend.TIMAPSend.html#ResultString^^Status line with result of last operation. ^0"
s[560] = "imapsend.TIMAPSend.FullResult^imapsend.TIMAPSend.html#FullResult^^Full result of last IMAP operation. ^0"
s[561] = "imapsend.TIMAPSend.IMAPcap^imapsend.TIMAPSend.html#IMAPcap^^List of server capabilites. ^0"
s[562] = "imapsend.TIMAPSend.AuthDone^imapsend.TIMAPSend.html#AuthDone^^Authorization is successful done. ^0"
s[563] = "imapsend.TIMAPSend.UID^imapsend.TIMAPSend.html#UID^^Turn on or off usage of UID (unicate identificator) of messages instead only sequence numbers. ^0"
s[564] = "imapsend.TIMAPSend.SelectedFolder^imapsend.TIMAPSend.html#SelectedFolder^^Name of currently selected folder. ^0"
s[565] = "imapsend.TIMAPSend.SelectedCount^imapsend.TIMAPSend.html#SelectedCount^^Count of messages in currently selected folder. ^0"
s[566] = "imapsend.TIMAPSend.SelectedRecent^imapsend.TIMAPSend.html#SelectedRecent^^Count of not-visited messages in currently selected folder. ^0"
s[567] = "imapsend.TIMAPSend.SelectedUIDvalidity^imapsend.TIMAPSend.html#SelectedUIDvalidity^^This number with name of folder is unique indentificator of folder. (If someone delete folder and next create new folder with exactly same name of folder, this number is must be different!) ^0"
s[568] = "imapsend.TIMAPSend.AutoTLS^imapsend.TIMAPSend.html#AutoTLS^^If is set to true, then upgrade to SSL/TLS mode if remote server support it. ^0"
s[569] = "imapsend.TIMAPSend.FullSSL^imapsend.TIMAPSend.html#FullSSL^^SSL/TLS mode is used from first contact to server. Servers with full SSL/TLS mode usualy using non-standard TCP port! ^0"
s[570] = "imapsend.TIMAPSend.Sock^imapsend.TIMAPSend.html#Sock^^Socket object used for TCP/IP operation. Good for seting OnStatus hook, etc. ^0"
s[571] = "imapsend.cIMAPProtocol^imapsend.html#cIMAPProtocol^^ ^0"
s[572] = "laz_synapse^laz_synapse.html^^ ^0"
s[573] = "ldapsend^ldapsend.html^LDAP client^    <p>Used RFC: RFC-2251, RFC-2254, RFC-2829, RFC-2830 ^0"
s[574] = "ldapsend.TLDAPAttribute^ldapsend.TLDAPAttribute.html^LDAP attribute with list of their values^ This class holding name of LDAP attribute and list of their values. This is descendant of TStringList class enhanced by some new properties. ^0"
s[575] = "ldapsend.TLDAPAttribute.AttributeName^ldapsend.TLDAPAttribute.html#AttributeName^^Name of LDAP attribute. ^0"
s[576] = "ldapsend.TLDAPAttribute.IsBinary^ldapsend.TLDAPAttribute.html#IsBinary^^Return <code>True</code> when attribute contains binary data. ^0"
s[577] = "ldapsend.TLDAPAttributeList^ldapsend.TLDAPAttributeList.html^List of <a class=\"normal\" href=\"ldapsend.TLDAPAttribute.html\">TLDAPAttribute</a>^ This object can hold list of TLDAPAttribute objects. ^0"
s[578] = "ldapsend.TLDAPAttributeList.Create^ldapsend.TLDAPAttributeList.html#Create^^    ^0"
s[579] = "ldapsend.TLDAPAttributeList.Destroy^ldapsend.TLDAPAttributeList.html#Destroy^^    ^0"
s[580] = "ldapsend.TLDAPAttributeList.Clear^ldapsend.TLDAPAttributeList.html#Clear^^Clear list.    ^0"
s[581] = "ldapsend.TLDAPAttributeList.Count^ldapsend.TLDAPAttributeList.html#Count^^Return count of TLDAPAttribute objects in list.    ^0"
s[582] = "ldapsend.TLDAPAttributeList.Add^ldapsend.TLDAPAttributeList.html#Add^^Add new TLDAPAttribute object to list.    ^0"
s[583] = "ldapsend.TLDAPAttributeList.Del^ldapsend.TLDAPAttributeList.html#Del^^Delete one TLDAPAttribute object from list.    ^0"
s[584] = "ldapsend.TLDAPAttributeList.Find^ldapsend.TLDAPAttributeList.html#Find^^Find and return attribute with requested name. Returns nil if not found.    ^0"
s[585] = "ldapsend.TLDAPAttributeList.Get^ldapsend.TLDAPAttributeList.html#Get^^Find and return attribute value with requested name. Returns empty string if not found.    ^0"
s[586] = "ldapsend.TLDAPAttributeList.Items^ldapsend.TLDAPAttributeList.html#Items^^List of TLDAPAttribute objects. ^0"
s[587] = "ldapsend.TLDAPResult^ldapsend.TLDAPResult.html^LDAP result object^ This object can hold LDAP object. (their name and all their attributes with values) ^0"
s[588] = "ldapsend.TLDAPResult.Create^ldapsend.TLDAPResult.html#Create^^    ^0"
s[589] = "ldapsend.TLDAPResult.Destroy^ldapsend.TLDAPResult.html#Destroy^^    ^0"
s[590] = "ldapsend.TLDAPResult.ObjectName^ldapsend.TLDAPResult.html#ObjectName^^Name of this LDAP object. ^0"
s[591] = "ldapsend.TLDAPResult.Attributes^ldapsend.TLDAPResult.html#Attributes^^Here is list of object attributes. ^0"
s[592] = "ldapsend.TLDAPResultList^ldapsend.TLDAPResultList.html^List of LDAP result objects^ This object can hold list of LDAP objects. (for example result of LDAP SEARCH.) ^0"
s[593] = "ldapsend.TLDAPResultList.Create^ldapsend.TLDAPResultList.html#Create^^    ^0"
s[594] = "ldapsend.TLDAPResultList.Destroy^ldapsend.TLDAPResultList.html#Destroy^^    ^0"
s[595] = "ldapsend.TLDAPResultList.Clear^ldapsend.TLDAPResultList.html#Clear^^Clear all TLDAPResult objects in list.    ^0"
s[596] = "ldapsend.TLDAPResultList.Count^ldapsend.TLDAPResultList.html#Count^^Return count of TLDAPResult objects in list.    ^0"
s[597] = "ldapsend.TLDAPResultList.Add^ldapsend.TLDAPResultList.html#Add^^Create and add new TLDAPResult object to list.    ^0"
s[598] = "ldapsend.TLDAPResultList.Items^ldapsend.TLDAPResultList.html#Items^^List of TLDAPResult objects. ^0"
s[599] = "ldapsend.TLDAPSend^ldapsend.TLDAPSend.html^Implementation of LDAP client^ (version 2 and 3)    <p>Note: Are you missing properties for setting Username and Password? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> object!    <p>Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[600] = "ldapsend.TLDAPSend.Create^ldapsend.TLDAPSend.html#Create^^    ^0"
s[601] = "ldapsend.TLDAPSend.Destroy^ldapsend.TLDAPSend.html#Destroy^^    ^0"
s[602] = "ldapsend.TLDAPSend.Login^ldapsend.TLDAPSend.html#Login^^Try to connect to LDAP server and start secure channel, when it is required.    ^0"
s[603] = "ldapsend.TLDAPSend.Bind^ldapsend.TLDAPSend.html#Bind^^Try to bind to LDAP server with <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a>.<a class=\"normal\" href=\"blcksock.TSynaClient.html#UserName\">UserName</a> and <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a>.<a class=\"normal\" href=\"blcksock.TSynaClient.html#Password\">Password</a>. If this is empty strings, then it do annonymous Bind. When you not call Bind on LDAPv3, then is automaticly used anonymous mode.    <p>This method using plaintext transport of password! It is not secure!    ^0"
s[604] = "ldapsend.TLDAPSend.BindSasl^ldapsend.TLDAPSend.html#BindSasl^^Try to bind to LDAP server with <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a>.<a class=\"normal\" href=\"blcksock.TSynaClient.html#UserName\">UserName</a> and <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a>.<a class=\"normal\" href=\"blcksock.TSynaClient.html#Password\">Password</a>. If this is empty strings, then it do annonymous Bind. When you not call Bind on LDAPv3, then is automaticly used anonymous mode.    <p>This method using SASL with DIGEST-MD5 method for secure transfer of your password.    ^0"
s[605] = "ldapsend.TLDAPSend.Logout^ldapsend.TLDAPSend.html#Logout^^Close connection to LDAP server.    ^0"
s[606] = "ldapsend.TLDAPSend.Modify^ldapsend.TLDAPSend.html#Modify^^Modify content of LDAP attribute on this object.    ^0"
s[607] = "ldapsend.TLDAPSend.Add^ldapsend.TLDAPSend.html#Add^^Add list of attributes to specified object.    ^0"
s[608] = "ldapsend.TLDAPSend.Delete^ldapsend.TLDAPSend.html#Delete^^Delete this LDAP object from server.    ^0"
s[609] = "ldapsend.TLDAPSend.ModifyDN^ldapsend.TLDAPSend.html#ModifyDN^^Modify object name of this LDAP object.    ^0"
s[610] = "ldapsend.TLDAPSend.Compare^ldapsend.TLDAPSend.html#Compare^^Try to compare Attribute value with this LDAP object.    ^0"
s[611] = "ldapsend.TLDAPSend.Search^ldapsend.TLDAPSend.html#Search^^Search LDAP base for LDAP objects by Filter.    ^0"
s[612] = "ldapsend.TLDAPSend.Extended^ldapsend.TLDAPSend.html#Extended^^Call any LDAPv3 extended command.    ^0"
s[613] = "ldapsend.TLDAPSend.StartTLS^ldapsend.TLDAPSend.html#StartTLS^^Try to start SSL/TLS connection to LDAP server.    ^0"
s[614] = "ldapsend.TLDAPSend.Version^ldapsend.TLDAPSend.html#Version^^Specify version of used LDAP protocol. Default value is 3. ^0"
s[615] = "ldapsend.TLDAPSend.ResultCode^ldapsend.TLDAPSend.html#ResultCode^^Result code of last LDAP operation. ^0"
s[616] = "ldapsend.TLDAPSend.ResultString^ldapsend.TLDAPSend.html#ResultString^^Human readable description of result code of last LDAP operation. ^0"
s[617] = "ldapsend.TLDAPSend.FullResult^ldapsend.TLDAPSend.html#FullResult^^Binary string with full last response of LDAP server. This string is encoded by ASN.1 BER encoding! You need this only for debugging. ^0"
s[618] = "ldapsend.TLDAPSend.AutoTLS^ldapsend.TLDAPSend.html#AutoTLS^^If <code>True</code>, then try to start TSL mode in Login procedure. ^0"
s[619] = "ldapsend.TLDAPSend.FullSSL^ldapsend.TLDAPSend.html#FullSSL^^If <code>True</code>, then use connection to LDAP server through SSL/TLS tunnel. ^0"
s[620] = "ldapsend.TLDAPSend.Seq^ldapsend.TLDAPSend.html#Seq^^Sequence number of last LDAp command. It is incremented by any LDAP command. ^0"
s[621] = "ldapsend.TLDAPSend.SearchScope^ldapsend.TLDAPSend.html#SearchScope^^Specify what search scope is used in search command. ^0"
s[622] = "ldapsend.TLDAPSend.SearchAliases^ldapsend.TLDAPSend.html#SearchAliases^^Specify how to handle aliases in search command. ^0"
s[623] = "ldapsend.TLDAPSend.SearchSizeLimit^ldapsend.TLDAPSend.html#SearchSizeLimit^^Specify result size limit in search command. Value 0 means without limit. ^0"
s[624] = "ldapsend.TLDAPSend.SearchTimeLimit^ldapsend.TLDAPSend.html#SearchTimeLimit^^Specify search time limit in search command (seconds). Value 0 means without limit. ^0"
s[625] = "ldapsend.TLDAPSend.SearchResult^ldapsend.TLDAPSend.html#SearchResult^^Here is result of search command. ^0"
s[626] = "ldapsend.TLDAPSend.Referals^ldapsend.TLDAPSend.html#Referals^^On each LDAP operation can LDAP server return some referals URLs. Here is their list. ^0"
s[627] = "ldapsend.TLDAPSend.ExtName^ldapsend.TLDAPSend.html#ExtName^^When you call <a class=\"normal\" href=\"ldapsend.TLDAPSend.html#Extended\">Extended</a> operation, then here is result Name returned by server. ^0"
s[628] = "ldapsend.TLDAPSend.ExtValue^ldapsend.TLDAPSend.html#ExtValue^^When you call <a class=\"normal\" href=\"ldapsend.TLDAPSend.html#Extended\">Extended</a> operation, then here is result Value returned by server. ^0"
s[629] = "ldapsend.TLDAPSend.Sock^ldapsend.TLDAPSend.html#Sock^^TCP socket used by all LDAP operations. ^0"
s[630] = "ldapsend.cLDAPProtocol^ldapsend.html#cLDAPProtocol^^ ^0"
s[631] = "ldapsend.LDAP_ASN1_BIND_REQUEST^ldapsend.html#LDAP_ASN1_BIND_REQUEST^^ ^0"
s[632] = "ldapsend.LDAP_ASN1_BIND_RESPONSE^ldapsend.html#LDAP_ASN1_BIND_RESPONSE^^ ^0"
s[633] = "ldapsend.LDAP_ASN1_UNBIND_REQUEST^ldapsend.html#LDAP_ASN1_UNBIND_REQUEST^^ ^0"
s[634] = "ldapsend.LDAP_ASN1_SEARCH_REQUEST^ldapsend.html#LDAP_ASN1_SEARCH_REQUEST^^ ^0"
s[635] = "ldapsend.LDAP_ASN1_SEARCH_ENTRY^ldapsend.html#LDAP_ASN1_SEARCH_ENTRY^^ ^0"
s[636] = "ldapsend.LDAP_ASN1_SEARCH_DONE^ldapsend.html#LDAP_ASN1_SEARCH_DONE^^ ^0"
s[637] = "ldapsend.LDAP_ASN1_SEARCH_REFERENCE^ldapsend.html#LDAP_ASN1_SEARCH_REFERENCE^^ ^0"
s[638] = "ldapsend.LDAP_ASN1_MODIFY_REQUEST^ldapsend.html#LDAP_ASN1_MODIFY_REQUEST^^ ^0"
s[639] = "ldapsend.LDAP_ASN1_MODIFY_RESPONSE^ldapsend.html#LDAP_ASN1_MODIFY_RESPONSE^^ ^0"
s[640] = "ldapsend.LDAP_ASN1_ADD_REQUEST^ldapsend.html#LDAP_ASN1_ADD_REQUEST^^ ^0"
s[641] = "ldapsend.LDAP_ASN1_ADD_RESPONSE^ldapsend.html#LDAP_ASN1_ADD_RESPONSE^^ ^0"
s[642] = "ldapsend.LDAP_ASN1_DEL_REQUEST^ldapsend.html#LDAP_ASN1_DEL_REQUEST^^ ^0"
s[643] = "ldapsend.LDAP_ASN1_DEL_RESPONSE^ldapsend.html#LDAP_ASN1_DEL_RESPONSE^^ ^0"
s[644] = "ldapsend.LDAP_ASN1_MODIFYDN_REQUEST^ldapsend.html#LDAP_ASN1_MODIFYDN_REQUEST^^ ^0"
s[645] = "ldapsend.LDAP_ASN1_MODIFYDN_RESPONSE^ldapsend.html#LDAP_ASN1_MODIFYDN_RESPONSE^^ ^0"
s[646] = "ldapsend.LDAP_ASN1_COMPARE_REQUEST^ldapsend.html#LDAP_ASN1_COMPARE_REQUEST^^ ^0"
s[647] = "ldapsend.LDAP_ASN1_COMPARE_RESPONSE^ldapsend.html#LDAP_ASN1_COMPARE_RESPONSE^^ ^0"
s[648] = "ldapsend.LDAP_ASN1_ABANDON_REQUEST^ldapsend.html#LDAP_ASN1_ABANDON_REQUEST^^ ^0"
s[649] = "ldapsend.LDAP_ASN1_EXT_REQUEST^ldapsend.html#LDAP_ASN1_EXT_REQUEST^^ ^0"
s[650] = "ldapsend.LDAP_ASN1_EXT_RESPONSE^ldapsend.html#LDAP_ASN1_EXT_RESPONSE^^ ^0"
s[651] = "ldapsend.LDAPResultDump^ldapsend.html#LDAPResultDump^^Dump result of LDAP SEARCH into human readable form. Good for debugging.    ^0"
s[652] = "ldapsend.TLDAPModifyOp^ldapsend.html#TLDAPModifyOp^^Define possible operations for LDAP MODIFY operations.  MO_Add    MO_Delete    MO_Replace   ^0"
s[653] = "ldapsend.TLDAPSearchScope^ldapsend.html#TLDAPSearchScope^^Specify possible values for search scope.  SS_BaseObject    SS_SingleLevel    SS_WholeSubtree   ^0"
s[654] = "ldapsend.TLDAPSearchAliases^ldapsend.html#TLDAPSearchAliases^^Specify possible values about alias dereferencing.  SA_NeverDeref    SA_InSearching    SA_FindingBaseObj    SA_Always   ^0"
s[655] = "mimeinln^mimeinln.html^Utilities for inline MIME^ Support for Inline MIME encoding and decoding.    <p>Used RFC: RFC-2047, RFC-2231 ^0"
s[656] = "mimeinln.InlineDecode^mimeinln.html#InlineDecode^^Decodes mime inline encoding (i.e. in headers) uses target characterset &quot;CP&quot;.    ^0"
s[657] = "mimeinln.InlineEncode^mimeinln.html#InlineEncode^^Encodes string to MIME inline encoding. The source characterset is &quot;CP&quot;, and the target charset is &quot;MimeP&quot;.    ^0"
s[658] = "mimeinln.NeedInline^mimeinln.html#NeedInline^^Returns <code>True</code>, if &quot;Value&quot; contains characters needed for inline coding.    ^0"
s[659] = "mimeinln.InlineCodeEx^mimeinln.html#InlineCodeEx^^Inline mime encoding similar to <a class=\"normal\" href=\"mimeinln.html#InlineEncode\">InlineEncode</a>, but you can specify source charset, and the target characterset is automatically assigned.    ^0"
s[660] = "mimeinln.InlineCode^mimeinln.html#InlineCode^^Inline MIME encoding similar to <a class=\"normal\" href=\"mimeinln.html#InlineEncode\">InlineEncode</a>, but the source charset is automatically set to the system default charset, and the target charset is automatically assigned from set of allowed encoding for MIME.    ^0"
s[661] = "mimeinln.InlineEmailEx^mimeinln.html#InlineEmailEx^^Converts e-mail address to canonical mime form. You can specify source charset.    ^0"
s[662] = "mimeinln.InlineEmail^mimeinln.html#InlineEmail^^Converts e-mail address to canonical mime form. Source charser it system default charset.    ^0"
s[663] = "mimemess^mimemess.html^MIME message handling^ Classes for easy handling with e-mail message. ^0"
s[664] = "mimemess.TMessHeader^mimemess.TMessHeader.html^Object for basic e-mail header fields.^ ^0"
s[665] = "mimemess.TMessHeader.Create^mimemess.TMessHeader.html#Create^^    ^0"
s[666] = "mimemess.TMessHeader.Destroy^mimemess.TMessHeader.html#Destroy^^    ^0"
s[667] = "mimemess.TMessHeader.Clear^mimemess.TMessHeader.html#Clear^^Clears all data fields.    ^0"
s[668] = "mimemess.TMessHeader.EncodeHeaders^mimemess.TMessHeader.html#EncodeHeaders^^    ^0"
s[669] = "mimemess.TMessHeader.DecodeHeaders^mimemess.TMessHeader.html#DecodeHeaders^^Parse header from Value to this object.    ^0"
s[670] = "mimemess.TMessHeader.FindHeader^mimemess.TMessHeader.html#FindHeader^^Try find specific header in CustomHeader. Search is case insensitive. This is good for reading any non-parsed header.    ^0"
s[671] = "mimemess.TMessHeader.FindHeaderList^mimemess.TMessHeader.html#FindHeaderList^^Try find specific headers in CustomHeader. This metod is for repeatly used headers like 'received' header, etc. Search is case insensitive. This is good for reading ano non-parsed header.    ^0"
s[672] = "mimemess.TMessHeader.From^mimemess.TMessHeader.html#From^^Sender of message. ^0"
s[673] = "mimemess.TMessHeader.ToList^mimemess.TMessHeader.html#ToList^^Stringlist with receivers of message. (one per line) ^0"
s[674] = "mimemess.TMessHeader.CCList^mimemess.TMessHeader.html#CCList^^Stringlist with Carbon Copy receivers of message. (one per line) ^0"
s[675] = "mimemess.TMessHeader.Subject^mimemess.TMessHeader.html#Subject^^Subject of message. ^0"
s[676] = "mimemess.TMessHeader.Organization^mimemess.TMessHeader.html#Organization^^Organization string. ^0"
s[677] = "mimemess.TMessHeader.CustomHeaders^mimemess.TMessHeader.html#CustomHeaders^^After decoding contains all headers lines witch not have parsed to any other structures in this object. It mean: this conatins all other headers except:    <p>X-MAILER, FROM, SUBJECT, ORGANIZATION, TO, CC, DATE, MIME-VERSION, CONTENT-TYPE, CONTENT-DESCRIPTION, CONTENT-DISPOSITION, CONTENT-ID, CONTENT-TRANSFER-ENCODING, REPLY-TO, MESSAGE-ID, X-MSMAIL-PRIORITY, X-PRIORITY, PRIORITY    <p>When you encode headers, all this lines is added as headers. Be carefull for duplicites! ^0"
s[678] = "mimemess.TMessHeader.Date^mimemess.TMessHeader.html#Date^^Date and time of message. ^0"
s[679] = "mimemess.TMessHeader.XMailer^mimemess.TMessHeader.html#XMailer^^Mailer identification. ^0"
s[680] = "mimemess.TMessHeader.ReplyTo^mimemess.TMessHeader.html#ReplyTo^^Address for replies ^0"
s[681] = "mimemess.TMessHeader.MessageID^mimemess.TMessHeader.html#MessageID^^message indetifier ^0"
s[682] = "mimemess.TMessHeader.Priority^mimemess.TMessHeader.html#Priority^^message priority ^0"
s[683] = "mimemess.TMessHeader.CharsetCode^mimemess.TMessHeader.html#CharsetCode^^Specify base charset. By default is used system charset. ^0"
s[684] = "mimemess.TMimeMess^mimemess.TMimeMess.html^Object for handling of e-mail message.^ ^0"
s[685] = "mimemess.TMimeMess.Create^mimemess.TMimeMess.html#Create^^    ^0"
s[686] = "mimemess.TMimeMess.CreateAltHeaders^mimemess.TMimeMess.html#CreateAltHeaders^^create this object and assign your own descendant of <a class=\"normal\" href=\"mimemess.TMessHeader.html\">TMessHeader</a> object to <a class=\"normal\" href=\"mimemess.TMimeMess.html#Header\">Header</a> property. So, you can create your own message headers parser and use it by this object.    ^0"
s[687] = "mimemess.TMimeMess.Destroy^mimemess.TMimeMess.html#Destroy^^    ^0"
s[688] = "mimemess.TMimeMess.Clear^mimemess.TMimeMess.html#Clear^^Reset component to default state.    ^0"
s[689] = "mimemess.TMimeMess.AddPart^mimemess.TMimeMess.html#AddPart^^Add MIME part as subpart of PartParent. If you need set root MIME part, then set as PartParent <code>Nil</code> value. If you need set more then one subpart, you must have PartParent of multipart type!    ^0"
s[690] = "mimemess.TMimeMess.AddPartMultipart^mimemess.TMimeMess.html#AddPartMultipart^^Add MIME part as subpart of PartParent. If you need set root MIME part, then set as PartParent <code>Nil</code> value. If you need set more then 1 subpart, you must have PartParent of multipart type!    <p>This part is marked as multipart with secondary MIME type specified by MultipartType parameter. (typical value is 'mixed')    <p>This part can be used as PartParent for another parts (include next multipart). If you need only one part, then you not need Multipart part.    ^0"
s[691] = "mimemess.TMimeMess.AddPartText^mimemess.TMimeMess.html#AddPartText^^Add MIME part as subpart of PartParent. If you need set root MIME part, then set as PartParent <code>Nil</code> value. If you need set more then 1 subpart, you must have PartParent of multipart type!    <p>After creation of part set type to text part and set all necessary properties. Content of part is readed from value stringlist.    ^0"
s[692] = "mimemess.TMimeMess.AddPartTextEx^mimemess.TMimeMess.html#AddPartTextEx^^Add MIME part as subpart of PartParent. If you need set root MIME part, then set as PartParent <code>Nil</code> value. If you need set more then 1 subpart, you must have PartParent of multipart type!    <p>After creation of part set type to text part and set all necessary properties. Content of part is readed from value stringlist. You can select your charset and your encoding type. If Raw is <code>True</code>, then it not doing charset conversion!    ^0"
s[693] = "mimemess.TMimeMess.AddPartHTML^mimemess.TMimeMess.html#AddPartHTML^^Add MIME part as subpart of PartParent. If you need set root MIME part, then set as PartParent <code>Nil</code> value. If you need set more then 1 subpart, you must have PartParent of multipart type!    <p>After creation of part set type to text part to HTML type and set all necessary properties. Content of HTML part is readed from Value stringlist.    ^0"
s[694] = "mimemess.TMimeMess.AddPartTextFromFile^mimemess.TMimeMess.html#AddPartTextFromFile^^Same as <a class=\"normal\" href=\"mimemess.TMimeMess.html#AddPartText\">AddPartText</a>, but content is readed from file    ^0"
s[695] = "mimemess.TMimeMess.AddPartHTMLFromFile^mimemess.TMimeMess.html#AddPartHTMLFromFile^^Same as <a class=\"normal\" href=\"mimemess.TMimeMess.html#AddPartHTML\">AddPartHTML</a>, but content is readed from file    ^0"
s[696] = "mimemess.TMimeMess.AddPartBinary^mimemess.TMimeMess.html#AddPartBinary^^Add MIME part as subpart of PartParent. If you need set root MIME part, then set as PartParent <code>Nil</code> value. If you need set more then 1 subpart, you must have PartParent of multipart type!    <p>After creation of part set type to binary and set all necessary properties. MIME primary and secondary types defined automaticly by filename extension. Content of binary part is readed from Stream. This binary part is encoded as file attachment.    ^0"
s[697] = "mimemess.TMimeMess.AddPartBinaryFromFile^mimemess.TMimeMess.html#AddPartBinaryFromFile^^Same as <a class=\"normal\" href=\"mimemess.TMimeMess.html#AddPartBinary\">AddPartBinary</a>, but content is readed from file    ^0"
s[698] = "mimemess.TMimeMess.AddPartHTMLBinary^mimemess.TMimeMess.html#AddPartHTMLBinary^^Add MIME part as subpart of PartParent. If you need set root MIME part, then set as PartParent <code>Nil</code> value. If you need set more then 1 subpart, you must have PartParent of multipart type!    <p>After creation of part set type to binary and set all necessary properties. MIME primary and secondary types defined automaticly by filename extension. Content of binary part is readed from Stream.    <p>This binary part is encoded as inline data with given Conten ID (cid). Content ID can be used as reference ID in HTML source in HTML part.    ^0"
s[699] = "mimemess.TMimeMess.AddPartHTMLBinaryFromFile^mimemess.TMimeMess.html#AddPartHTMLBinaryFromFile^^Same as <a class=\"normal\" href=\"mimemess.TMimeMess.html#AddPartHTMLBinary\">AddPartHTMLBinary</a>, but content is readed from file    ^0"
s[700] = "mimemess.TMimeMess.AddPartMess^mimemess.TMimeMess.html#AddPartMess^^Add MIME part as subpart of PartParent. If you need set root MIME part, then set as PartParent <code>Nil</code> value. If you need set more then 1 subpart, you must have PartParent of multipart type!    <p>After creation of part set type to message and set all necessary properties. MIME primary and secondary types are setted to 'message/rfc822'. Content of raw RFC-822 message is readed from Stream.    ^0"
s[701] = "mimemess.TMimeMess.AddPartMessFromFile^mimemess.TMimeMess.html#AddPartMessFromFile^^Same as <a class=\"normal\" href=\"mimemess.TMimeMess.html#AddPartMess\">AddPartMess</a>, but content is readed from file    ^0"
s[702] = "mimemess.TMimeMess.EncodeMessage^mimemess.TMimeMess.html#EncodeMessage^^Compose message from <a class=\"normal\" href=\"mimemess.TMimeMess.html#MessagePart\">MessagePart</a> to <a class=\"normal\" href=\"mimemess.TMimeMess.html#Lines\">Lines</a>. Headers from <a class=\"normal\" href=\"mimemess.TMimeMess.html#Header\">Header</a> object is added also.    ^0"
s[703] = "mimemess.TMimeMess.DecodeMessage^mimemess.TMimeMess.html#DecodeMessage^^Decode message from <a class=\"normal\" href=\"mimemess.TMimeMess.html#Lines\">Lines</a> to <a class=\"normal\" href=\"mimemess.TMimeMess.html#MessagePart\">MessagePart</a>. Massage headers are parsed into <a class=\"normal\" href=\"mimemess.TMimeMess.html#Header\">Header</a> object.    ^0"
s[704] = "mimemess.TMimeMess.DecodeMessageBinary^mimemess.TMimeMess.html#DecodeMessageBinary^^HTTP message is received by <a class=\"normal\" href=\"httpsend.THTTPSend.html\">THTTPSend</a> component in two parts: headers are stored in <a class=\"normal\" href=\"httpsend.THTTPSend.html\">THTTPSend</a>.<a class=\"normal\" href=\"httpsend.THTTPSend.html#Headers\">Headers</a> and a body in memory stream <a class=\"normal\" href=\"httpsend.THTTPSend.html\">THTTPSend</a>.<a class=\"normal\" href=\"httpsend.THTTPSend.html#Document\">Document</a>.    <p>On the top of it, HTTP connections are always 8-bit, hence data are transferred in native format i.e. no transfer encoding is applied.    <p>This method operates the similiar way and produces the same result as <a class=\"normal\" href=\"mimemess.TMimeMess.html#DecodeMessage\">DecodeMessage</a>.    ^0"
s[705] = "mimemess.TMimeMess.MessagePart^mimemess.TMimeMess.html#MessagePart^^<a class=\"normal\" href=\"mimepart.TMimePart.html\">TMimePart</a> object with decoded MIME message. This object can handle any number of nested <a class=\"normal\" href=\"mimepart.TMimePart.html\">TMimePart</a> objects itself. It is used for handle any tree of MIME subparts. ^0"
s[706] = "mimemess.TMimeMess.Lines^mimemess.TMimeMess.html#Lines^^Raw MIME encoded message. ^0"
s[707] = "mimemess.TMimeMess.Header^mimemess.TMimeMess.html#Header^^Object for e-mail header fields. This object is created automaticly. Do not free this object! ^0"
s[708] = "mimemess.TMessPriority^mimemess.html#TMessPriority^^Possible values for message priority  MP_unknown    MP_low    MP_normal    MP_high   ^0"
s[709] = "mimemess.TMessHeaderClass^mimemess.html#TMessHeaderClass^^ ^0"
s[710] = "mimepart^mimepart.html^MIME part handling^ Handling with MIME parts.    <p>Used RFC: RFC-2045 ^0"
s[711] = "mimepart.TMimePart^mimepart.TMimePart.html^Object for working with parts of MIME e-mail.^ Each TMimePart object can handle any number of nested subparts as new TMimepart objects. It can handle any tree hierarchy structure of nested MIME subparts itself.    <p>Basic tasks are:    <p>Decoding of MIME message: - store message into Lines property - call DecomposeParts. Now you have decomposed MIME parts in all nested levels! - now you can explore all properties and subparts. (You can use WalkPart method) - if you need decode part, call DecodePart.    <p>Encoding of MIME message:    <p>- if you need multipart message, you must create subpart by AddSubPart. - set all properties of all parts. - set content of part into DecodedLines stream - encode this stream by EncodePart. - compose full message by ComposeParts. (it build full MIME message from all subparts. Do not call this method for each subpart! It is needed on root part!) - encoded MIME message is stored in Lines property. ^0"
s[712] = "mimepart.TMimePart.Create^mimepart.TMimePart.html#Create^^    ^0"
s[713] = "mimepart.TMimePart.Destroy^mimepart.TMimePart.html#Destroy^^    ^0"
s[714] = "mimepart.TMimePart.Assign^mimepart.TMimePart.html#Assign^^Assign content of another object to this object. (Only this part, not subparts!)    ^0"
s[715] = "mimepart.TMimePart.AssignSubParts^mimepart.TMimePart.html#AssignSubParts^^Assign content of another object to this object. (With all subparts!)    ^0"
s[716] = "mimepart.TMimePart.Clear^mimepart.TMimePart.html#Clear^^Clear all data values to default values. It also call <a class=\"normal\" href=\"mimepart.TMimePart.html#ClearSubParts\">ClearSubParts</a>.    ^0"
s[717] = "mimepart.TMimePart.DecodePart^mimepart.TMimePart.html#DecodePart^^Decode Mime part from <a class=\"normal\" href=\"mimepart.TMimePart.html#Lines\">Lines</a> to <a class=\"normal\" href=\"mimepart.TMimePart.html#DecodedLines\">DecodedLines</a>.    ^0"
s[718] = "mimepart.TMimePart.DecodePartHeader^mimepart.TMimePart.html#DecodePartHeader^^Parse header lines from Headers property into another properties.    ^0"
s[719] = "mimepart.TMimePart.EncodePart^mimepart.TMimePart.html#EncodePart^^Encode mime part from <a class=\"normal\" href=\"mimepart.TMimePart.html#DecodedLines\">DecodedLines</a> to <a class=\"normal\" href=\"mimepart.TMimePart.html#Lines\">Lines</a> and build mime headers.    ^0"
s[720] = "mimepart.TMimePart.EncodePartHeader^mimepart.TMimePart.html#EncodePartHeader^^Build header lines in Headers property from another properties.    ^0"
s[721] = "mimepart.TMimePart.MimeTypeFromExt^mimepart.TMimePart.html#MimeTypeFromExt^^generate primary and secondary mime type from filename extension in value. If type not recognised, it return 'Application/octet-string' type.    ^0"
s[722] = "mimepart.TMimePart.GetSubPartCount^mimepart.TMimePart.html#GetSubPartCount^^Return number of decomposed subparts. (On this level! Each of this subparts can hold any number of their own nested subparts!)    ^0"
s[723] = "mimepart.TMimePart.GetSubPart^mimepart.TMimePart.html#GetSubPart^^Get nested subpart object as new TMimePart. For getting maximum possible index you can use <a class=\"normal\" href=\"mimepart.TMimePart.html#GetSubPartCount\">GetSubPartCount</a> method.    ^0"
s[724] = "mimepart.TMimePart.DeleteSubPart^mimepart.TMimePart.html#DeleteSubPart^^delete subpart on given index.    ^0"
s[725] = "mimepart.TMimePart.ClearSubParts^mimepart.TMimePart.html#ClearSubParts^^Clear and destroy all subpart TMimePart objects.    ^0"
s[726] = "mimepart.TMimePart.AddSubPart^mimepart.TMimePart.html#AddSubPart^^Add and create new subpart.    ^0"
s[727] = "mimepart.TMimePart.DecomposeParts^mimepart.TMimePart.html#DecomposeParts^^E-mail message in <a class=\"normal\" href=\"mimepart.TMimePart.html#Lines\">Lines</a> property is parsed into this object. E-mail headers are stored in <a class=\"normal\" href=\"mimepart.TMimePart.html#Headers\">Headers</a> property and is parsed into another properties automaticly. Not need call <a class=\"normal\" href=\"mimepart.TMimePart.html#DecodePartHeader\">DecodePartHeader</a>! Content of message (part) is stored into <a class=\"normal\" href=\"mimepart.TMimePart.html#PartBody\">PartBody</a> property. This part is in undecoded form! If you need decode it, then you must call <a class=\"normal\" href=\"mimepart.TMimePart.html#DecodePart\">DecodePart</a> method by your hands. Lot of another properties is filled also.    <p>Decoding of parts you must call separately due performance reasons. (Not needed to decode all parts in all reasons.)    <p>For each MIME subpart is created new TMimepart object (accessible via method <a class=\"normal\" href=\"mimepart.TMimePart.html#GetSubPart\">GetSubPart</a>).    ^0"
s[728] = "mimepart.TMimePart.DecomposePartsBinary^mimepart.TMimePart.html#DecomposePartsBinary^^HTTP message is received by <a class=\"normal\" href=\"httpsend.THTTPSend.html\">THTTPSend</a> component in two parts: headers are stored in <a class=\"normal\" href=\"httpsend.THTTPSend.html\">THTTPSend</a>.<a class=\"normal\" href=\"httpsend.THTTPSend.html#Headers\">Headers</a> and a body in memory stream <a class=\"normal\" href=\"httpsend.THTTPSend.html\">THTTPSend</a>.<a class=\"normal\" href=\"httpsend.THTTPSend.html#Document\">Document</a>.    <p>On the top of it, HTTP connections are always 8-bit, hence data are transferred in native format i.e. no transfer encoding is applied.    <p>This method operates the similiar way and produces the same result as <a class=\"normal\" href=\"mimepart.TMimePart.html#DecomposeParts\">DecomposeParts</a>.    ^0"
s[729] = "mimepart.TMimePart.ComposeParts^mimepart.TMimePart.html#ComposeParts^^This part and all subparts is composed into one MIME message stored in <a class=\"normal\" href=\"mimepart.TMimePart.html#Lines\">Lines</a> property.    ^0"
s[730] = "mimepart.TMimePart.WalkPart^mimepart.TMimePart.html#WalkPart^^By calling this method is called <a class=\"normal\" href=\"mimepart.TMimePart.html#OnWalkPart\">OnWalkPart</a> event for each part and their subparts. It is very good for calling some code for each part in MIME message    ^0"
s[731] = "mimepart.TMimePart.CanSubPart^mimepart.TMimePart.html#CanSubPart^^Return <code>True</code> when is possible create next subpart. (<a class=\"normal\" href=\"mimepart.TMimePart.html#MaxSubLevel\">MaxSubLevel</a> is still not reached)    ^0"
s[732] = "mimepart.TMimePart.Primary^mimepart.TMimePart.html#Primary^^Primary Mime type of part. (i.e. 'application') Writing to this property automaticly generate value of <a class=\"normal\" href=\"mimepart.TMimePart.html#PrimaryCode\">PrimaryCode</a>. ^0"
s[733] = "mimepart.TMimePart.Encoding^mimepart.TMimePart.html#Encoding^^String representation of used Mime encoding in part. (i.e. 'base64') Writing to this property automaticly generate value of <a class=\"normal\" href=\"mimepart.TMimePart.html#EncodingCode\">EncodingCode</a>. ^0"
s[734] = "mimepart.TMimePart.Charset^mimepart.TMimePart.html#Charset^^String representation of used Mime charset in part. (i.e. 'iso-8859-1') Writing to this property automaticly generate value of <a class=\"normal\" href=\"mimepart.TMimePart.html#CharsetCode\">CharsetCode</a>. Charset is used only for text parts. ^0"
s[735] = "mimepart.TMimePart.DefaultCharset^mimepart.TMimePart.html#DefaultCharset^^Define default charset for decoding text MIME parts without charset specification. Default value is 'ISO-8859-1' by RCF documents. But Microsoft Outlook use windows codings as default. This property allows properly decode textual parts from some broken versions of Microsoft Outlook. (this is bad software!) ^0"
s[736] = "mimepart.TMimePart.PrimaryCode^mimepart.TMimePart.html#PrimaryCode^^Decoded primary type. Possible values are: MP_TEXT, MP_MULTIPART, MP_MESSAGE and MP_BINARY. If type not recognised, result is MP_BINARY. ^0"
s[737] = "mimepart.TMimePart.EncodingCode^mimepart.TMimePart.html#EncodingCode^^Decoded encoding type. Possible values are: ME_7BIT, ME_8BIT, ME_QUOTED_PRINTABLE and ME_BASE64. If type not recognised, result is ME_7BIT. ^0"
s[738] = "mimepart.TMimePart.CharsetCode^mimepart.TMimePart.html#CharsetCode^^Decoded charset type. Possible values are defined in <a class=\"normal\" href=\"synachar.html\">synachar</a> unit. ^0"
s[739] = "mimepart.TMimePart.TargetCharset^mimepart.TMimePart.html#TargetCharset^^System charset type. Default value is charset used by default in your operating system. ^0"
s[740] = "mimepart.TMimePart.ConvertCharset^mimepart.TMimePart.html#ConvertCharset^^If <code>True</code>, then do internal charset translation of part content between <a class=\"normal\" href=\"mimepart.TMimePart.html#CharsetCode\">CharsetCode</a> and <a class=\"normal\" href=\"mimepart.TMimePart.html#TargetCharset\">TargetCharset</a> ^0"
s[741] = "mimepart.TMimePart.ForcedHTMLConvert^mimepart.TMimePart.html#ForcedHTMLConvert^^If <code>True</code>, then allways do internal charset translation of HTML parts by MIME even it have their own charset in META tag. Default is <code>False</code>. ^0"
s[742] = "mimepart.TMimePart.Secondary^mimepart.TMimePart.html#Secondary^^Secondary Mime type of part. (i.e. 'mixed') ^0"
s[743] = "mimepart.TMimePart.Description^mimepart.TMimePart.html#Description^^Description of Mime part. ^0"
s[744] = "mimepart.TMimePart.Disposition^mimepart.TMimePart.html#Disposition^^Value of content disposition field. (i.e. 'inline' or 'attachment') ^0"
s[745] = "mimepart.TMimePart.ContentID^mimepart.TMimePart.html#ContentID^^Content ID. ^0"
s[746] = "mimepart.TMimePart.Boundary^mimepart.TMimePart.html#Boundary^^Boundary delimiter of multipart Mime part. Used only in multipart part. ^0"
s[747] = "mimepart.TMimePart.FileName^mimepart.TMimePart.html#FileName^^Filename of file in binary part. ^0"
s[748] = "mimepart.TMimePart.Lines^mimepart.TMimePart.html#Lines^^String list with lines contains mime part (It can be a full message). ^0"
s[749] = "mimepart.TMimePart.PartBody^mimepart.TMimePart.html#PartBody^^Encoded form of MIME part data. ^0"
s[750] = "mimepart.TMimePart.Headers^mimepart.TMimePart.html#Headers^^All header lines of MIME part. ^0"
s[751] = "mimepart.TMimePart.PrePart^mimepart.TMimePart.html#PrePart^^On multipart this contains part of message between first line of message and first boundary. ^0"
s[752] = "mimepart.TMimePart.PostPart^mimepart.TMimePart.html#PostPart^^On multipart this contains part of message between last boundary and end of message. ^0"
s[753] = "mimepart.TMimePart.DecodedLines^mimepart.TMimePart.html#DecodedLines^^Stream with decoded form of budy part. ^0"
s[754] = "mimepart.TMimePart.SubLevel^mimepart.TMimePart.html#SubLevel^^Show nested level in subpart tree. Value 0 means root part. 1 means subpart from this root. etc. ^0"
s[755] = "mimepart.TMimePart.MaxSubLevel^mimepart.TMimePart.html#MaxSubLevel^^Specify maximum sublevel value for decomposing. ^0"
s[756] = "mimepart.TMimePart.AttachInside^mimepart.TMimePart.html#AttachInside^^When is <code>True</code>, then this part maybe(!) have included some uuencoded binary data. ^0"
s[757] = "mimepart.TMimePart.OnWalkPart^mimepart.TMimePart.html#OnWalkPart^^Here you can assign hook procedure for walking through all part and their subparts. ^0"
s[758] = "mimepart.TMimePart.MaxLineLength^mimepart.TMimePart.html#MaxLineLength^^Here you can specify maximum line length for encoding of MIME part. If line is longer, then is splitted by standard of MIME. Correct MIME mailers can de-split this line into original length. ^0"
s[759] = "mimepart.MaxMimeType^mimepart.html#MaxMimeType^^ ^0"
s[760] = "mimepart.MimeType^mimepart.html#MimeType^^ ^0"
s[761] = "mimepart.GenerateBoundary^mimepart.html#GenerateBoundary^^Generates a unique boundary string.    ^0"
s[762] = "mimepart.THookWalkPart^mimepart.html#THookWalkPart^Procedural type for <a class=\"normal\" href=\"mimepart.TMimePart.html\">TMimePart</a>.<a class=\"normal\" href=\"mimepart.TMimePart.html#WalkPart\">WalkPart</a> hook^. This hook is used for easy walking through MIME subparts.    ^0"
s[763] = "mimepart.TMimePrimary^mimepart.html#TMimePrimary^^The four types of MIME parts. (textual, multipart, message or any other binary data.)  MP_TEXT    MP_MULTIPART    MP_MESSAGE    MP_BINARY   ^0"
s[764] = "mimepart.TMimeEncoding^mimepart.html#TMimeEncoding^^The various types of possible part encodings.  ME_7BIT    ME_8BIT    ME_QUOTED_PRINTABLE    ME_BASE64    ME_UU    ME_XX   ^0"
s[765] = "nntpsend^nntpsend.html^NNTP client^ NNTP (network news transfer protocol)    <p>Used RFC: RFC-977, RFC-2980 ^0"
s[766] = "nntpsend.TNNTPSend^nntpsend.TNNTPSend.html^^abstract(Implementation of Network News Transfer Protocol.    <p>Note: Are you missing properties for setting Username and Password? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> object!    <p>Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[767] = "nntpsend.TNNTPSend.Create^nntpsend.TNNTPSend.html#Create^^    ^0"
s[768] = "nntpsend.TNNTPSend.Destroy^nntpsend.TNNTPSend.html#Destroy^^    ^0"
s[769] = "nntpsend.TNNTPSend.Login^nntpsend.TNNTPSend.html#Login^^Connects to NNTP server and begin session.    ^0"
s[770] = "nntpsend.TNNTPSend.Logout^nntpsend.TNNTPSend.html#Logout^^Logout from NNTP server and terminate session.    ^0"
s[771] = "nntpsend.TNNTPSend.DoCommand^nntpsend.TNNTPSend.html#DoCommand^^By this you can call any NNTP command.    ^0"
s[772] = "nntpsend.TNNTPSend.DoCommandRead^nntpsend.TNNTPSend.html#DoCommandRead^^by this you can call any NNTP command. This variant is used for commands for download information from server.    ^0"
s[773] = "nntpsend.TNNTPSend.DoCommandWrite^nntpsend.TNNTPSend.html#DoCommandWrite^^by this you can call any NNTP command. This variant is used for commands for upload information to server.    ^0"
s[774] = "nntpsend.TNNTPSend.GetArticle^nntpsend.TNNTPSend.html#GetArticle^^Download full message to <a class=\"normal\" href=\"nntpsend.TNNTPSend.html#Data\">Data</a> property. Value can be number of message or message-id (in brackets).    ^0"
s[775] = "nntpsend.TNNTPSend.GetBody^nntpsend.TNNTPSend.html#GetBody^^Download only body of message to <a class=\"normal\" href=\"nntpsend.TNNTPSend.html#Data\">Data</a> property. Value can be number of message or message-id (in brackets).    ^0"
s[776] = "nntpsend.TNNTPSend.GetHead^nntpsend.TNNTPSend.html#GetHead^^Download only headers of message to <a class=\"normal\" href=\"nntpsend.TNNTPSend.html#Data\">Data</a> property. Value can be number of message or message-id (in brackets).    ^0"
s[777] = "nntpsend.TNNTPSend.GetStat^nntpsend.TNNTPSend.html#GetStat^^Get message status. Value can be number of message or message-id (in brackets).    ^0"
s[778] = "nntpsend.TNNTPSend.SelectGroup^nntpsend.TNNTPSend.html#SelectGroup^^Select given group.    ^0"
s[779] = "nntpsend.TNNTPSend.IHave^nntpsend.TNNTPSend.html#IHave^^Tell to server 'I have mesage with given message-ID.' If server need this message, message is uploaded to server.    ^0"
s[780] = "nntpsend.TNNTPSend.GotoLast^nntpsend.TNNTPSend.html#GotoLast^^Move message pointer to last item in group.    ^0"
s[781] = "nntpsend.TNNTPSend.GotoNext^nntpsend.TNNTPSend.html#GotoNext^^Move message pointer to next item in group.    ^0"
s[782] = "nntpsend.TNNTPSend.ListGroups^nntpsend.TNNTPSend.html#ListGroups^^Download to <a class=\"normal\" href=\"nntpsend.TNNTPSend.html#Data\">Data</a> property list of all groups on NNTP server.    ^0"
s[783] = "nntpsend.TNNTPSend.ListNewGroups^nntpsend.TNNTPSend.html#ListNewGroups^^Download to <a class=\"normal\" href=\"nntpsend.TNNTPSend.html#Data\">Data</a> property list of all groups created after given time.    ^0"
s[784] = "nntpsend.TNNTPSend.NewArticles^nntpsend.TNNTPSend.html#NewArticles^^Download to <a class=\"normal\" href=\"nntpsend.TNNTPSend.html#Data\">Data</a> property list of message-ids in given group since given time.    ^0"
s[785] = "nntpsend.TNNTPSend.PostArticle^nntpsend.TNNTPSend.html#PostArticle^^Upload new article to server. (for new messages by you)    ^0"
s[786] = "nntpsend.TNNTPSend.SwitchToSlave^nntpsend.TNNTPSend.html#SwitchToSlave^^Tells to remote NNTP server 'I am not NNTP client, but I am another NNTP server'.    ^0"
s[787] = "nntpsend.TNNTPSend.Xover^nntpsend.TNNTPSend.html#Xover^^Call NNTP XOVER command.    ^0"
s[788] = "nntpsend.TNNTPSend.StartTLS^nntpsend.TNNTPSend.html#StartTLS^^Call STARTTLS command for upgrade connection to SSL/TLS mode.    ^0"
s[789] = "nntpsend.TNNTPSend.FindCap^nntpsend.TNNTPSend.html#FindCap^^Try to find given capability in extension list. This list is getted after successful login to NNTP server. If extension capability is not found, then return is empty string.    ^0"
s[790] = "nntpsend.TNNTPSend.ListExtensions^nntpsend.TNNTPSend.html#ListExtensions^^Try get list of server extensions. List is returned in <a class=\"normal\" href=\"nntpsend.TNNTPSend.html#Data\">Data</a> property.    ^0"
s[791] = "nntpsend.TNNTPSend.ResultCode^nntpsend.TNNTPSend.html#ResultCode^^Result code number of last operation. ^0"
s[792] = "nntpsend.TNNTPSend.ResultString^nntpsend.TNNTPSend.html#ResultString^^String description of last result code from NNTP server. ^0"
s[793] = "nntpsend.TNNTPSend.Data^nntpsend.TNNTPSend.html#Data^^Readed data. (message, etc.) ^0"
s[794] = "nntpsend.TNNTPSend.AutoTLS^nntpsend.TNNTPSend.html#AutoTLS^^If is set to <code>True</code>, then upgrade to SSL/TLS mode after login if remote server support it. ^0"
s[795] = "nntpsend.TNNTPSend.FullSSL^nntpsend.TNNTPSend.html#FullSSL^^SSL/TLS mode is used from first contact to server. Servers with full SSL/TLS mode usualy using non-standard TCP port! ^0"
s[796] = "nntpsend.TNNTPSend.Sock^nntpsend.TNNTPSend.html#Sock^^Socket object used for TCP/IP operation. Good for seting OnStatus hook, etc. ^0"
s[797] = "nntpsend.cNNTPProtocol^nntpsend.html#cNNTPProtocol^^ ^0"
s[798] = "pingsend^pingsend.html^^ ^0"
s[799] = "pingsend.TPINGSend^pingsend.TPINGSend.html^Implementation of ICMP PING and ICMPv6 PING.^ ^0"
s[800] = "pingsend.TPINGSend.Ping^pingsend.TPINGSend.html#Ping^^Send ICMP ping to host and count <a class=\"normal\" href=\"pingsend.TPINGSend.html#PingTime\">PingTime</a>. If ping OK, result is <code>True</code>.    ^0"
s[801] = "pingsend.TPINGSend.Create^pingsend.TPINGSend.html#Create^^    ^0"
s[802] = "pingsend.TPINGSend.Destroy^pingsend.TPINGSend.html#Destroy^^    ^0"
s[803] = "pingsend.TPINGSend.PacketSize^pingsend.TPINGSend.html#PacketSize^^Size of PING packet. Default size is 32 bytes. ^0"
s[804] = "pingsend.TPINGSend.PingTime^pingsend.TPINGSend.html#PingTime^^Time between request and reply. ^0"
s[805] = "pingsend.TPINGSend.ReplyFrom^pingsend.TPINGSend.html#ReplyFrom^^From this address is sended reply for your PING request. It maybe not your requested destination, when some error occured! ^0"
s[806] = "pingsend.TPINGSend.ReplyType^pingsend.TPINGSend.html#ReplyType^^ICMP type of PING reply. Each protocol using another values! For IPv4 and IPv6 are used different values! ^0"
s[807] = "pingsend.TPINGSend.ReplyCode^pingsend.TPINGSend.html#ReplyCode^^ICMP code of PING reply. Each protocol using another values! For IPv4 and IPv6 are used different values! For protocol independent value look to <a class=\"normal\" href=\"pingsend.TPINGSend.html#ReplyError\">ReplyError</a> ^0"
s[808] = "pingsend.TPINGSend.ReplyError^pingsend.TPINGSend.html#ReplyError^^Return type of returned ICMP message. This value is independent on used protocol! ^0"
s[809] = "pingsend.TPINGSend.ReplyErrorDesc^pingsend.TPINGSend.html#ReplyErrorDesc^^Return human readable description of returned packet type. ^0"
s[810] = "pingsend.TPINGSend.Sock^pingsend.TPINGSend.html#Sock^^Socket object used for TCP/IP operation. Good for seting OnStatus hook, etc. ^0"
s[811] = "pingsend.TPINGSend.TTL^pingsend.TPINGSend.html#TTL^^TTL value for ICMP query ^0"
s[812] = "pingsend.ICMP_ECHO^pingsend.html#ICMP_ECHO^^ ^0"
s[813] = "pingsend.ICMP_ECHOREPLY^pingsend.html#ICMP_ECHOREPLY^^ ^0"
s[814] = "pingsend.ICMP_UNREACH^pingsend.html#ICMP_UNREACH^^ ^0"
s[815] = "pingsend.ICMP_TIME_EXCEEDED^pingsend.html#ICMP_TIME_EXCEEDED^^ ^0"
s[816] = "pingsend.ICMP6_ECHO^pingsend.html#ICMP6_ECHO^^ ^0"
s[817] = "pingsend.ICMP6_ECHOREPLY^pingsend.html#ICMP6_ECHOREPLY^^ ^0"
s[818] = "pingsend.ICMP6_UNREACH^pingsend.html#ICMP6_UNREACH^^ ^0"
s[819] = "pingsend.ICMP6_TIME_EXCEEDED^pingsend.html#ICMP6_TIME_EXCEEDED^^ ^0"
s[820] = "pingsend.PingHost^pingsend.html#PingHost^^A very useful function and example of its use would be found in the TPINGSend object. Use it to ping to any host. If successful, returns the ping time in milliseconds. Returns -1 if an error occurred.    ^0"
s[821] = "pingsend.TraceRouteHost^pingsend.html#TraceRouteHost^^A very useful function and example of its use would be found in the TPINGSend object. Use it to TraceRoute to any host.    ^0"
s[822] = "pingsend.TICMPError^pingsend.html#TICMPError^^List of possible ICMP reply packet types.  IE_NoError    IE_Other    IE_TTLExceed    IE_UnreachOther    IE_UnreachRoute    IE_UnreachAdmin    IE_UnreachAddr    IE_UnreachPort   ^0"
s[823] = "pop3send^pop3send.html^POP3 protocol client^    <p>Used RFC: RFC-1734, RFC-1939, RFC-2195, RFC-2449, RFC-2595 ^0"
s[824] = "pop3send.TPOP3Send^pop3send.TPOP3Send.html^Implementation of POP3 client protocol.^    <p>Note: Are you missing properties for setting Username and Password? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> object!    <p>Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[825] = "pop3send.TPOP3Send.Create^pop3send.TPOP3Send.html#Create^^    ^0"
s[826] = "pop3send.TPOP3Send.Destroy^pop3send.TPOP3Send.html#Destroy^^    ^0"
s[827] = "pop3send.TPOP3Send.CustomCommand^pop3send.TPOP3Send.html#CustomCommand^^You can call any custom by this method. Call Command without trailing CRLF. If MultiLine parameter is <code>True</code>, multilined response are expected. Result is <code>True</code> on sucess.    ^0"
s[828] = "pop3send.TPOP3Send.Capability^pop3send.TPOP3Send.html#Capability^^Call CAPA command for get POP3 server capabilites. note: not all servers support this command!    ^0"
s[829] = "pop3send.TPOP3Send.Login^pop3send.TPOP3Send.html#Login^^Connect to remote POP3 host. If all OK, result is <code>True</code>.    ^0"
s[830] = "pop3send.TPOP3Send.Logout^pop3send.TPOP3Send.html#Logout^^Disconnects from POP3 server.    ^0"
s[831] = "pop3send.TPOP3Send.Reset^pop3send.TPOP3Send.html#Reset^^Send RSET command. If all OK, result is <code>True</code>.    ^0"
s[832] = "pop3send.TPOP3Send.NoOp^pop3send.TPOP3Send.html#NoOp^^Send NOOP command. If all OK, result is <code>True</code>.    ^0"
s[833] = "pop3send.TPOP3Send.Stat^pop3send.TPOP3Send.html#Stat^^Send STAT command and fill <a class=\"normal\" href=\"pop3send.TPOP3Send.html#StatCount\">StatCount</a> and <a class=\"normal\" href=\"pop3send.TPOP3Send.html#StatSize\">StatSize</a> property. If all OK, result is <code>True</code>.    ^0"
s[834] = "pop3send.TPOP3Send.List^pop3send.TPOP3Send.html#List^^Send LIST command. If Value is 0, LIST is for all messages. After successful operation is listing in FullResult. If all OK, result is <code>True</code>.    ^0"
s[835] = "pop3send.TPOP3Send.Retr^pop3send.TPOP3Send.html#Retr^^Send RETR command. After successful operation dowloaded message in <a class=\"normal\" href=\"pop3send.TPOP3Send.html#FullResult\">FullResult</a>. If all OK, result is <code>True</code>.    ^0"
s[836] = "pop3send.TPOP3Send.RetrStream^pop3send.TPOP3Send.html#RetrStream^^Send RETR command. After successful operation dowloaded message in <code>Stream</code>. If all OK, result is <code>True</code>.    ^0"
s[837] = "pop3send.TPOP3Send.Dele^pop3send.TPOP3Send.html#Dele^^Send DELE command for delete specified message. If all OK, result is <code>True</code>.    ^0"
s[838] = "pop3send.TPOP3Send.Top^pop3send.TPOP3Send.html#Top^^Send TOP command. After successful operation dowloaded headers of message and maxlines count of message in <a class=\"normal\" href=\"pop3send.TPOP3Send.html#FullResult\">FullResult</a>. If all OK, result is <code>True</code>.    ^0"
s[839] = "pop3send.TPOP3Send.Uidl^pop3send.TPOP3Send.html#Uidl^^Send UIDL command. If Value is 0, UIDL is for all messages. After successful operation is listing in FullResult. If all OK, result is <code>True</code>.    ^0"
s[840] = "pop3send.TPOP3Send.StartTLS^pop3send.TPOP3Send.html#StartTLS^^Call STLS command for upgrade connection to SSL/TLS mode.    ^0"
s[841] = "pop3send.TPOP3Send.FindCap^pop3send.TPOP3Send.html#FindCap^^Try to find given capabily in capabilty string returned from POP3 server by CAPA command.    ^0"
s[842] = "pop3send.TPOP3Send.ResultCode^pop3send.TPOP3Send.html#ResultCode^^Result code of last POP3 operation. 0 - error, 1 - OK. ^0"
s[843] = "pop3send.TPOP3Send.ResultString^pop3send.TPOP3Send.html#ResultString^^Result string of last POP3 operation. ^0"
s[844] = "pop3send.TPOP3Send.FullResult^pop3send.TPOP3Send.html#FullResult^^Stringlist with full lines returned as result of POP3 operation. I.e. if operation is LIST, this property is filled by list of messages. If operation is RETR, this property have downloaded message. ^0"
s[845] = "pop3send.TPOP3Send.StatCount^pop3send.TPOP3Send.html#StatCount^^After STAT command is there count of messages in inbox. ^0"
s[846] = "pop3send.TPOP3Send.StatSize^pop3send.TPOP3Send.html#StatSize^^After STAT command is there size of all messages in inbox. ^0"
s[847] = "pop3send.TPOP3Send.ListSize^pop3send.TPOP3Send.html#ListSize^^After LIST 0 command size of all messages on server, After LIST x size of message x on server ^0"
s[848] = "pop3send.TPOP3Send.TimeStamp^pop3send.TPOP3Send.html#TimeStamp^^If server support this, after comnnect is in this property timestamp of remote server. ^0"
s[849] = "pop3send.TPOP3Send.AuthType^pop3send.TPOP3Send.html#AuthType^^Type of authorisation for login to POP3 server. Dafault is autodetect one of possible authorisation. Autodetect do this:    <p>If remote POP3 server support APOP, try login by APOP method. If APOP is not supported, or if APOP login failed, try classic USER+PASS login method. ^0"
s[850] = "pop3send.TPOP3Send.AutoTLS^pop3send.TPOP3Send.html#AutoTLS^^If is set to <code>True</code>, then upgrade to SSL/TLS mode if remote server support it. ^0"
s[851] = "pop3send.TPOP3Send.FullSSL^pop3send.TPOP3Send.html#FullSSL^^SSL/TLS mode is used from first contact to server. Servers with full SSL/TLS mode usualy using non-standard TCP port! ^0"
s[852] = "pop3send.TPOP3Send.Sock^pop3send.TPOP3Send.html#Sock^^Socket object used for TCP/IP operation. Good for seting OnStatus hook, etc. ^0"
s[853] = "pop3send.cPop3Protocol^pop3send.html#cPop3Protocol^^ ^0"
s[854] = "pop3send.TPOP3AuthType^pop3send.html#TPOP3AuthType^^The three types of possible authorization methods for &quot;logging in&quot; to a POP3 server.  POP3AuthAll    POP3AuthLogin    POP3AuthAPOP   ^0"
s[855] = "slogsend^slogsend.html^BSD SYSLOG protocol^    <p>Used RFC: RFC-3164 ^0"
s[856] = "slogsend.TSyslogMessage^slogsend.TSyslogMessage.html^encoding or decoding of SYSLOG message^ ^0"
s[857] = "slogsend.TSyslogMessage.Clear^slogsend.TSyslogMessage.html#Clear^^Reset values to defaults    ^0"
s[858] = "slogsend.TSyslogMessage.Facility^slogsend.TSyslogMessage.html#Facility^^Define facilicity of Syslog message. For specify you may use predefined FCL_* constants. Default is &quot;FCL_Local0&quot;. ^0"
s[859] = "slogsend.TSyslogMessage.Severity^slogsend.TSyslogMessage.html#Severity^^Define possible priority of Syslog message. Default is &quot;Debug&quot;. ^0"
s[860] = "slogsend.TSyslogMessage.DateTime^slogsend.TSyslogMessage.html#DateTime^^date and time of Syslog message ^0"
s[861] = "slogsend.TSyslogMessage.Tag^slogsend.TSyslogMessage.html#Tag^^This is used for identify process of this message. Default is filename of your executable file. ^0"
s[862] = "slogsend.TSyslogMessage.LogMessage^slogsend.TSyslogMessage.html#LogMessage^^Text of your message for log. ^0"
s[863] = "slogsend.TSyslogMessage.LocalIP^slogsend.TSyslogMessage.html#LocalIP^^IP address of message sender. ^0"
s[864] = "slogsend.TSyslogMessage.PacketBuf^slogsend.TSyslogMessage.html#PacketBuf^^This property holds encoded binary SYSLOG packet ^0"
s[865] = "slogsend.TSyslogSend^slogsend.TSyslogSend.html^This object implement BSD SysLog client^    <p>Note: Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[866] = "slogsend.TSyslogSend.Create^slogsend.TSyslogSend.html#Create^^    ^0"
s[867] = "slogsend.TSyslogSend.Destroy^slogsend.TSyslogSend.html#Destroy^^    ^0"
s[868] = "slogsend.TSyslogSend.DoIt^slogsend.TSyslogSend.html#DoIt^^Send Syslog UDP packet defined by <a class=\"normal\" href=\"slogsend.TSyslogSend.html#SysLogMessage\">SysLogMessage</a>.    ^0"
s[869] = "slogsend.TSyslogSend.SysLogMessage^slogsend.TSyslogSend.html#SysLogMessage^^Syslog message for send ^0"
s[870] = "slogsend.cSysLogProtocol^slogsend.html#cSysLogProtocol^^ ^0"
s[871] = "slogsend.FCL_Kernel^slogsend.html#FCL_Kernel^^ ^0"
s[872] = "slogsend.FCL_UserLevel^slogsend.html#FCL_UserLevel^^ ^0"
s[873] = "slogsend.FCL_MailSystem^slogsend.html#FCL_MailSystem^^ ^0"
s[874] = "slogsend.FCL_System^slogsend.html#FCL_System^^ ^0"
s[875] = "slogsend.FCL_Security^slogsend.html#FCL_Security^^ ^0"
s[876] = "slogsend.FCL_Syslogd^slogsend.html#FCL_Syslogd^^ ^0"
s[877] = "slogsend.FCL_Printer^slogsend.html#FCL_Printer^^ ^0"
s[878] = "slogsend.FCL_News^slogsend.html#FCL_News^^ ^0"
s[879] = "slogsend.FCL_UUCP^slogsend.html#FCL_UUCP^^ ^0"
s[880] = "slogsend.FCL_Clock^slogsend.html#FCL_Clock^^ ^0"
s[881] = "slogsend.FCL_Authorization^slogsend.html#FCL_Authorization^^ ^0"
s[882] = "slogsend.FCL_FTP^slogsend.html#FCL_FTP^^ ^0"
s[883] = "slogsend.FCL_NTP^slogsend.html#FCL_NTP^^ ^0"
s[884] = "slogsend.FCL_LogAudit^slogsend.html#FCL_LogAudit^^ ^0"
s[885] = "slogsend.FCL_LogAlert^slogsend.html#FCL_LogAlert^^ ^0"
s[886] = "slogsend.FCL_Time^slogsend.html#FCL_Time^^ ^0"
s[887] = "slogsend.FCL_Local0^slogsend.html#FCL_Local0^^ ^0"
s[888] = "slogsend.FCL_Local1^slogsend.html#FCL_Local1^^ ^0"
s[889] = "slogsend.FCL_Local2^slogsend.html#FCL_Local2^^ ^0"
s[890] = "slogsend.FCL_Local3^slogsend.html#FCL_Local3^^ ^0"
s[891] = "slogsend.FCL_Local4^slogsend.html#FCL_Local4^^ ^0"
s[892] = "slogsend.FCL_Local5^slogsend.html#FCL_Local5^^ ^0"
s[893] = "slogsend.FCL_Local6^slogsend.html#FCL_Local6^^ ^0"
s[894] = "slogsend.FCL_Local7^slogsend.html#FCL_Local7^^ ^0"
s[895] = "slogsend.ToSysLog^slogsend.html#ToSysLog^^Simply send packet to specified Syslog server.    ^0"
s[896] = "slogsend.TSyslogSeverity^slogsend.html#TSyslogSeverity^Define possible priority of Syslog message^  Emergency    Alert    Critical    Error    Warning    Notice    Info    Debug   ^0"
s[897] = "smtpsend^smtpsend.html^SMTP client^    <p>Used RFC: RFC-1869, RFC-1870, RFC-1893, RFC-2034, RFC-2104, RFC-2195, RFC-2487, RFC-2554, RFC-2821 ^0"
s[898] = "smtpsend.TSMTPSend^smtpsend.TSMTPSend.html^Implementation of SMTP and ESMTP procotol^, include some ESMTP extensions, include SSL/TLS too.    <p>Note: Are you missing properties for setting Username and Password for ESMTP? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> object!    <p>Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[899] = "smtpsend.TSMTPSend.Create^smtpsend.TSMTPSend.html#Create^^    ^0"
s[900] = "smtpsend.TSMTPSend.Destroy^smtpsend.TSMTPSend.html#Destroy^^    ^0"
s[901] = "smtpsend.TSMTPSend.Login^smtpsend.TSMTPSend.html#Login^^Connects to SMTP server (defined in <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a>.<a class=\"normal\" href=\"blcksock.TSynaClient.html#TargetHost\">TargetHost</a>) and begin SMTP session. (First try ESMTP EHLO, next old HELO handshake). Parses ESMTP capabilites and if you specified Username and password and remote server can handle AUTH command, try login by AUTH command. Preffered login method is CRAM-MD5 (if safer!). If all OK, result is <code>True</code>, else result is <code>False</code>.    ^0"
s[902] = "smtpsend.TSMTPSend.Logout^smtpsend.TSMTPSend.html#Logout^^Close SMTP session (QUIT command) and disconnect from SMTP server.    ^0"
s[903] = "smtpsend.TSMTPSend.Reset^smtpsend.TSMTPSend.html#Reset^^Send RSET SMTP command for reset SMTP session. If all OK, result is <code>True</code>, else result is <code>False</code>.    ^0"
s[904] = "smtpsend.TSMTPSend.NoOp^smtpsend.TSMTPSend.html#NoOp^^Send NOOP SMTP command for keep SMTP session. If all OK, result is <code>True</code>, else result is <code>False</code>.    ^0"
s[905] = "smtpsend.TSMTPSend.MailFrom^smtpsend.TSMTPSend.html#MailFrom^^Send MAIL FROM SMTP command for set sender e-mail address. If sender's e-mail address is empty string, transmited message is error message.    <p>If size not 0 and remote server can handle SIZE parameter, append SIZE parameter to request. If all OK, result is <code>True</code>, else result is <code>False</code>.    ^0"
s[906] = "smtpsend.TSMTPSend.MailTo^smtpsend.TSMTPSend.html#MailTo^^Send RCPT TO SMTP command for set receiver e-mail address. It cannot be an empty string. If all OK, result is <code>True</code>, else result is <code>False</code>.    ^0"
s[907] = "smtpsend.TSMTPSend.MailData^smtpsend.TSMTPSend.html#MailData^^Send DATA SMTP command and transmit message data. If all OK, result is <code>True</code>, else result is <code>False</code>.    ^0"
s[908] = "smtpsend.TSMTPSend.Etrn^smtpsend.TSMTPSend.html#Etrn^^Send ETRN SMTP command for start sending of remote queue for domain in Value. If all OK, result is <code>True</code>, else result is <code>False</code>.    ^0"
s[909] = "smtpsend.TSMTPSend.Verify^smtpsend.TSMTPSend.html#Verify^^Send VRFY SMTP command for check receiver e-mail address. It cannot be an empty string. If all OK, result is <code>True</code>, else result is <code>False</code>.    ^0"
s[910] = "smtpsend.TSMTPSend.StartTLS^smtpsend.TSMTPSend.html#StartTLS^^Call STARTTLS command for upgrade connection to SSL/TLS mode.    ^0"
s[911] = "smtpsend.TSMTPSend.EnhCodeString^smtpsend.TSMTPSend.html#EnhCodeString^^Return string descriptive text for enhanced result codes stored in <a class=\"normal\" href=\"smtpsend.TSMTPSend.html#EnhCode1\">EnhCode1</a>, <a class=\"normal\" href=\"smtpsend.TSMTPSend.html#EnhCode2\">EnhCode2</a> and <a class=\"normal\" href=\"smtpsend.TSMTPSend.html#EnhCode3\">EnhCode3</a>.    ^0"
s[912] = "smtpsend.TSMTPSend.FindCap^smtpsend.TSMTPSend.html#FindCap^^Try to find specified capability in ESMTP response.    ^0"
s[913] = "smtpsend.TSMTPSend.ResultCode^smtpsend.TSMTPSend.html#ResultCode^^result code of last SMTP command. ^0"
s[914] = "smtpsend.TSMTPSend.ResultString^smtpsend.TSMTPSend.html#ResultString^^result string of last SMTP command (begin with string representation of result code). ^0"
s[915] = "smtpsend.TSMTPSend.FullResult^smtpsend.TSMTPSend.html#FullResult^^All result strings of last SMTP command (result is maybe multiline!). ^0"
s[916] = "smtpsend.TSMTPSend.ESMTPcap^smtpsend.TSMTPSend.html#ESMTPcap^^List of ESMTP capabilites of remote ESMTP server. (If you connect to ESMTP server only!). ^0"
s[917] = "smtpsend.TSMTPSend.ESMTP^smtpsend.TSMTPSend.html#ESMTP^^<code>True</code> if you successfuly logged to ESMTP server. ^0"
s[918] = "smtpsend.TSMTPSend.AuthDone^smtpsend.TSMTPSend.html#AuthDone^^<code>True</code> if you successfuly pass authorisation to remote server. ^0"
s[919] = "smtpsend.TSMTPSend.ESMTPSize^smtpsend.TSMTPSend.html#ESMTPSize^^<code>True</code> if remote server can handle SIZE parameter. ^0"
s[920] = "smtpsend.TSMTPSend.MaxSize^smtpsend.TSMTPSend.html#MaxSize^^When <a class=\"normal\" href=\"smtpsend.TSMTPSend.html#ESMTPSize\">ESMTPSize</a> is <code>True</code>, contains max length of message that remote server can handle. ^0"
s[921] = "smtpsend.TSMTPSend.EnhCode1^smtpsend.TSMTPSend.html#EnhCode1^^First digit of Enhanced result code. If last operation does not have enhanced result code, values is 0. ^0"
s[922] = "smtpsend.TSMTPSend.EnhCode2^smtpsend.TSMTPSend.html#EnhCode2^^Second digit of Enhanced result code. If last operation does not have enhanced result code, values is 0. ^0"
s[923] = "smtpsend.TSMTPSend.EnhCode3^smtpsend.TSMTPSend.html#EnhCode3^^Third digit of Enhanced result code. If last operation does not have enhanced result code, values is 0. ^0"
s[924] = "smtpsend.TSMTPSend.SystemName^smtpsend.TSMTPSend.html#SystemName^^name of our system used in HELO and EHLO command. Implicit value is internet address of your machine. ^0"
s[925] = "smtpsend.TSMTPSend.AutoTLS^smtpsend.TSMTPSend.html#AutoTLS^^If is set to true, then upgrade to SSL/TLS mode if remote server support it. ^0"
s[926] = "smtpsend.TSMTPSend.FullSSL^smtpsend.TSMTPSend.html#FullSSL^^SSL/TLS mode is used from first contact to server. Servers with full SSL/TLS mode usualy using non-standard TCP port! ^0"
s[927] = "smtpsend.TSMTPSend.Sock^smtpsend.TSMTPSend.html#Sock^^Socket object used for TCP/IP operation. Good for seting OnStatus hook, etc. ^0"
s[928] = "smtpsend.cSmtpProtocol^smtpsend.html#cSmtpProtocol^^ ^0"
s[929] = "smtpsend.SendToRaw^smtpsend.html#SendToRaw^^A very useful function and example of its use would be found in the TSMTPsend object. Send maildata (text of e-mail with all SMTP headers! For example when text of message is created by <a class=\"normal\" href=\"mimemess.TMimeMess.html\">TMimeMess</a> object) from &quot;MailFrom&quot; e-mail address to &quot;MailTo&quot; e-mail address (If you need more then one receiver, then separate their addresses by comma).    <p>Function sends e-mail to a SMTP server defined in &quot;SMTPhost&quot; parameter. Username and password are used for authorization to the &quot;SMTPhost&quot;. If you don't want authorization, set &quot;Username&quot; and &quot;Password&quot; to empty strings. If e-mail message is successfully sent, the result returns <code>True</code>.    <p>If you need use different port number then standard, then add this port number to SMTPhost after colon. (i.e. '127.0.0.1:1025')    ^0"
s[930] = "smtpsend.SendTo^smtpsend.html#SendTo^^A very useful function and example of its use would be found in the TSMTPsend object. Send &quot;Maildata&quot; (text of e-mail without any SMTP headers!) from &quot;MailFrom&quot; e-mail address to &quot;MailTo&quot; e-mail address with &quot;Subject&quot;. (If you need more then one receiver, then separate their addresses by comma).    <p>This function constructs all needed SMTP headers (with DATE header) and sends the e-mail to the SMTP server defined in the &quot;SMTPhost&quot; parameter. If the e-mail message is successfully sent, the result will be <code>True</code>.    <p>If you need use different port number then standard, then add this port number to SMTPhost after colon. (i.e. '127.0.0.1:1025')    ^0"
s[931] = "smtpsend.SendToEx^smtpsend.html#SendToEx^^A very useful function and example of its use would be found in the TSMTPsend object. Sends &quot;MailData&quot; (text of e-mail without any SMTP headers!) from &quot;MailFrom&quot; e-mail address to &quot;MailTo&quot; e-mail address (If you need more then one receiver, then separate their addresses by comma).    <p>This function sends the e-mail to the SMTP server defined in the &quot;SMTPhost&quot; parameter. Username and password are used for authorization to the &quot;SMTPhost&quot;. If you dont want authorization, set &quot;Username&quot; and &quot;Password&quot; to empty Strings. If the e-mail message is successfully sent, the result will be <code>True</code>.    <p>If you need use different port number then standard, then add this port number to SMTPhost after colon. (i.e. '127.0.0.1:1025')    ^0"
s[932] = "snmpsend^snmpsend.html^SNMP client^ Supports SNMPv1 include traps, SNMPv2c and SNMPv3 include authorization and privacy encryption.    <p>Used RFC: RFC-1157, RFC-1901, RFC-3412, RFC-3414, RFC-3416, RFC-3826    <p>Supported Authorization hashes: MD5, SHA1 Supported Privacy encryptions: DES, 3DES, AES ^0"
s[933] = "snmpsend.TSNMPMib^snmpsend.TSNMPMib.html^Data object with one record of MIB OID and corresponding values.^ ^0"
s[934] = "snmpsend.TSNMPMib.OID^snmpsend.TSNMPMib.html#OID^^OID number in string format. ^0"
s[935] = "snmpsend.TSNMPMib.Value^snmpsend.TSNMPMib.html#Value^^Value of OID object in string format. ^0"
s[936] = "snmpsend.TSNMPMib.ValueType^snmpsend.TSNMPMib.html#ValueType^^Define type of Value. Supported values are defined in <a class=\"normal\" href=\"asn1util.html\">asn1util</a>. For queries use ASN1_NULL, becouse you don't know type in response! ^0"
s[937] = "snmpsend.TV3Sync^snmpsend.TV3Sync.html^It holding all information for SNMPv3 agent synchronization^ Used internally. ^0"
s[938] = "snmpsend.TV3Sync.EngineID^snmpsend.TV3Sync.html#EngineID^^ ^0"
s[939] = "snmpsend.TV3Sync.EngineBoots^snmpsend.TV3Sync.html#EngineBoots^^ ^0"
s[940] = "snmpsend.TV3Sync.EngineTime^snmpsend.TV3Sync.html#EngineTime^^ ^0"
s[941] = "snmpsend.TV3Sync.EngineStamp^snmpsend.TV3Sync.html#EngineStamp^^ ^0"
s[942] = "snmpsend.TSNMPRec^snmpsend.TSNMPRec.html^Data object abstracts SNMP data packet^ ^0"
s[943] = "snmpsend.TSNMPRec.Create^snmpsend.TSNMPRec.html#Create^^    ^0"
s[944] = "snmpsend.TSNMPRec.Destroy^snmpsend.TSNMPRec.html#Destroy^^    ^0"
s[945] = "snmpsend.TSNMPRec.DecodeBuf^snmpsend.TSNMPRec.html#DecodeBuf^^Decode SNMP packet in buffer to object properties.    ^0"
s[946] = "snmpsend.TSNMPRec.EncodeBuf^snmpsend.TSNMPRec.html#EncodeBuf^^Encode obeject properties to SNMP packet.    ^0"
s[947] = "snmpsend.TSNMPRec.Clear^snmpsend.TSNMPRec.html#Clear^^Clears all object properties to default values.    ^0"
s[948] = "snmpsend.TSNMPRec.MIBAdd^snmpsend.TSNMPRec.html#MIBAdd^^Add entry to <a class=\"normal\" href=\"snmpsend.TSNMPRec.html#SNMPMibList\">SNMPMibList</a>. For queries use value as empty string, and ValueType as ASN1_NULL.    ^0"
s[949] = "snmpsend.TSNMPRec.MIBDelete^snmpsend.TSNMPRec.html#MIBDelete^^Delete entry from <a class=\"normal\" href=\"snmpsend.TSNMPRec.html#SNMPMibList\">SNMPMibList</a>.    ^0"
s[950] = "snmpsend.TSNMPRec.MIBGet^snmpsend.TSNMPRec.html#MIBGet^^Search <a class=\"normal\" href=\"snmpsend.TSNMPRec.html#SNMPMibList\">SNMPMibList</a> list for MIB and return correspond value.    ^0"
s[951] = "snmpsend.TSNMPRec.MIBCount^snmpsend.TSNMPRec.html#MIBCount^^return number of entries in MIB array.    ^0"
s[952] = "snmpsend.TSNMPRec.MIBByIndex^snmpsend.TSNMPRec.html#MIBByIndex^^Return MIB information from given row of MIB array.    ^0"
s[953] = "snmpsend.TSNMPRec.SNMPMibList^snmpsend.TSNMPRec.html#SNMPMibList^^List of <a class=\"normal\" href=\"snmpsend.TSNMPMib.html\">TSNMPMib</a> objects. ^0"
s[954] = "snmpsend.TSNMPRec.Version^snmpsend.TSNMPRec.html#Version^^Version of SNMP packet. Default value is 0 (SNMP ver. 1). You can use value 1 for SNMPv2c or value 3 for SNMPv3. ^0"
s[955] = "snmpsend.TSNMPRec.Community^snmpsend.TSNMPRec.html#Community^^Community string for autorize access to SNMP server. (Case sensitive!) Community string is not used in SNMPv3! Use <a class=\"normal\" href=\"snmpsend.TSNMPRec.html#UserName\">UserName</a> and <a class=\"normal\" href=\"snmpsend.TSNMPRec.html#Password\">Password</a> instead! ^0"
s[956] = "snmpsend.TSNMPRec.PDUType^snmpsend.TSNMPRec.html#PDUType^^Define type of SNMP operation. ^0"
s[957] = "snmpsend.TSNMPRec.ID^snmpsend.TSNMPRec.html#ID^^Contains ID number. Not need to use. ^0"
s[958] = "snmpsend.TSNMPRec.ErrorStatus^snmpsend.TSNMPRec.html#ErrorStatus^^When packet is reply, contains error code. Supported values are defined by E* constants. ^0"
s[959] = "snmpsend.TSNMPRec.ErrorIndex^snmpsend.TSNMPRec.html#ErrorIndex^^Point to error position in reply packet. Not usefull for users. It only good for debugging! ^0"
s[960] = "snmpsend.TSNMPRec.NonRepeaters^snmpsend.TSNMPRec.html#NonRepeaters^^special value for GetBulkRequest of SNMPv2 and v3. ^0"
s[961] = "snmpsend.TSNMPRec.MaxRepetitions^snmpsend.TSNMPRec.html#MaxRepetitions^^special value for GetBulkRequest of SNMPv2 and v3. ^0"
s[962] = "snmpsend.TSNMPRec.MaxSize^snmpsend.TSNMPRec.html#MaxSize^^Maximum message size in bytes for SNMPv3. For sending is default 1472 bytes. ^0"
s[963] = "snmpsend.TSNMPRec.Flags^snmpsend.TSNMPRec.html#Flags^^Specify if message is authorised or encrypted. Used only in SNMPv3. ^0"
s[964] = "snmpsend.TSNMPRec.FlagReportable^snmpsend.TSNMPRec.html#FlagReportable^^For SNMPv3.... If is <code>True</code>, SNMP agent must send reply (at least with some error). ^0"
s[965] = "snmpsend.TSNMPRec.ContextEngineID^snmpsend.TSNMPRec.html#ContextEngineID^^For SNMPv3. If not specified, is used value from <a class=\"normal\" href=\"snmpsend.TSNMPRec.html#AuthEngineID\">AuthEngineID</a> ^0"
s[966] = "snmpsend.TSNMPRec.ContextName^snmpsend.TSNMPRec.html#ContextName^^For SNMPv3. ^0"
s[967] = "snmpsend.TSNMPRec.AuthMode^snmpsend.TSNMPRec.html#AuthMode^^For SNMPv3. Specify Authorization mode. (specify used hash for authorization) ^0"
s[968] = "snmpsend.TSNMPRec.PrivMode^snmpsend.TSNMPRec.html#PrivMode^^For SNMPv3. Specify Privacy mode. ^0"
s[969] = "snmpsend.TSNMPRec.AuthEngineID^snmpsend.TSNMPRec.html#AuthEngineID^^value used by SNMPv3 authorisation for synchronization with SNMP agent. ^0"
s[970] = "snmpsend.TSNMPRec.AuthEngineBoots^snmpsend.TSNMPRec.html#AuthEngineBoots^^value used by SNMPv3 authorisation for synchronization with SNMP agent. ^0"
s[971] = "snmpsend.TSNMPRec.AuthEngineTime^snmpsend.TSNMPRec.html#AuthEngineTime^^value used by SNMPv3 authorisation for synchronization with SNMP agent. ^0"
s[972] = "snmpsend.TSNMPRec.AuthEngineTimeStamp^snmpsend.TSNMPRec.html#AuthEngineTimeStamp^^value used by SNMPv3 authorisation for synchronization with SNMP agent. ^0"
s[973] = "snmpsend.TSNMPRec.UserName^snmpsend.TSNMPRec.html#UserName^^SNMPv3 authorization username ^0"
s[974] = "snmpsend.TSNMPRec.Password^snmpsend.TSNMPRec.html#Password^^SNMPv3 authorization password ^0"
s[975] = "snmpsend.TSNMPRec.AuthKey^snmpsend.TSNMPRec.html#AuthKey^^For SNMPv3. Computed Athorization key from <a class=\"normal\" href=\"snmpsend.TSNMPRec.html#Password\">Password</a>. ^0"
s[976] = "snmpsend.TSNMPRec.PrivPassword^snmpsend.TSNMPRec.html#PrivPassword^^SNMPv3 privacy password ^0"
s[977] = "snmpsend.TSNMPRec.PrivKey^snmpsend.TSNMPRec.html#PrivKey^^For SNMPv3. Computed Privacy key from <a class=\"normal\" href=\"snmpsend.TSNMPRec.html#PrivPassword\">PrivPassword</a>. ^0"
s[978] = "snmpsend.TSNMPRec.OldTrapEnterprise^snmpsend.TSNMPRec.html#OldTrapEnterprise^^MIB value to identify the object that sent the TRAPv1. ^0"
s[979] = "snmpsend.TSNMPRec.OldTrapHost^snmpsend.TSNMPRec.html#OldTrapHost^^Address of TRAPv1 sender (IP address). ^0"
s[980] = "snmpsend.TSNMPRec.OldTrapGen^snmpsend.TSNMPRec.html#OldTrapGen^^Generic TRAPv1 identification. ^0"
s[981] = "snmpsend.TSNMPRec.OldTrapSpec^snmpsend.TSNMPRec.html#OldTrapSpec^^Specific TRAPv1 identification. ^0"
s[982] = "snmpsend.TSNMPRec.OldTrapTimeTicks^snmpsend.TSNMPRec.html#OldTrapTimeTicks^^Number of 1/100th of seconds since last reboot or power up. (for TRAPv1) ^0"
s[983] = "snmpsend.TSNMPSend^snmpsend.TSNMPSend.html^Implementation of SNMP protocol.^    <p>Note: Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[984] = "snmpsend.TSNMPSend.Create^snmpsend.TSNMPSend.html#Create^^    ^0"
s[985] = "snmpsend.TSNMPSend.Destroy^snmpsend.TSNMPSend.html#Destroy^^    ^0"
s[986] = "snmpsend.TSNMPSend.SendRequest^snmpsend.TSNMPSend.html#SendRequest^^Connects to a Host and send there query. If in timeout SNMP server send back query, result is <code>True</code>. If is used SNMPv3, then it synchronize self with SNMPv3 agent first. (It is needed for SNMPv3 auhorization!)    ^0"
s[987] = "snmpsend.TSNMPSend.SendTrap^snmpsend.TSNMPSend.html#SendTrap^^Send SNMP packet only, but not waits for reply. Good for sending traps.    ^0"
s[988] = "snmpsend.TSNMPSend.RecvTrap^snmpsend.TSNMPSend.html#RecvTrap^^Receive SNMP packet only. Good for receiving traps.    ^0"
s[989] = "snmpsend.TSNMPSend.DoIt^snmpsend.TSNMPSend.html#DoIt^^Mapped to <a class=\"normal\" href=\"snmpsend.TSNMPSend.html#SendRequest\">SendRequest</a> internally. This function is only for backward compatibility.    ^0"
s[990] = "snmpsend.TSNMPSend.Buffer^snmpsend.TSNMPSend.html#Buffer^^contains raw binary form of SNMP packet. Good for debugging. ^0"
s[991] = "snmpsend.TSNMPSend.HostIP^snmpsend.TSNMPSend.html#HostIP^^After SNMP operation hold IP address of remote side. ^0"
s[992] = "snmpsend.TSNMPSend.Query^snmpsend.TSNMPSend.html#Query^^Data object contains SNMP query. ^0"
s[993] = "snmpsend.TSNMPSend.Reply^snmpsend.TSNMPSend.html#Reply^^Data object contains SNMP reply. ^0"
s[994] = "snmpsend.TSNMPSend.Sock^snmpsend.TSNMPSend.html#Sock^^Socket object used for TCP/IP operation. Good for seting OnStatus hook, etc. ^0"
s[995] = "snmpsend.cSnmpProtocol^snmpsend.html#cSnmpProtocol^^ ^0"
s[996] = "snmpsend.cSnmpTrapProtocol^snmpsend.html#cSnmpTrapProtocol^^ ^0"
s[997] = "snmpsend.SNMP_V1^snmpsend.html#SNMP_V1^^ ^0"
s[998] = "snmpsend.SNMP_V2C^snmpsend.html#SNMP_V2C^^ ^0"
s[999] = "snmpsend.SNMP_V3^snmpsend.html#SNMP_V3^^ ^0"
s[1000] = "snmpsend.PDUGetRequest^snmpsend.html#PDUGetRequest^^ ^0"
s[1001] = "snmpsend.PDUGetNextRequest^snmpsend.html#PDUGetNextRequest^^ ^0"
s[1002] = "snmpsend.PDUGetResponse^snmpsend.html#PDUGetResponse^^ ^0"
s[1003] = "snmpsend.PDUSetRequest^snmpsend.html#PDUSetRequest^^ ^0"
s[1004] = "snmpsend.PDUTrap^snmpsend.html#PDUTrap^^ ^0"
s[1005] = "snmpsend.PDUGetBulkRequest^snmpsend.html#PDUGetBulkRequest^^ ^0"
s[1006] = "snmpsend.PDUInformRequest^snmpsend.html#PDUInformRequest^^ ^0"
s[1007] = "snmpsend.PDUTrapV2^snmpsend.html#PDUTrapV2^^ ^0"
s[1008] = "snmpsend.PDUReport^snmpsend.html#PDUReport^^ ^0"
s[1009] = "snmpsend.ENoError^snmpsend.html#ENoError^^ ^0"
s[1010] = "snmpsend.ETooBig^snmpsend.html#ETooBig^^ ^0"
s[1011] = "snmpsend.ENoSuchName^snmpsend.html#ENoSuchName^^ ^0"
s[1012] = "snmpsend.EBadValue^snmpsend.html#EBadValue^^ ^0"
s[1013] = "snmpsend.EReadOnly^snmpsend.html#EReadOnly^^ ^0"
s[1014] = "snmpsend.EGenErr^snmpsend.html#EGenErr^^ ^0"
s[1015] = "snmpsend.ENoAccess^snmpsend.html#ENoAccess^^ ^0"
s[1016] = "snmpsend.EWrongType^snmpsend.html#EWrongType^^ ^0"
s[1017] = "snmpsend.EWrongLength^snmpsend.html#EWrongLength^^ ^0"
s[1018] = "snmpsend.EWrongEncoding^snmpsend.html#EWrongEncoding^^ ^0"
s[1019] = "snmpsend.EWrongValue^snmpsend.html#EWrongValue^^ ^0"
s[1020] = "snmpsend.ENoCreation^snmpsend.html#ENoCreation^^ ^0"
s[1021] = "snmpsend.EInconsistentValue^snmpsend.html#EInconsistentValue^^ ^0"
s[1022] = "snmpsend.EResourceUnavailable^snmpsend.html#EResourceUnavailable^^ ^0"
s[1023] = "snmpsend.ECommitFailed^snmpsend.html#ECommitFailed^^ ^0"
s[1024] = "snmpsend.EUndoFailed^snmpsend.html#EUndoFailed^^ ^0"
s[1025] = "snmpsend.EAuthorizationError^snmpsend.html#EAuthorizationError^^ ^0"
s[1026] = "snmpsend.ENotWritable^snmpsend.html#ENotWritable^^ ^0"
s[1027] = "snmpsend.EInconsistentName^snmpsend.html#EInconsistentName^^ ^0"
s[1028] = "snmpsend.SNMPGet^snmpsend.html#SNMPGet^^A very useful function and example of its use would be found in the TSNMPSend object. It implements basic GET method of the SNMP protocol. The MIB value is located in the &quot;OID&quot; variable, and is sent to the requested &quot;SNMPHost&quot; with the proper &quot;Community&quot; access identifier. Upon a successful retrieval, &quot;Value&quot; will contain the information requested. If the SNMP operation is successful, the result returns <code>True</code>.    ^0"
s[1029] = "snmpsend.SNMPSet^snmpsend.html#SNMPSet^^This is useful function and example of use TSNMPSend object. It implements the basic SET method of the SNMP protocol. If the SNMP operation is successful, the result is <code>True</code>. &quot;Value&quot; is value of MIB Oid for &quot;SNMPHost&quot; with &quot;Community&quot; access identifier. You must specify &quot;ValueType&quot; too.    ^0"
s[1030] = "snmpsend.SNMPGetNext^snmpsend.html#SNMPGetNext^^A very useful function and example of its use would be found in the TSNMPSend object. It implements basic GETNEXT method of the SNMP protocol. The MIB value is located in the &quot;OID&quot; variable, and is sent to the requested &quot;SNMPHost&quot; with the proper &quot;Community&quot; access identifier. Upon a successful retrieval, &quot;Value&quot; will contain the information requested. If the SNMP operation is successful, the result returns <code>True</code>.    ^0"
s[1031] = "snmpsend.SNMPGetTable^snmpsend.html#SNMPGetTable^^A very useful function and example of its use would be found in the TSNMPSend object. It implements basic read of SNMP MIB tables. As BaseOID you must specify basic MIB OID of requested table (base IOD is OID without row and column specificator!) Table is readed into stringlist, where each string is comma delimited string.    <p>Warning: this function is not have best performance. For better performance you must write your own function. best performace you can get by knowledge of structuture of table and by more then one MIB on one query.    ^0"
s[1032] = "snmpsend.SNMPGetTableElement^snmpsend.html#SNMPGetTableElement^^A very useful function and example of its use would be found in the TSNMPSend object. It implements basic read of SNMP MIB table element. As BaseOID you must specify basic MIB OID of requested table (base IOD is OID without row and column specificator!) As next you must specify identificator of row and column for specify of needed field of table.    ^0"
s[1033] = "snmpsend.SendTrap^snmpsend.html#SendTrap^^A very useful function and example of its use would be found in the TSNMPSend object. It implements a TRAPv1 to send with all data in the parameters.    ^0"
s[1034] = "snmpsend.RecvTrap^snmpsend.html#RecvTrap^^A very useful function and example of its use would be found in the TSNMPSend object. It receives a TRAPv1 and returns all the data that comes with it.    ^0"
s[1035] = "snmpsend.TV3Flags^snmpsend.html#TV3Flags^Possible values for SNMPv3 flags.^ This flags specify level of authorization and encryption.  NoAuthNoPriv    AuthNoPriv    AuthPriv   ^0"
s[1036] = "snmpsend.TV3Auth^snmpsend.html#TV3Auth^Type of SNMPv3 authorization^  AuthMD5    AuthSHA1   ^0"
s[1037] = "snmpsend.TV3Priv^snmpsend.html#TV3Priv^Type of SNMPv3 privacy^  PrivDES    Priv3DES    PrivAES   ^0"
s[1038] = "sntpsend^sntpsend.html^ NTP and SNTP client^    <p>Used RFC: RFC-1305, RFC-2030 ^0"
s[1039] = "sntpsend.TNtp^sntpsend.TNtp.html^Record containing the NTP packet.^ ^0"
s[1040] = "sntpsend.TNtp.mode^sntpsend.TNtp.html#mode^^ ^0"
s[1041] = "sntpsend.TNtp.stratum^sntpsend.TNtp.html#stratum^^ ^0"
s[1042] = "sntpsend.TNtp.poll^sntpsend.TNtp.html#poll^^ ^0"
s[1043] = "sntpsend.TNtp.Precision^sntpsend.TNtp.html#Precision^^ ^0"
s[1044] = "sntpsend.TNtp.RootDelay^sntpsend.TNtp.html#RootDelay^^ ^0"
s[1045] = "sntpsend.TNtp.RootDisperson^sntpsend.TNtp.html#RootDisperson^^ ^0"
s[1046] = "sntpsend.TNtp.RefID^sntpsend.TNtp.html#RefID^^ ^0"
s[1047] = "sntpsend.TNtp.Ref1^sntpsend.TNtp.html#Ref1^^ ^0"
s[1048] = "sntpsend.TNtp.Ref2^sntpsend.TNtp.html#Ref2^^ ^0"
s[1049] = "sntpsend.TNtp.Org1^sntpsend.TNtp.html#Org1^^ ^0"
s[1050] = "sntpsend.TNtp.Org2^sntpsend.TNtp.html#Org2^^ ^0"
s[1051] = "sntpsend.TNtp.Rcv1^sntpsend.TNtp.html#Rcv1^^ ^0"
s[1052] = "sntpsend.TNtp.Rcv2^sntpsend.TNtp.html#Rcv2^^ ^0"
s[1053] = "sntpsend.TNtp.Xmit1^sntpsend.TNtp.html#Xmit1^^ ^0"
s[1054] = "sntpsend.TNtp.Xmit2^sntpsend.TNtp.html#Xmit2^^ ^0"
s[1055] = "sntpsend.TSNTPSend^sntpsend.TSNTPSend.html^Implementation of NTP and SNTP client protocol^, include time synchronisation. It can send NTP or SNTP time queries, or it can receive NTP broadcasts too.    <p>Note: Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[1056] = "sntpsend.TSNTPSend.Create^sntpsend.TSNTPSend.html#Create^^    ^0"
s[1057] = "sntpsend.TSNTPSend.Destroy^sntpsend.TSNTPSend.html#Destroy^^    ^0"
s[1058] = "sntpsend.TSNTPSend.DecodeTs^sntpsend.TSNTPSend.html#DecodeTs^^Decode 128 bit timestamp used in NTP packet to TDateTime type.    ^0"
s[1059] = "sntpsend.TSNTPSend.EncodeTs^sntpsend.TSNTPSend.html#EncodeTs^^Decode TDateTime type to 128 bit timestamp used in NTP packet.    ^0"
s[1060] = "sntpsend.TSNTPSend.GetSNTP^sntpsend.TSNTPSend.html#GetSNTP^^Send request to <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a>.<a class=\"normal\" href=\"blcksock.TSynaClient.html#TargetHost\">TargetHost</a> and wait for reply. If all is OK, then result is <code>True</code> and <a class=\"normal\" href=\"sntpsend.TSNTPSend.html#NTPReply\">NTPReply</a> and <a class=\"normal\" href=\"sntpsend.TSNTPSend.html#NTPTime\">NTPTime</a> are valid.    ^0"
s[1061] = "sntpsend.TSNTPSend.GetNTP^sntpsend.TSNTPSend.html#GetNTP^^Send request to <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a>.<a class=\"normal\" href=\"blcksock.TSynaClient.html#TargetHost\">TargetHost</a> and wait for reply. If all is OK, then result is <code>True</code> and <a class=\"normal\" href=\"sntpsend.TSNTPSend.html#NTPReply\">NTPReply</a> and <a class=\"normal\" href=\"sntpsend.TSNTPSend.html#NTPTime\">NTPTime</a> are valid. Result time is after all needed corrections.    ^0"
s[1062] = "sntpsend.TSNTPSend.GetBroadcastNTP^sntpsend.TSNTPSend.html#GetBroadcastNTP^^Wait for broadcast NTP packet. If all OK, result is <code>True</code> and <a class=\"normal\" href=\"sntpsend.TSNTPSend.html#NTPReply\">NTPReply</a> and <a class=\"normal\" href=\"sntpsend.TSNTPSend.html#NTPTime\">NTPTime</a> are valid.    ^0"
s[1063] = "sntpsend.TSNTPSend.NTPReply^sntpsend.TSNTPSend.html#NTPReply^^Holds last received NTP packet. ^0"
s[1064] = "sntpsend.TSNTPSend.NTPTime^sntpsend.TSNTPSend.html#NTPTime^^Date and time of remote NTP or SNTP server. (UTC time!!!) ^0"
s[1065] = "sntpsend.TSNTPSend.NTPOffset^sntpsend.TSNTPSend.html#NTPOffset^^Offset between your computer and remote NTP or SNTP server. ^0"
s[1066] = "sntpsend.TSNTPSend.NTPDelay^sntpsend.TSNTPSend.html#NTPDelay^^Delay between your computer and remote NTP or SNTP server. ^0"
s[1067] = "sntpsend.TSNTPSend.MaxSyncDiff^sntpsend.TSNTPSend.html#MaxSyncDiff^^Define allowed maximum difference between your time and remote time for synchronising time. If difference is bigger, your system time is not changed! ^0"
s[1068] = "sntpsend.TSNTPSend.SyncTime^sntpsend.TSNTPSend.html#SyncTime^^If <code>True</code>, after successfull getting time is local computer clock synchronised to given time. For synchronising time you must have proper rights! (Usually Administrator) ^0"
s[1069] = "sntpsend.TSNTPSend.Sock^sntpsend.TSNTPSend.html#Sock^^Socket object used for TCP/IP operation. Good for seting OnStatus hook, etc. ^0"
s[1070] = "sntpsend.cNtpProtocol^sntpsend.html#cNtpProtocol^^ ^0"
s[1071] = "ssl_cryptlib^ssl_cryptlib.html^SSL/SSH plugin for CryptLib^    <p>This plugin requires cl32.dll at least version 3.2.0! It can be used on Win32 and Linux. This library is staticly linked - when you compile your application with this plugin, you MUST distribute it with Cryptib library, otherwise you cannot run your application!    <p>It can work with keys and certificates stored as PKCS#15 only! It must be stored as disk file only, you cannot load them from memory! Each file can hold multiple keys and certificates. You must identify it by 'label' stored in <a class=\"normal\" href=\"ssl_cryptlib.TSSLCryptLib.html\">TSSLCryptLib</a>.<a class=\"normal\" href=\"ssl_cryptlib.TSSLCryptLib.html#PrivateKeyLabel\">PrivateKeyLabel</a>.    <p>If you need to use secure connection and authorize self by certificate (each SSL/TLS server or client with client authorization), then use <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#PrivateKeyFile\">PrivateKeyFile</a>, <a class=\"normal\" href=\"ssl_cryptlib.TSSLCryptLib.html\">TSSLCryptLib</a>.<a class=\"normal\" href=\"ssl_cryptlib.TSSLCryptLib.html#PrivateKeyLabel\">PrivateKeyLabel</a> and <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#KeyPassword\">KeyPassword</a> properties.    <p>If you need to use server what verifying client certificates, then use <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#CertCAFile\">CertCAFile</a> as PKCS#15 file with public keyas of allowed clients. Clients with non-matching certificates will be rejected by cryptLib.    <p>This plugin is capable to create Ad-Hoc certificates. When you start SSL/TLS server without explicitly assigned key and certificate, then this plugin create Ad-Hoc key and certificate for each incomming connection by self. It slowdown accepting of new connections!    <p>You can use this plugin for SSHv2 connections too! You must explicitly set <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#SSLType\">SSLType</a> to value LT_SSHv2 and set <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Username\">Username</a> and <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Password\">Password</a>. You can use special SSH channels too, see <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>. ^0"
s[1072] = "ssl_cryptlib.TSSLCryptLib^ssl_cryptlib.TSSLCryptLib.html^class implementing CryptLib SSL/SSH plugin.^ Instance of this class will be created for each <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>. You not need to create instance of this class, all is done by Synapse itself! ^0"
s[1073] = "ssl_cryptlib.TSSLCryptLib.Create^ssl_cryptlib.TSSLCryptLib.html#Create^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Create\">Create</a>    ^0"
s[1074] = "ssl_cryptlib.TSSLCryptLib.Destroy^ssl_cryptlib.TSSLCryptLib.html#Destroy^^    ^0"
s[1075] = "ssl_cryptlib.TSSLCryptLib.SetCertCAFile^ssl_cryptlib.TSSLCryptLib.html#SetCertCAFile^^Load trusted CA's in PEM format    ^0"
s[1076] = "ssl_cryptlib.TSSLCryptLib.LibVersion^ssl_cryptlib.TSSLCryptLib.html#LibVersion^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#LibVersion\">LibVersion</a>    ^0"
s[1077] = "ssl_cryptlib.TSSLCryptLib.LibName^ssl_cryptlib.TSSLCryptLib.html#LibName^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#LibName\">LibName</a>    ^0"
s[1078] = "ssl_cryptlib.TSSLCryptLib.Assign^ssl_cryptlib.TSSLCryptLib.html#Assign^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Assign\">Assign</a>    ^0"
s[1079] = "ssl_cryptlib.TSSLCryptLib.Connect^ssl_cryptlib.TSSLCryptLib.html#Connect^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Connect\">Connect</a> and <a class=\"normal\" href=\"ssl_cryptlib.html\">ssl_cryptlib</a> for more details.    ^0"
s[1080] = "ssl_cryptlib.TSSLCryptLib.Accept^ssl_cryptlib.TSSLCryptLib.html#Accept^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Accept\">Accept</a> and <a class=\"normal\" href=\"ssl_cryptlib.html\">ssl_cryptlib</a> for more details.    ^0"
s[1081] = "ssl_cryptlib.TSSLCryptLib.Shutdown^ssl_cryptlib.TSSLCryptLib.html#Shutdown^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Shutdown\">Shutdown</a>    ^0"
s[1082] = "ssl_cryptlib.TSSLCryptLib.BiShutdown^ssl_cryptlib.TSSLCryptLib.html#BiShutdown^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#BiShutdown\">BiShutdown</a>    ^0"
s[1083] = "ssl_cryptlib.TSSLCryptLib.SendBuffer^ssl_cryptlib.TSSLCryptLib.html#SendBuffer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#SendBuffer\">SendBuffer</a>    ^0"
s[1084] = "ssl_cryptlib.TSSLCryptLib.RecvBuffer^ssl_cryptlib.TSSLCryptLib.html#RecvBuffer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#RecvBuffer\">RecvBuffer</a>    ^0"
s[1085] = "ssl_cryptlib.TSSLCryptLib.WaitingData^ssl_cryptlib.TSSLCryptLib.html#WaitingData^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#WaitingData\">WaitingData</a>    ^0"
s[1086] = "ssl_cryptlib.TSSLCryptLib.GetSSLVersion^ssl_cryptlib.TSSLCryptLib.html#GetSSLVersion^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetSSLVersion\">GetSSLVersion</a>    ^0"
s[1087] = "ssl_cryptlib.TSSLCryptLib.GetPeerSubject^ssl_cryptlib.TSSLCryptLib.html#GetPeerSubject^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerSubject\">GetPeerSubject</a>    ^0"
s[1088] = "ssl_cryptlib.TSSLCryptLib.GetPeerIssuer^ssl_cryptlib.TSSLCryptLib.html#GetPeerIssuer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerIssuer\">GetPeerIssuer</a>    ^0"
s[1089] = "ssl_cryptlib.TSSLCryptLib.GetPeerName^ssl_cryptlib.TSSLCryptLib.html#GetPeerName^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerName\">GetPeerName</a>    ^0"
s[1090] = "ssl_cryptlib.TSSLCryptLib.GetPeerFingerprint^ssl_cryptlib.TSSLCryptLib.html#GetPeerFingerprint^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerFingerprint\">GetPeerFingerprint</a>    ^0"
s[1091] = "ssl_cryptlib.TSSLCryptLib.GetVerifyCert^ssl_cryptlib.TSSLCryptLib.html#GetVerifyCert^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetVerifyCert\">GetVerifyCert</a>    ^0"
s[1092] = "ssl_cryptlib.TSSLCryptLib.PrivateKeyLabel^ssl_cryptlib.TSSLCryptLib.html#PrivateKeyLabel^^name of certificate/key within PKCS#15 file. It can hold more then one certificate/key and each certificate/key must have unique label within one file. ^0"
s[1093] = "ssl_openssl^ssl_openssl.html^SSL plugin for OpenSSL^    <p>You need OpenSSL libraries version 0.9.7. It can work with 0.9.6 too, but application mysteriously crashing when you are using freePascal on Linux. Use Kylix on Linux is OK! If you have version 0.9.7 on Linux, then I not see any problems with FreePascal.    <p>OpenSSL libraries are loaded dynamicly - you not need OpenSSl librares even you compile your application with this unit. SSL just not working when you not have OpenSSL libraries.    <p>This plugin have limited support for .NET too! Because is not possible to use callbacks with CDECL calling convention under .NET, is not supported key/certificate passwords and multithread locking. :-(    <p>For handling keys and certificates you can use this properties:    <p><a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#CertificateFile\">CertificateFile</a> for PEM or ASN1 DER (cer) format. <br> <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Certificate\">Certificate</a> for ASN1 DER format only. <br> <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#PrivateKeyFile\">PrivateKeyFile</a> for PEM or ASN1 DER (key) format. <br> <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#PrivateKey\">PrivateKey</a> for ASN1 DER format only. <br> <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#CertCAFile\">CertCAFile</a> for PEM CA certificate bundle. <br> <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#PFXfile\">PFXfile</a> for PFX format. <br> <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#PFX\">PFX</a> for PFX format from binary string. <br>    <p>This plugin is capable to create Ad-Hoc certificates. When you start SSL/TLS server without explicitly assigned key and certificate, then this plugin create Ad-Hoc key and certificate for each incomming connection by self. It slowdown accepting of new connections! ^0"
s[1094] = "ssl_openssl.TSSLOpenSSL^ssl_openssl.TSSLOpenSSL.html^class implementing OpenSSL SSL plugin.^ Instance of this class will be created for each <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>. You not need to create instance of this class, all is done by Synapse itself! ^0"
s[1095] = "ssl_openssl.TSSLOpenSSL.Create^ssl_openssl.TSSLOpenSSL.html#Create^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Create\">Create</a>    ^0"
s[1096] = "ssl_openssl.TSSLOpenSSL.Destroy^ssl_openssl.TSSLOpenSSL.html#Destroy^^    ^0"
s[1097] = "ssl_openssl.TSSLOpenSSL.LibVersion^ssl_openssl.TSSLOpenSSL.html#LibVersion^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#LibVersion\">LibVersion</a>    ^0"
s[1098] = "ssl_openssl.TSSLOpenSSL.LibName^ssl_openssl.TSSLOpenSSL.html#LibName^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#LibName\">LibName</a>    ^0"
s[1099] = "ssl_openssl.TSSLOpenSSL.Connect^ssl_openssl.TSSLOpenSSL.html#Connect^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Connect\">Connect</a> and <a class=\"normal\" href=\"ssl_cryptlib.html\">ssl_cryptlib</a> for more details.    ^0"
s[1100] = "ssl_openssl.TSSLOpenSSL.Accept^ssl_openssl.TSSLOpenSSL.html#Accept^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Accept\">Accept</a> and <a class=\"normal\" href=\"ssl_cryptlib.html\">ssl_cryptlib</a> for more details.    ^0"
s[1101] = "ssl_openssl.TSSLOpenSSL.Shutdown^ssl_openssl.TSSLOpenSSL.html#Shutdown^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Shutdown\">Shutdown</a>    ^0"
s[1102] = "ssl_openssl.TSSLOpenSSL.BiShutdown^ssl_openssl.TSSLOpenSSL.html#BiShutdown^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#BiShutdown\">BiShutdown</a>    ^0"
s[1103] = "ssl_openssl.TSSLOpenSSL.SendBuffer^ssl_openssl.TSSLOpenSSL.html#SendBuffer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#SendBuffer\">SendBuffer</a>    ^0"
s[1104] = "ssl_openssl.TSSLOpenSSL.RecvBuffer^ssl_openssl.TSSLOpenSSL.html#RecvBuffer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#RecvBuffer\">RecvBuffer</a>    ^0"
s[1105] = "ssl_openssl.TSSLOpenSSL.WaitingData^ssl_openssl.TSSLOpenSSL.html#WaitingData^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#WaitingData\">WaitingData</a>    ^0"
s[1106] = "ssl_openssl.TSSLOpenSSL.GetSSLVersion^ssl_openssl.TSSLOpenSSL.html#GetSSLVersion^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetSSLVersion\">GetSSLVersion</a>    ^0"
s[1107] = "ssl_openssl.TSSLOpenSSL.GetPeerSubject^ssl_openssl.TSSLOpenSSL.html#GetPeerSubject^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerSubject\">GetPeerSubject</a>    ^0"
s[1108] = "ssl_openssl.TSSLOpenSSL.GetPeerSerialNo^ssl_openssl.TSSLOpenSSL.html#GetPeerSerialNo^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerSerialNo\">GetPeerSerialNo</a>    ^0"
s[1109] = "ssl_openssl.TSSLOpenSSL.GetPeerIssuer^ssl_openssl.TSSLOpenSSL.html#GetPeerIssuer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerIssuer\">GetPeerIssuer</a>    ^0"
s[1110] = "ssl_openssl.TSSLOpenSSL.GetPeerName^ssl_openssl.TSSLOpenSSL.html#GetPeerName^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerName\">GetPeerName</a>    ^0"
s[1111] = "ssl_openssl.TSSLOpenSSL.GetPeerNameHash^ssl_openssl.TSSLOpenSSL.html#GetPeerNameHash^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerNameHash\">GetPeerNameHash</a>    ^0"
s[1112] = "ssl_openssl.TSSLOpenSSL.GetPeerFingerprint^ssl_openssl.TSSLOpenSSL.html#GetPeerFingerprint^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerFingerprint\">GetPeerFingerprint</a>    ^0"
s[1113] = "ssl_openssl.TSSLOpenSSL.GetCertInfo^ssl_openssl.TSSLOpenSSL.html#GetCertInfo^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetCertInfo\">GetCertInfo</a>    ^0"
s[1114] = "ssl_openssl.TSSLOpenSSL.GetCipherName^ssl_openssl.TSSLOpenSSL.html#GetCipherName^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetCipherName\">GetCipherName</a>    ^0"
s[1115] = "ssl_openssl.TSSLOpenSSL.GetCipherBits^ssl_openssl.TSSLOpenSSL.html#GetCipherBits^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetCipherBits\">GetCipherBits</a>    ^0"
s[1116] = "ssl_openssl.TSSLOpenSSL.GetCipherAlgBits^ssl_openssl.TSSLOpenSSL.html#GetCipherAlgBits^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetCipherAlgBits\">GetCipherAlgBits</a>    ^0"
s[1117] = "ssl_openssl.TSSLOpenSSL.GetVerifyCert^ssl_openssl.TSSLOpenSSL.html#GetVerifyCert^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetVerifyCert\">GetVerifyCert</a>    ^0"
s[1118] = "ssl_openssl_lib^ssl_openssl_lib.html^OpenSSL support^    <p>This unit is Pascal interface to OpenSSL library (used by <a class=\"normal\" href=\"ssl_openssl.html\">ssl_openssl</a> unit). OpenSSL is loaded dynamicly on-demand. If this library is not found in system, requested OpenSSL function just return errorcode. ^0"
s[1119] = "ssl_openssl_lib.des_ks_struct^ssl_openssl_lib.des_ks_struct.html^^ ^0"
s[1120] = "ssl_openssl_lib.des_ks_struct.ks^ssl_openssl_lib.des_ks_struct.html#ks^^ ^0"
s[1121] = "ssl_openssl_lib.des_ks_struct.weak_key^ssl_openssl_lib.des_ks_struct.html#weak_key^^ ^0"
s[1122] = "ssl_openssl_lib.EVP_MAX_MD_SIZE^ssl_openssl_lib.html#EVP_MAX_MD_SIZE^^ ^0"
s[1123] = "ssl_openssl_lib.SSL_ERROR_NONE^ssl_openssl_lib.html#SSL_ERROR_NONE^^ ^0"
s[1124] = "ssl_openssl_lib.SSL_ERROR_SSL^ssl_openssl_lib.html#SSL_ERROR_SSL^^ ^0"
s[1125] = "ssl_openssl_lib.SSL_ERROR_WANT_READ^ssl_openssl_lib.html#SSL_ERROR_WANT_READ^^ ^0"
s[1126] = "ssl_openssl_lib.SSL_ERROR_WANT_WRITE^ssl_openssl_lib.html#SSL_ERROR_WANT_WRITE^^ ^0"
s[1127] = "ssl_openssl_lib.SSL_ERROR_WANT_X509_LOOKUP^ssl_openssl_lib.html#SSL_ERROR_WANT_X509_LOOKUP^^ ^0"
s[1128] = "ssl_openssl_lib.SSL_ERROR_SYSCALL^ssl_openssl_lib.html#SSL_ERROR_SYSCALL^^ ^0"
s[1129] = "ssl_openssl_lib.SSL_ERROR_ZERO_RETURN^ssl_openssl_lib.html#SSL_ERROR_ZERO_RETURN^^ ^0"
s[1130] = "ssl_openssl_lib.SSL_ERROR_WANT_CONNECT^ssl_openssl_lib.html#SSL_ERROR_WANT_CONNECT^^ ^0"
s[1131] = "ssl_openssl_lib.SSL_ERROR_WANT_ACCEPT^ssl_openssl_lib.html#SSL_ERROR_WANT_ACCEPT^^ ^0"
s[1132] = "ssl_openssl_lib.SSL_OP_NO_SSLv2^ssl_openssl_lib.html#SSL_OP_NO_SSLv2^^ ^0"
s[1133] = "ssl_openssl_lib.SSL_OP_NO_SSLv3^ssl_openssl_lib.html#SSL_OP_NO_SSLv3^^ ^0"
s[1134] = "ssl_openssl_lib.SSL_OP_NO_TLSv1^ssl_openssl_lib.html#SSL_OP_NO_TLSv1^^ ^0"
s[1135] = "ssl_openssl_lib.SSL_OP_ALL^ssl_openssl_lib.html#SSL_OP_ALL^^ ^0"
s[1136] = "ssl_openssl_lib.SSL_VERIFY_NONE^ssl_openssl_lib.html#SSL_VERIFY_NONE^^ ^0"
s[1137] = "ssl_openssl_lib.SSL_VERIFY_PEER^ssl_openssl_lib.html#SSL_VERIFY_PEER^^ ^0"
s[1138] = "ssl_openssl_lib.OPENSSL_DES_DECRYPT^ssl_openssl_lib.html#OPENSSL_DES_DECRYPT^^ ^0"
s[1139] = "ssl_openssl_lib.OPENSSL_DES_ENCRYPT^ssl_openssl_lib.html#OPENSSL_DES_ENCRYPT^^ ^0"
s[1140] = "ssl_openssl_lib.X509_V_OK^ssl_openssl_lib.html#X509_V_OK^^ ^0"
s[1141] = "ssl_openssl_lib.X509_V_ILLEGAL^ssl_openssl_lib.html#X509_V_ILLEGAL^^ ^0"
s[1142] = "ssl_openssl_lib.X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT^ssl_openssl_lib.html#X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT^^ ^0"
s[1143] = "ssl_openssl_lib.X509_V_ERR_UNABLE_TO_GET_CRL^ssl_openssl_lib.html#X509_V_ERR_UNABLE_TO_GET_CRL^^ ^0"
s[1144] = "ssl_openssl_lib.X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE^ssl_openssl_lib.html#X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE^^ ^0"
s[1145] = "ssl_openssl_lib.X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE^ssl_openssl_lib.html#X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE^^ ^0"
s[1146] = "ssl_openssl_lib.X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY^ssl_openssl_lib.html#X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY^^ ^0"
s[1147] = "ssl_openssl_lib.X509_V_ERR_CERT_SIGNATURE_FAILURE^ssl_openssl_lib.html#X509_V_ERR_CERT_SIGNATURE_FAILURE^^ ^0"
s[1148] = "ssl_openssl_lib.X509_V_ERR_CRL_SIGNATURE_FAILURE^ssl_openssl_lib.html#X509_V_ERR_CRL_SIGNATURE_FAILURE^^ ^0"
s[1149] = "ssl_openssl_lib.X509_V_ERR_CERT_NOT_YET_VALID^ssl_openssl_lib.html#X509_V_ERR_CERT_NOT_YET_VALID^^ ^0"
s[1150] = "ssl_openssl_lib.X509_V_ERR_CERT_HAS_EXPIRED^ssl_openssl_lib.html#X509_V_ERR_CERT_HAS_EXPIRED^^ ^0"
s[1151] = "ssl_openssl_lib.X509_V_ERR_CRL_NOT_YET_VALID^ssl_openssl_lib.html#X509_V_ERR_CRL_NOT_YET_VALID^^ ^0"
s[1152] = "ssl_openssl_lib.X509_V_ERR_CRL_HAS_EXPIRED^ssl_openssl_lib.html#X509_V_ERR_CRL_HAS_EXPIRED^^ ^0"
s[1153] = "ssl_openssl_lib.X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD^ssl_openssl_lib.html#X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD^^ ^0"
s[1154] = "ssl_openssl_lib.X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD^ssl_openssl_lib.html#X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD^^ ^0"
s[1155] = "ssl_openssl_lib.X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD^ssl_openssl_lib.html#X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD^^ ^0"
s[1156] = "ssl_openssl_lib.X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD^ssl_openssl_lib.html#X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD^^ ^0"
s[1157] = "ssl_openssl_lib.X509_V_ERR_OUT_OF_MEM^ssl_openssl_lib.html#X509_V_ERR_OUT_OF_MEM^^ ^0"
s[1158] = "ssl_openssl_lib.X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT^ssl_openssl_lib.html#X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT^^ ^0"
s[1159] = "ssl_openssl_lib.X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN^ssl_openssl_lib.html#X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN^^ ^0"
s[1160] = "ssl_openssl_lib.X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY^ssl_openssl_lib.html#X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY^^ ^0"
s[1161] = "ssl_openssl_lib.X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE^ssl_openssl_lib.html#X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE^^ ^0"
s[1162] = "ssl_openssl_lib.X509_V_ERR_CERT_CHAIN_TOO_LONG^ssl_openssl_lib.html#X509_V_ERR_CERT_CHAIN_TOO_LONG^^ ^0"
s[1163] = "ssl_openssl_lib.X509_V_ERR_CERT_REVOKED^ssl_openssl_lib.html#X509_V_ERR_CERT_REVOKED^^ ^0"
s[1164] = "ssl_openssl_lib.X509_V_ERR_INVALID_CA^ssl_openssl_lib.html#X509_V_ERR_INVALID_CA^^ ^0"
s[1165] = "ssl_openssl_lib.X509_V_ERR_PATH_LENGTH_EXCEEDED^ssl_openssl_lib.html#X509_V_ERR_PATH_LENGTH_EXCEEDED^^ ^0"
s[1166] = "ssl_openssl_lib.X509_V_ERR_INVALID_PURPOSE^ssl_openssl_lib.html#X509_V_ERR_INVALID_PURPOSE^^ ^0"
s[1167] = "ssl_openssl_lib.X509_V_ERR_CERT_UNTRUSTED^ssl_openssl_lib.html#X509_V_ERR_CERT_UNTRUSTED^^ ^0"
s[1168] = "ssl_openssl_lib.X509_V_ERR_CERT_REJECTED^ssl_openssl_lib.html#X509_V_ERR_CERT_REJECTED^^ ^0"
s[1169] = "ssl_openssl_lib.X509_V_ERR_SUBJECT_ISSUER_MISMATCH^ssl_openssl_lib.html#X509_V_ERR_SUBJECT_ISSUER_MISMATCH^^ ^0"
s[1170] = "ssl_openssl_lib.X509_V_ERR_AKID_SKID_MISMATCH^ssl_openssl_lib.html#X509_V_ERR_AKID_SKID_MISMATCH^^ ^0"
s[1171] = "ssl_openssl_lib.X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH^ssl_openssl_lib.html#X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH^^ ^0"
s[1172] = "ssl_openssl_lib.X509_V_ERR_KEYUSAGE_NO_CERTSIGN^ssl_openssl_lib.html#X509_V_ERR_KEYUSAGE_NO_CERTSIGN^^ ^0"
s[1173] = "ssl_openssl_lib.X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER^ssl_openssl_lib.html#X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER^^ ^0"
s[1174] = "ssl_openssl_lib.X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION^ssl_openssl_lib.html#X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION^^ ^0"
s[1175] = "ssl_openssl_lib.X509_V_ERR_APPLICATION_VERIFICATION^ssl_openssl_lib.html#X509_V_ERR_APPLICATION_VERIFICATION^^ ^0"
s[1176] = "ssl_openssl_lib.SSL_FILETYPE_ASN1^ssl_openssl_lib.html#SSL_FILETYPE_ASN1^^ ^0"
s[1177] = "ssl_openssl_lib.SSL_FILETYPE_PEM^ssl_openssl_lib.html#SSL_FILETYPE_PEM^^ ^0"
s[1178] = "ssl_openssl_lib.EVP_PKEY_RSA^ssl_openssl_lib.html#EVP_PKEY_RSA^^ ^0"
s[1179] = "ssl_openssl_lib.SSL_CTRL_SET_TLSEXT_HOSTNAME^ssl_openssl_lib.html#SSL_CTRL_SET_TLSEXT_HOSTNAME^^ ^0"
s[1180] = "ssl_openssl_lib.TLSEXT_NAMETYPE_host_name^ssl_openssl_lib.html#TLSEXT_NAMETYPE_host_name^^ ^0"
s[1181] = "ssl_openssl_lib.SslGetError^ssl_openssl_lib.html#SslGetError^^    ^0"
s[1182] = "ssl_openssl_lib.SslLibraryInit^ssl_openssl_lib.html#SslLibraryInit^^    ^0"
s[1183] = "ssl_openssl_lib.SslLoadErrorStrings^ssl_openssl_lib.html#SslLoadErrorStrings^^    ^0"
s[1184] = "ssl_openssl_lib.SslCtxSetCipherList^ssl_openssl_lib.html#SslCtxSetCipherList^^    ^0"
s[1185] = "ssl_openssl_lib.SslCtxNew^ssl_openssl_lib.html#SslCtxNew^^    ^0"
s[1186] = "ssl_openssl_lib.SslCtxFree^ssl_openssl_lib.html#SslCtxFree^^    ^0"
s[1187] = "ssl_openssl_lib.SslSetFd^ssl_openssl_lib.html#SslSetFd^^    ^0"
s[1188] = "ssl_openssl_lib.SslMethodV2^ssl_openssl_lib.html#SslMethodV2^^    ^0"
s[1189] = "ssl_openssl_lib.SslMethodV3^ssl_openssl_lib.html#SslMethodV3^^    ^0"
s[1190] = "ssl_openssl_lib.SslMethodTLSV1^ssl_openssl_lib.html#SslMethodTLSV1^^    ^0"
s[1191] = "ssl_openssl_lib.SslMethodV23^ssl_openssl_lib.html#SslMethodV23^^    ^0"
s[1192] = "ssl_openssl_lib.SslCtxUsePrivateKey^ssl_openssl_lib.html#SslCtxUsePrivateKey^^    ^0"
s[1193] = "ssl_openssl_lib.SslCtxUsePrivateKeyASN1^ssl_openssl_lib.html#SslCtxUsePrivateKeyASN1^^    ^0"
s[1194] = "ssl_openssl_lib.SslCtxUsePrivateKeyFile^ssl_openssl_lib.html#SslCtxUsePrivateKeyFile^^    ^0"
s[1195] = "ssl_openssl_lib.SslCtxUseCertificate^ssl_openssl_lib.html#SslCtxUseCertificate^^    ^0"
s[1196] = "ssl_openssl_lib.SslCtxUseCertificateASN1^ssl_openssl_lib.html#SslCtxUseCertificateASN1^^    ^0"
s[1197] = "ssl_openssl_lib.SslCtxUseCertificateFile^ssl_openssl_lib.html#SslCtxUseCertificateFile^^    ^0"
s[1198] = "ssl_openssl_lib.SslCtxUseCertificateChainFile^ssl_openssl_lib.html#SslCtxUseCertificateChainFile^^    ^0"
s[1199] = "ssl_openssl_lib.SslCtxCheckPrivateKeyFile^ssl_openssl_lib.html#SslCtxCheckPrivateKeyFile^^    ^0"
s[1200] = "ssl_openssl_lib.SslCtxSetDefaultPasswdCb^ssl_openssl_lib.html#SslCtxSetDefaultPasswdCb^^    ^0"
s[1201] = "ssl_openssl_lib.SslCtxSetDefaultPasswdCbUserdata^ssl_openssl_lib.html#SslCtxSetDefaultPasswdCbUserdata^^    ^0"
s[1202] = "ssl_openssl_lib.SslCtxLoadVerifyLocations^ssl_openssl_lib.html#SslCtxLoadVerifyLocations^^    ^0"
s[1203] = "ssl_openssl_lib.SslCtxCtrl^ssl_openssl_lib.html#SslCtxCtrl^^    ^0"
s[1204] = "ssl_openssl_lib.SslNew^ssl_openssl_lib.html#SslNew^^    ^0"
s[1205] = "ssl_openssl_lib.SslFree^ssl_openssl_lib.html#SslFree^^    ^0"
s[1206] = "ssl_openssl_lib.SslAccept^ssl_openssl_lib.html#SslAccept^^    ^0"
s[1207] = "ssl_openssl_lib.SslConnect^ssl_openssl_lib.html#SslConnect^^    ^0"
s[1208] = "ssl_openssl_lib.SslShutdown^ssl_openssl_lib.html#SslShutdown^^    ^0"
s[1209] = "ssl_openssl_lib.SslRead^ssl_openssl_lib.html#SslRead^^    ^0"
s[1210] = "ssl_openssl_lib.SslPeek^ssl_openssl_lib.html#SslPeek^^    ^0"
s[1211] = "ssl_openssl_lib.SslWrite^ssl_openssl_lib.html#SslWrite^^    ^0"
s[1212] = "ssl_openssl_lib.SslPending^ssl_openssl_lib.html#SslPending^^    ^0"
s[1213] = "ssl_openssl_lib.SslGetVersion^ssl_openssl_lib.html#SslGetVersion^^    ^0"
s[1214] = "ssl_openssl_lib.SslGetPeerCertificate^ssl_openssl_lib.html#SslGetPeerCertificate^^    ^0"
s[1215] = "ssl_openssl_lib.SslCtxSetVerify^ssl_openssl_lib.html#SslCtxSetVerify^^    ^0"
s[1216] = "ssl_openssl_lib.SSLGetCurrentCipher^ssl_openssl_lib.html#SSLGetCurrentCipher^^    ^0"
s[1217] = "ssl_openssl_lib.SSLCipherGetName^ssl_openssl_lib.html#SSLCipherGetName^^    ^0"
s[1218] = "ssl_openssl_lib.SSLCipherGetBits^ssl_openssl_lib.html#SSLCipherGetBits^^    ^0"
s[1219] = "ssl_openssl_lib.SSLGetVerifyResult^ssl_openssl_lib.html#SSLGetVerifyResult^^    ^0"
s[1220] = "ssl_openssl_lib.SSLCtrl^ssl_openssl_lib.html#SSLCtrl^^    ^0"
s[1221] = "ssl_openssl_lib.X509New^ssl_openssl_lib.html#X509New^^    ^0"
s[1222] = "ssl_openssl_lib.X509Free^ssl_openssl_lib.html#X509Free^^    ^0"
s[1223] = "ssl_openssl_lib.X509NameOneline^ssl_openssl_lib.html#X509NameOneline^^    ^0"
s[1224] = "ssl_openssl_lib.X509GetSubjectName^ssl_openssl_lib.html#X509GetSubjectName^^    ^0"
s[1225] = "ssl_openssl_lib.X509GetIssuerName^ssl_openssl_lib.html#X509GetIssuerName^^    ^0"
s[1226] = "ssl_openssl_lib.X509NameHash^ssl_openssl_lib.html#X509NameHash^^    ^0"
s[1227] = "ssl_openssl_lib.X509Digest^ssl_openssl_lib.html#X509Digest^^    ^0"
s[1228] = "ssl_openssl_lib.X509print^ssl_openssl_lib.html#X509print^^    ^0"
s[1229] = "ssl_openssl_lib.X509SetVersion^ssl_openssl_lib.html#X509SetVersion^^    ^0"
s[1230] = "ssl_openssl_lib.X509SetPubkey^ssl_openssl_lib.html#X509SetPubkey^^    ^0"
s[1231] = "ssl_openssl_lib.X509SetIssuerName^ssl_openssl_lib.html#X509SetIssuerName^^    ^0"
s[1232] = "ssl_openssl_lib.X509NameAddEntryByTxt^ssl_openssl_lib.html#X509NameAddEntryByTxt^^    ^0"
s[1233] = "ssl_openssl_lib.X509Sign^ssl_openssl_lib.html#X509Sign^^    ^0"
s[1234] = "ssl_openssl_lib.X509GmtimeAdj^ssl_openssl_lib.html#X509GmtimeAdj^^    ^0"
s[1235] = "ssl_openssl_lib.X509SetNotBefore^ssl_openssl_lib.html#X509SetNotBefore^^    ^0"
s[1236] = "ssl_openssl_lib.X509SetNotAfter^ssl_openssl_lib.html#X509SetNotAfter^^    ^0"
s[1237] = "ssl_openssl_lib.X509GetSerialNumber^ssl_openssl_lib.html#X509GetSerialNumber^^    ^0"
s[1238] = "ssl_openssl_lib.EvpPkeyNew^ssl_openssl_lib.html#EvpPkeyNew^^    ^0"
s[1239] = "ssl_openssl_lib.EvpPkeyFree^ssl_openssl_lib.html#EvpPkeyFree^^    ^0"
s[1240] = "ssl_openssl_lib.EvpPkeyAssign^ssl_openssl_lib.html#EvpPkeyAssign^^    ^0"
s[1241] = "ssl_openssl_lib.EvpGetDigestByName^ssl_openssl_lib.html#EvpGetDigestByName^^    ^0"
s[1242] = "ssl_openssl_lib.EVPcleanup^ssl_openssl_lib.html#EVPcleanup^^    ^0"
s[1243] = "ssl_openssl_lib.SSLeayversion^ssl_openssl_lib.html#SSLeayversion^^    ^0"
s[1244] = "ssl_openssl_lib.ErrErrorString^ssl_openssl_lib.html#ErrErrorString^^    ^0"
s[1245] = "ssl_openssl_lib.ErrGetError^ssl_openssl_lib.html#ErrGetError^^    ^0"
s[1246] = "ssl_openssl_lib.ErrClearError^ssl_openssl_lib.html#ErrClearError^^    ^0"
s[1247] = "ssl_openssl_lib.ErrFreeStrings^ssl_openssl_lib.html#ErrFreeStrings^^    ^0"
s[1248] = "ssl_openssl_lib.ErrRemoveState^ssl_openssl_lib.html#ErrRemoveState^^    ^0"
s[1249] = "ssl_openssl_lib.OPENSSLaddallalgorithms^ssl_openssl_lib.html#OPENSSLaddallalgorithms^^    ^0"
s[1250] = "ssl_openssl_lib.CRYPTOcleanupAllExData^ssl_openssl_lib.html#CRYPTOcleanupAllExData^^    ^0"
s[1251] = "ssl_openssl_lib.RandScreen^ssl_openssl_lib.html#RandScreen^^    ^0"
s[1252] = "ssl_openssl_lib.BioNew^ssl_openssl_lib.html#BioNew^^    ^0"
s[1253] = "ssl_openssl_lib.BioFreeAll^ssl_openssl_lib.html#BioFreeAll^^    ^0"
s[1254] = "ssl_openssl_lib.BioSMem^ssl_openssl_lib.html#BioSMem^^    ^0"
s[1255] = "ssl_openssl_lib.BioCtrlPending^ssl_openssl_lib.html#BioCtrlPending^^    ^0"
s[1256] = "ssl_openssl_lib.BioRead^ssl_openssl_lib.html#BioRead^^    ^0"
s[1257] = "ssl_openssl_lib.BioWrite^ssl_openssl_lib.html#BioWrite^^    ^0"
s[1258] = "ssl_openssl_lib.d2iPKCS12bio^ssl_openssl_lib.html#d2iPKCS12bio^^    ^0"
s[1259] = "ssl_openssl_lib.PKCS12parse^ssl_openssl_lib.html#PKCS12parse^^    ^0"
s[1260] = "ssl_openssl_lib.PKCS12free^ssl_openssl_lib.html#PKCS12free^^    ^0"
s[1261] = "ssl_openssl_lib.RsaGenerateKey^ssl_openssl_lib.html#RsaGenerateKey^^    ^0"
s[1262] = "ssl_openssl_lib.Asn1UtctimeNew^ssl_openssl_lib.html#Asn1UtctimeNew^^    ^0"
s[1263] = "ssl_openssl_lib.Asn1UtctimeFree^ssl_openssl_lib.html#Asn1UtctimeFree^^    ^0"
s[1264] = "ssl_openssl_lib.Asn1IntegerSet^ssl_openssl_lib.html#Asn1IntegerSet^^    ^0"
s[1265] = "ssl_openssl_lib.Asn1IntegerGet^ssl_openssl_lib.html#Asn1IntegerGet^^    ^0"
s[1266] = "ssl_openssl_lib.i2dX509bio^ssl_openssl_lib.html#i2dX509bio^^    ^0"
s[1267] = "ssl_openssl_lib.d2iX509bio^ssl_openssl_lib.html#d2iX509bio^^    ^0"
s[1268] = "ssl_openssl_lib.PEMReadBioX509^ssl_openssl_lib.html#PEMReadBioX509^^    ^0"
s[1269] = "ssl_openssl_lib.SkX509PopFree^ssl_openssl_lib.html#SkX509PopFree^^    ^0"
s[1270] = "ssl_openssl_lib.i2dPrivateKeyBio^ssl_openssl_lib.html#i2dPrivateKeyBio^^    ^0"
s[1271] = "ssl_openssl_lib.DESsetoddparity^ssl_openssl_lib.html#DESsetoddparity^^    ^0"
s[1272] = "ssl_openssl_lib.DESsetkeychecked^ssl_openssl_lib.html#DESsetkeychecked^^    ^0"
s[1273] = "ssl_openssl_lib.DESecbencrypt^ssl_openssl_lib.html#DESecbencrypt^^    ^0"
s[1274] = "ssl_openssl_lib.IsSSLloaded^ssl_openssl_lib.html#IsSSLloaded^^    ^0"
s[1275] = "ssl_openssl_lib.InitSSLInterface^ssl_openssl_lib.html#InitSSLInterface^^    ^0"
s[1276] = "ssl_openssl_lib.DestroySSLInterface^ssl_openssl_lib.html#DestroySSLInterface^^    ^0"
s[1277] = "ssl_openssl_lib.SslPtr^ssl_openssl_lib.html#SslPtr^^ ^0"
s[1278] = "ssl_openssl_lib.PSslPtr^ssl_openssl_lib.html#PSslPtr^^ ^0"
s[1279] = "ssl_openssl_lib.PSSL_CTX^ssl_openssl_lib.html#PSSL_CTX^^ ^0"
s[1280] = "ssl_openssl_lib.PSSL^ssl_openssl_lib.html#PSSL^^ ^0"
s[1281] = "ssl_openssl_lib.PSSL_METHOD^ssl_openssl_lib.html#PSSL_METHOD^^ ^0"
s[1282] = "ssl_openssl_lib.PX509^ssl_openssl_lib.html#PX509^^ ^0"
s[1283] = "ssl_openssl_lib.PX509_NAME^ssl_openssl_lib.html#PX509_NAME^^ ^0"
s[1284] = "ssl_openssl_lib.PEVP_MD^ssl_openssl_lib.html#PEVP_MD^^ ^0"
s[1285] = "ssl_openssl_lib.PInteger^ssl_openssl_lib.html#PInteger^^ ^0"
s[1286] = "ssl_openssl_lib.PBIO_METHOD^ssl_openssl_lib.html#PBIO_METHOD^^ ^0"
s[1287] = "ssl_openssl_lib.PBIO^ssl_openssl_lib.html#PBIO^^ ^0"
s[1288] = "ssl_openssl_lib.EVP_PKEY^ssl_openssl_lib.html#EVP_PKEY^^ ^0"
s[1289] = "ssl_openssl_lib.PRSA^ssl_openssl_lib.html#PRSA^^ ^0"
s[1290] = "ssl_openssl_lib.PASN1_UTCTIME^ssl_openssl_lib.html#PASN1_UTCTIME^^ ^0"
s[1291] = "ssl_openssl_lib.PASN1_INTEGER^ssl_openssl_lib.html#PASN1_INTEGER^^ ^0"
s[1292] = "ssl_openssl_lib.PPasswdCb^ssl_openssl_lib.html#PPasswdCb^^ ^0"
s[1293] = "ssl_openssl_lib.PFunction^ssl_openssl_lib.html#PFunction^^    ^0"
s[1294] = "ssl_openssl_lib.PSTACK^ssl_openssl_lib.html#PSTACK^^ ^0"
s[1295] = "ssl_openssl_lib.TSkPopFreeFunc^ssl_openssl_lib.html#TSkPopFreeFunc^^    ^0"
s[1296] = "ssl_openssl_lib.TX509Free^ssl_openssl_lib.html#TX509Free^^    ^0"
s[1297] = "ssl_openssl_lib.DES_cblock^ssl_openssl_lib.html#DES_cblock^^ ^0"
s[1298] = "ssl_openssl_lib.PDES_cblock^ssl_openssl_lib.html#PDES_cblock^^ ^0"
s[1299] = "ssl_openssl_lib.des_key_schedule^ssl_openssl_lib.html#des_key_schedule^^ ^0"
s[1300] = "ssl_openssl_lib.DLLSSLName^ssl_openssl_lib.html#DLLSSLName^^ ^0"
s[1301] = "ssl_openssl_lib.DLLSSLName2^ssl_openssl_lib.html#DLLSSLName2^^ ^0"
s[1302] = "ssl_openssl_lib.DLLUtilName^ssl_openssl_lib.html#DLLUtilName^^ ^0"
s[1303] = "ssl_openssl_lib.SSLLibHandle^ssl_openssl_lib.html#SSLLibHandle^^ ^0"
s[1304] = "ssl_openssl_lib.SSLUtilHandle^ssl_openssl_lib.html#SSLUtilHandle^^ ^0"
s[1305] = "ssl_openssl_lib.SSLLibFile^ssl_openssl_lib.html#SSLLibFile^^ ^0"
s[1306] = "ssl_openssl_lib.SSLUtilFile^ssl_openssl_lib.html#SSLUtilFile^^ ^0"
s[1307] = "ssl_openssl_lib._X509Free^ssl_openssl_lib.html#_X509Free^^ ^0"
s[1308] = "ssl_sbb^ssl_sbb.html^SSL plugin for Eldos SecureBlackBox^    <p>For handling keys and certificates you can use this properties: <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#CertCAFile\">CertCAFile</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#CertCA\">CertCA</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#TrustCertificateFile\">TrustCertificateFile</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#TrustCertificate\">TrustCertificate</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#PrivateKeyFile\">PrivateKeyFile</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#PrivateKey\">PrivateKey</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#CertificateFile\">CertificateFile</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Certificate\">Certificate</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#PFXfile\">PFXfile</a>. For usage of this properties and for possible formats of keys and certificates refer to SecureBlackBox documentation. ^0"
s[1309] = "ssl_sbb.TSSLSBB^ssl_sbb.TSSLSBB.html^class implementing SecureBlackbox SSL plugin.^ Instance of this class will be created for each <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>. You not need to create instance of this class, all is done by Synapse itself! ^0"
s[1310] = "ssl_sbb.TSSLSBB.Create^ssl_sbb.TSSLSBB.html#Create^^    ^0"
s[1311] = "ssl_sbb.TSSLSBB.Destroy^ssl_sbb.TSSLSBB.html#Destroy^^    ^0"
s[1312] = "ssl_sbb.TSSLSBB.LibVersion^ssl_sbb.TSSLSBB.html#LibVersion^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#LibVersion\">LibVersion</a>    ^0"
s[1313] = "ssl_sbb.TSSLSBB.LibName^ssl_sbb.TSSLSBB.html#LibName^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#LibName\">LibName</a>    ^0"
s[1314] = "ssl_sbb.TSSLSBB.Connect^ssl_sbb.TSSLSBB.html#Connect^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Connect\">Connect</a> and <a class=\"normal\" href=\"ssl_sbb.html\">ssl_sbb</a> for more details.    ^0"
s[1315] = "ssl_sbb.TSSLSBB.Accept^ssl_sbb.TSSLSBB.html#Accept^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Accept\">Accept</a> and <a class=\"normal\" href=\"ssl_sbb.html\">ssl_sbb</a> for more details.    ^0"
s[1316] = "ssl_sbb.TSSLSBB.Shutdown^ssl_sbb.TSSLSBB.html#Shutdown^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Shutdown\">Shutdown</a>    ^0"
s[1317] = "ssl_sbb.TSSLSBB.BiShutdown^ssl_sbb.TSSLSBB.html#BiShutdown^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#BiShutdown\">BiShutdown</a>    ^0"
s[1318] = "ssl_sbb.TSSLSBB.SendBuffer^ssl_sbb.TSSLSBB.html#SendBuffer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#SendBuffer\">SendBuffer</a>    ^0"
s[1319] = "ssl_sbb.TSSLSBB.RecvBuffer^ssl_sbb.TSSLSBB.html#RecvBuffer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#RecvBuffer\">RecvBuffer</a>    ^0"
s[1320] = "ssl_sbb.TSSLSBB.WaitingData^ssl_sbb.TSSLSBB.html#WaitingData^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#WaitingData\">WaitingData</a>    ^0"
s[1321] = "ssl_sbb.TSSLSBB.GetSSLVersion^ssl_sbb.TSSLSBB.html#GetSSLVersion^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetSSLVersion\">GetSSLVersion</a>    ^0"
s[1322] = "ssl_sbb.TSSLSBB.GetPeerSubject^ssl_sbb.TSSLSBB.html#GetPeerSubject^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerSubject\">GetPeerSubject</a>    ^0"
s[1323] = "ssl_sbb.TSSLSBB.GetPeerIssuer^ssl_sbb.TSSLSBB.html#GetPeerIssuer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerIssuer\">GetPeerIssuer</a>    ^0"
s[1324] = "ssl_sbb.TSSLSBB.GetPeerName^ssl_sbb.TSSLSBB.html#GetPeerName^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerName\">GetPeerName</a>    ^0"
s[1325] = "ssl_sbb.TSSLSBB.GetPeerFingerprint^ssl_sbb.TSSLSBB.html#GetPeerFingerprint^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerFingerprint\">GetPeerFingerprint</a>    ^0"
s[1326] = "ssl_sbb.TSSLSBB.GetCertInfo^ssl_sbb.TSSLSBB.html#GetCertInfo^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetCertInfo\">GetCertInfo</a>    ^0"
s[1327] = "ssl_sbb.TSSLSBB.ElSecureClient^ssl_sbb.TSSLSBB.html#ElSecureClient^^ ^0"
s[1328] = "ssl_sbb.TSSLSBB.ElSecureServer^ssl_sbb.TSSLSBB.html#ElSecureServer^^ ^0"
s[1329] = "ssl_sbb.TSSLSBB.CipherSuites^ssl_sbb.TSSLSBB.html#CipherSuites^^ ^0"
s[1330] = "ssl_sbb.TSSLSBB.CipherSuite^ssl_sbb.TSSLSBB.html#CipherSuite^^ ^0"
s[1331] = "ssl_sbb.DEFAULT_RECV_BUFFER^ssl_sbb.html#DEFAULT_RECV_BUFFER^^ ^0"
s[1332] = "ssl_streamsec^ssl_streamsec.html^SSL plugin for StreamSecII or OpenStreamSecII^    <p>StreamSecII is native pascal library, you not need any external libraries!    <p>You can tune lot of StreamSecII properties by using your GlobalServer. If you not using your GlobalServer, then this plugin create own TSimpleTLSInternalServer instance for each TCP connection. Formore information about GlobalServer usage refer StreamSecII documentation.    <p>If you are not using key and certificate by GlobalServer, then you can use properties of this plugin instead, but this have limited features and <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#KeyPassword\">KeyPassword</a> not working properly yet!    <p>For handling keys and certificates you can use this properties: <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#CertCAFile\">CertCAFile</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#CertCA\">CertCA</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#TrustCertificateFile\">TrustCertificateFile</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#TrustCertificate\">TrustCertificate</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#PrivateKeyFile\">PrivateKeyFile</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#PrivateKey\">PrivateKey</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#CertificateFile\">CertificateFile</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Certificate\">Certificate</a>, <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#PFXfile\">PFXfile</a>. For usage of this properties and for possible formats of keys and certificates refer to StreamSecII documentation. ^0"
s[1333] = "ssl_streamsec.TSSLStreamSec^ssl_streamsec.TSSLStreamSec.html^class implementing StreamSecII SSL plugin.^ Instance of this class will be created for each <a class=\"normal\" href=\"blcksock.TTCPBlockSocket.html\">TTCPBlockSocket</a>. You not need to create instance of this class, all is done by Synapse itself! ^0"
s[1334] = "ssl_streamsec.TSSLStreamSec.Create^ssl_streamsec.TSSLStreamSec.html#Create^^    ^0"
s[1335] = "ssl_streamsec.TSSLStreamSec.Destroy^ssl_streamsec.TSSLStreamSec.html#Destroy^^    ^0"
s[1336] = "ssl_streamsec.TSSLStreamSec.LibVersion^ssl_streamsec.TSSLStreamSec.html#LibVersion^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#LibVersion\">LibVersion</a>    ^0"
s[1337] = "ssl_streamsec.TSSLStreamSec.LibName^ssl_streamsec.TSSLStreamSec.html#LibName^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#LibName\">LibName</a>    ^0"
s[1338] = "ssl_streamsec.TSSLStreamSec.Connect^ssl_streamsec.TSSLStreamSec.html#Connect^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Connect\">Connect</a> and <a class=\"normal\" href=\"ssl_streamsec.html\">ssl_streamsec</a> for more details.    ^0"
s[1339] = "ssl_streamsec.TSSLStreamSec.Accept^ssl_streamsec.TSSLStreamSec.html#Accept^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Accept\">Accept</a> and <a class=\"normal\" href=\"ssl_streamsec.html\">ssl_streamsec</a> for more details.    ^0"
s[1340] = "ssl_streamsec.TSSLStreamSec.Shutdown^ssl_streamsec.TSSLStreamSec.html#Shutdown^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#Shutdown\">Shutdown</a>    ^0"
s[1341] = "ssl_streamsec.TSSLStreamSec.BiShutdown^ssl_streamsec.TSSLStreamSec.html#BiShutdown^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#BiShutdown\">BiShutdown</a>    ^0"
s[1342] = "ssl_streamsec.TSSLStreamSec.SendBuffer^ssl_streamsec.TSSLStreamSec.html#SendBuffer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#SendBuffer\">SendBuffer</a>    ^0"
s[1343] = "ssl_streamsec.TSSLStreamSec.RecvBuffer^ssl_streamsec.TSSLStreamSec.html#RecvBuffer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#RecvBuffer\">RecvBuffer</a>    ^0"
s[1344] = "ssl_streamsec.TSSLStreamSec.WaitingData^ssl_streamsec.TSSLStreamSec.html#WaitingData^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#WaitingData\">WaitingData</a>    ^0"
s[1345] = "ssl_streamsec.TSSLStreamSec.GetSSLVersion^ssl_streamsec.TSSLStreamSec.html#GetSSLVersion^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetSSLVersion\">GetSSLVersion</a>    ^0"
s[1346] = "ssl_streamsec.TSSLStreamSec.GetPeerSubject^ssl_streamsec.TSSLStreamSec.html#GetPeerSubject^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerSubject\">GetPeerSubject</a>    ^0"
s[1347] = "ssl_streamsec.TSSLStreamSec.GetPeerIssuer^ssl_streamsec.TSSLStreamSec.html#GetPeerIssuer^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerIssuer\">GetPeerIssuer</a>    ^0"
s[1348] = "ssl_streamsec.TSSLStreamSec.GetPeerName^ssl_streamsec.TSSLStreamSec.html#GetPeerName^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerName\">GetPeerName</a>    ^0"
s[1349] = "ssl_streamsec.TSSLStreamSec.GetPeerFingerprint^ssl_streamsec.TSSLStreamSec.html#GetPeerFingerprint^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetPeerFingerprint\">GetPeerFingerprint</a>    ^0"
s[1350] = "ssl_streamsec.TSSLStreamSec.GetCertInfo^ssl_streamsec.TSSLStreamSec.html#GetCertInfo^^See <a class=\"normal\" href=\"blcksock.TCustomSSL.html\">TCustomSSL</a>.<a class=\"normal\" href=\"blcksock.TCustomSSL.html#GetCertInfo\">GetCertInfo</a>    ^0"
s[1351] = "ssl_streamsec.TSSLStreamSec.TLSServer^ssl_streamsec.TSSLStreamSec.html#TLSServer^^TLS server for tuning of StreamSecII. ^0"
s[1352] = "synachar^synachar.html^Charset conversion support^ This unit contains a routines for lot of charset conversions.    <p>It using built-in conversion tables or external Iconv library. Iconv is used when needed conversion is known by Iconv library. When Iconv library is not found or Iconv not know requested conversion, then are internal routines used for conversion. (You can disable Iconv support from your program too!)    <p>Internal routines knows all major charsets for Europe or America. For East-Asian charsets you must use Iconv library! ^0"
s[1353] = "synachar.IconvOnlyChars^synachar.html#IconvOnlyChars^^Set of charsets supported by Iconv library only. ^0"
s[1354] = "synachar.NoIconvChars^synachar.html#NoIconvChars^^Set of charsets supported by internal routines only. ^0"
s[1355] = "synachar.Replace_None^synachar.html#Replace_None^^null character replace table. (Usable for disable charater replacing.) ^0"
s[1356] = "synachar.Replace_Czech^synachar.html#Replace_Czech^^Character replace table for remove Czech diakritics. ^0"
s[1357] = "synachar.CharsetConversion^synachar.html#CharsetConversion^^Convert Value from one charset to another. See: <a class=\"normal\" href=\"synachar.html#CharsetConversionEx\">CharsetConversionEx</a>    ^0"
s[1358] = "synachar.CharsetConversionEx^synachar.html#CharsetConversionEx^^Convert Value from one charset to another with additional character conversion. see: <a class=\"normal\" href=\"synachar.html#Replace_None\">Replace_None</a> and <a class=\"normal\" href=\"synachar.html#Replace_Czech\">Replace_Czech</a>    ^0"
s[1359] = "synachar.CharsetConversionTrans^synachar.html#CharsetConversionTrans^^Convert Value from one charset to another with additional character conversion. This funtion is similar to <a class=\"normal\" href=\"synachar.html#CharsetConversionEx\">CharsetConversionEx</a>, but you can disable transliteration of unconvertible characters.    ^0"
s[1360] = "synachar.GetCurCP^synachar.html#GetCurCP^^Returns charset used by operating system.    ^0"
s[1361] = "synachar.GetCurOEMCP^synachar.html#GetCurOEMCP^^Returns charset used by operating system as OEM charset. (in Windows DOS box, for example)    ^0"
s[1362] = "synachar.GetCPFromID^synachar.html#GetCPFromID^^Converting string with charset name to TMimeChar.    ^0"
s[1363] = "synachar.GetIDFromCP^synachar.html#GetIDFromCP^^Converting TMimeChar to string with name of charset.    ^0"
s[1364] = "synachar.NeedCharsetConversion^synachar.html#NeedCharsetConversion^^return <code>True</code> when value need to be converted. (It is not 7-bit ASCII)    ^0"
s[1365] = "synachar.IdealCharsetCoding^synachar.html#IdealCharsetCoding^^Finding best target charset from set of TMimeChars with minimal count of unconvertible characters.    ^0"
s[1366] = "synachar.GetBOM^synachar.html#GetBOM^^Return BOM (Byte Order Mark) for given unicode charset.    ^0"
s[1367] = "synachar.StringToWide^synachar.html#StringToWide^^Convert binary string with unicode content to WideString.    ^0"
s[1368] = "synachar.WideToString^synachar.html#WideToString^^Convert WideString to binary string with unicode content.    ^0"
s[1369] = "synachar.TMimeChar^synachar.html#TMimeChar^^Type with all supported charsets.  ISO_8859_1    ISO_8859_2    ISO_8859_3    ISO_8859_4    ISO_8859_5    ISO_8859_6    ISO_8859_7    ISO_8859_8    ISO_8859_9    ISO_8859_10    ISO_8859_13    ISO_8859_14    ISO_8859_15    CP1250    CP1251    CP1252    CP1253    CP1254    CP1255    CP1256    CP1257    CP1258    KOI8_R    CP895    CP852    UCS_2    UCS_4    UTF_8    UTF_7    UTF_7mod    UCS_2LE    UCS_4LE    UTF_16    UTF_16LE    UTF_32    UTF_32LE    C99    JAVA    ISO_8859_16    KOI8_U    KOI8_RU    CP862    CP866    MAC    MACCE    MACICE    MACCRO    MACRO    MACCYR    MACUK    MACGR    MACTU    MACHEB    MACAR    MACTH    ROMAN8    NEXTSTEP    ARMASCII    GEORGIAN_AC    GEORGIAN_PS    KOI8_T    MULELAO    CP1133    TIS620    CP874    VISCII    TCVN    ISO_IR_14    JIS_X0201    JIS_X0208    JIS_X0212    GB1988_80    GB2312_80    ISO_IR_165    ISO_IR_149    EUC_JP    SHIFT_JIS    CP932    ISO_2022_JP    ISO_2022_JP1    ISO_2022_JP2    GB2312    CP936    GB18030    ISO_2022_CN    ISO_2022_CNE    HZ    EUC_TW    BIG5    CP950    BIG5_HKSCS    EUC_KR    CP949    CP1361    ISO_2022_KR    CP737    CP775    CP853    CP855    CP857    CP858    CP860    CP861    CP863    CP864    CP865    CP869    CP1125   ^0"
s[1370] = "synachar.TMimeSetChar^synachar.html#TMimeSetChar^^Set of any charsets. ^0"
s[1371] = "synachar.DisableIconv^synachar.html#DisableIconv^^By this you can generally disable/enable Iconv support. ^0"
s[1372] = "synachar.IdealCharsets^synachar.html#IdealCharsets^^Default set of charsets for <a class=\"normal\" href=\"synachar.html#IdealCharsetCoding\">IdealCharsetCoding</a> function. ^0"
s[1373] = "synacode^synacode.html^Various encoding and decoding support^ ^0"
s[1374] = "synacode.SpecialChar^synacode.html#SpecialChar^^ ^0"
s[1375] = "synacode.NonAsciiChar^synacode.html#NonAsciiChar^^ ^0"
s[1376] = "synacode.URLFullSpecialChar^synacode.html#URLFullSpecialChar^^ ^0"
s[1377] = "synacode.URLSpecialChar^synacode.html#URLSpecialChar^^ ^0"
s[1378] = "synacode.TableBase64^synacode.html#TableBase64^^ ^0"
s[1379] = "synacode.TableBase64mod^synacode.html#TableBase64mod^^ ^0"
s[1380] = "synacode.TableUU^synacode.html#TableUU^^ ^0"
s[1381] = "synacode.TableXX^synacode.html#TableXX^^ ^0"
s[1382] = "synacode.ReTablebase64^synacode.html#ReTablebase64^^ ^0"
s[1383] = "synacode.ReTableUU^synacode.html#ReTableUU^^ ^0"
s[1384] = "synacode.ReTableXX^synacode.html#ReTableXX^^ ^0"
s[1385] = "synacode.DecodeTriplet^synacode.html#DecodeTriplet^^Decodes triplet encoding with a given character delimiter. It is used for decoding quoted-printable or URL encoding.    ^0"
s[1386] = "synacode.DecodeQuotedPrintable^synacode.html#DecodeQuotedPrintable^^Decodes a string from quoted printable form. (also decodes triplet sequences like '=7F')    ^0"
s[1387] = "synacode.DecodeURL^synacode.html#DecodeURL^^Decodes a string of URL encoding. (also decodes triplet sequences like '%7F')    ^0"
s[1388] = "synacode.EncodeTriplet^synacode.html#EncodeTriplet^^Performs triplet encoding with a given character delimiter. Used for encoding quoted-printable or URL encoding.    ^0"
s[1389] = "synacode.EncodeQuotedPrintable^synacode.html#EncodeQuotedPrintable^^Encodes a string to triplet quoted printable form. All <a class=\"normal\" href=\"synacode.html#NonAsciiChar\">NonAsciiChar</a> are encoded.    ^0"
s[1390] = "synacode.EncodeSafeQuotedPrintable^synacode.html#EncodeSafeQuotedPrintable^^Encodes a string to triplet quoted printable form. All <a class=\"normal\" href=\"synacode.html#NonAsciiChar\">NonAsciiChar</a> and <a class=\"normal\" href=\"synacode.html#SpecialChar\">SpecialChar</a> are encoded.    ^0"
s[1391] = "synacode.EncodeURLElement^synacode.html#EncodeURLElement^^Encodes a string to URL format. Used for encoding data from a form field in HTTP, etc. (Encodes all critical characters including characters used as URL delimiters ('/',':', etc.)    ^0"
s[1392] = "synacode.EncodeURL^synacode.html#EncodeURL^^Encodes a string to URL format. Used to encode critical characters in all URLs.    ^0"
s[1393] = "synacode.Decode4to3^synacode.html#Decode4to3^^Decode 4to3 encoding with given table. If some element is not found in table, first item from table is used. This is good for buggy coded items by Microsoft Outlook. This software sometimes using wrong table for UUcode, where is used ' ' instead '`'.    ^0"
s[1394] = "synacode.Decode4to3Ex^synacode.html#Decode4to3Ex^^Decode 4to3 encoding with given REVERSE table. Using this function with reverse table is much faster then <a class=\"normal\" href=\"synacode.html#Decode4to3\">Decode4to3</a>. This function is used internally for Base64, UU or XX decoding.    ^0"
s[1395] = "synacode.Encode3to4^synacode.html#Encode3to4^^Encode by system 3to4 (used by Base64, UU coding, etc) by given table.    ^0"
s[1396] = "synacode.DecodeBase64^synacode.html#DecodeBase64^^Decode string from base64 format.    ^0"
s[1397] = "synacode.EncodeBase64^synacode.html#EncodeBase64^^Encodes a string to base64 format.    ^0"
s[1398] = "synacode.DecodeBase64mod^synacode.html#DecodeBase64mod^^Decode string from modified base64 format. (used in IMAP, for example.)    ^0"
s[1399] = "synacode.EncodeBase64mod^synacode.html#EncodeBase64mod^^Encodes a string to modified base64 format. (used in IMAP, for example.)    ^0"
s[1400] = "synacode.DecodeUU^synacode.html#DecodeUU^^Decodes a string from UUcode format.    ^0"
s[1401] = "synacode.EncodeUU^synacode.html#EncodeUU^^encode UUcode. it encode only datas, you must also add header and footer for proper encode.    ^0"
s[1402] = "synacode.DecodeXX^synacode.html#DecodeXX^^Decodes a string from XXcode format.    ^0"
s[1403] = "synacode.DecodeYEnc^synacode.html#DecodeYEnc^^decode line with Yenc code. This code is sometimes used in newsgroups.    ^0"
s[1404] = "synacode.UpdateCrc32^synacode.html#UpdateCrc32^^Returns a new CRC32 value after adding a new byte of data.    ^0"
s[1405] = "synacode.Crc32^synacode.html#Crc32^^return CRC32 from a value string.    ^0"
s[1406] = "synacode.UpdateCrc16^synacode.html#UpdateCrc16^^Returns a new CRC16 value after adding a new byte of data.    ^0"
s[1407] = "synacode.Crc16^synacode.html#Crc16^^return CRC16 from a value string.    ^0"
s[1408] = "synacode.MD5^synacode.html#MD5^^Returns a binary string with a RSA-MD5 hashing of &quot;Value&quot; string.    ^0"
s[1409] = "synacode.HMAC_MD5^synacode.html#HMAC_MD5^^Returns a binary string with HMAC-MD5 hash.    ^0"
s[1410] = "synacode.MD5LongHash^synacode.html#MD5LongHash^^Returns a binary string with a RSA-MD5 hashing of string what is constructed by repeating &quot;value&quot; until length is &quot;Len&quot;.    ^0"
s[1411] = "synacode.SHA1^synacode.html#SHA1^^Returns a binary string with a SHA-1 hashing of &quot;Value&quot; string.    ^0"
s[1412] = "synacode.HMAC_SHA1^synacode.html#HMAC_SHA1^^Returns a binary string with HMAC-SHA1 hash.    ^0"
s[1413] = "synacode.SHA1LongHash^synacode.html#SHA1LongHash^^Returns a binary string with a SHA-1 hashing of string what is constructed by repeating &quot;value&quot; until length is &quot;Len&quot;.    ^0"
s[1414] = "synacode.MD4^synacode.html#MD4^^Returns a binary string with a RSA-MD4 hashing of &quot;Value&quot; string.    ^0"
s[1415] = "synacode.TSpecials^synacode.html#TSpecials^^ ^0"
s[1416] = "synacrypt^synacrypt.html^Encryption support^    <p>Implemented are DES and 3DES encryption/decryption by ECB, CBC, CFB-8bit, CFB-block, OFB and CTR methods. ^0"
s[1417] = "synacrypt.TSynaBlockCipher^synacrypt.TSynaBlockCipher.html^Implementation of common routines block ciphers (dafault size is 64-bits)^    <p>Do not use this class directly, use descendants only! ^0"
s[1418] = "synacrypt.TSynaBlockCipher.SetIV^synacrypt.TSynaBlockCipher.html#SetIV^^Sets the IV to Value and performs a reset    ^0"
s[1419] = "synacrypt.TSynaBlockCipher.GetIV^synacrypt.TSynaBlockCipher.html#GetIV^^Returns the current chaining information, not the actual IV    ^0"
s[1420] = "synacrypt.TSynaBlockCipher.Reset^synacrypt.TSynaBlockCipher.html#Reset^^Reset any stored chaining information    ^0"
s[1421] = "synacrypt.TSynaBlockCipher.EncryptECB^synacrypt.TSynaBlockCipher.html#EncryptECB^^Encrypt a 64-bit block of data using the ECB method of encryption    ^0"
s[1422] = "synacrypt.TSynaBlockCipher.DecryptECB^synacrypt.TSynaBlockCipher.html#DecryptECB^^Decrypt a 64-bit block of data using the ECB method of decryption    ^0"
s[1423] = "synacrypt.TSynaBlockCipher.EncryptCBC^synacrypt.TSynaBlockCipher.html#EncryptCBC^^Encrypt data using the CBC method of encryption    ^0"
s[1424] = "synacrypt.TSynaBlockCipher.DecryptCBC^synacrypt.TSynaBlockCipher.html#DecryptCBC^^Decrypt data using the CBC method of decryption    ^0"
s[1425] = "synacrypt.TSynaBlockCipher.EncryptCFB8bit^synacrypt.TSynaBlockCipher.html#EncryptCFB8bit^^Encrypt data using the CFB (8 bit) method of encryption    ^0"
s[1426] = "synacrypt.TSynaBlockCipher.DecryptCFB8bit^synacrypt.TSynaBlockCipher.html#DecryptCFB8bit^^Decrypt data using the CFB (8 bit) method of decryption    ^0"
s[1427] = "synacrypt.TSynaBlockCipher.EncryptCFBblock^synacrypt.TSynaBlockCipher.html#EncryptCFBblock^^Encrypt data using the CFB (block) method of encryption    ^0"
s[1428] = "synacrypt.TSynaBlockCipher.DecryptCFBblock^synacrypt.TSynaBlockCipher.html#DecryptCFBblock^^Decrypt data using the CFB (block) method of decryption    ^0"
s[1429] = "synacrypt.TSynaBlockCipher.EncryptOFB^synacrypt.TSynaBlockCipher.html#EncryptOFB^^Encrypt data using the OFB method of encryption    ^0"
s[1430] = "synacrypt.TSynaBlockCipher.DecryptOFB^synacrypt.TSynaBlockCipher.html#DecryptOFB^^Decrypt data using the OFB method of decryption    ^0"
s[1431] = "synacrypt.TSynaBlockCipher.EncryptCTR^synacrypt.TSynaBlockCipher.html#EncryptCTR^^Encrypt data using the CTR method of encryption    ^0"
s[1432] = "synacrypt.TSynaBlockCipher.DecryptCTR^synacrypt.TSynaBlockCipher.html#DecryptCTR^^Decrypt data using the CTR method of decryption    ^0"
s[1433] = "synacrypt.TSynaBlockCipher.Create^synacrypt.TSynaBlockCipher.html#Create^^Create a encryptor/decryptor instance and initialize it by the Key.    ^0"
s[1434] = "synacrypt.TSynaCustomDes^synacrypt.TSynaCustomDes.html^Implementation of common routines for DES encryption^    <p>Do not use this class directly, use descendants only! ^0"
s[1435] = "synacrypt.TSynaDes^synacrypt.TSynaDes.html^Implementation of DES encryption^ ^0"
s[1436] = "synacrypt.TSynaDes.EncryptECB^synacrypt.TSynaDes.html#EncryptECB^^Encrypt a 64-bit block of data using the ECB method of encryption    ^0"
s[1437] = "synacrypt.TSynaDes.DecryptECB^synacrypt.TSynaDes.html#DecryptECB^^Decrypt a 64-bit block of data using the ECB method of decryption    ^0"
s[1438] = "synacrypt.TSyna3Des^synacrypt.TSyna3Des.html^Implementation of 3DES encryption^ ^0"
s[1439] = "synacrypt.TSyna3Des.EncryptECB^synacrypt.TSyna3Des.html#EncryptECB^^Encrypt a 64-bit block of data using the ECB method of encryption    ^0"
s[1440] = "synacrypt.TSyna3Des.DecryptECB^synacrypt.TSyna3Des.html#DecryptECB^^Decrypt a 64-bit block of data using the ECB method of decryption    ^0"
s[1441] = "synacrypt.TSynaAes^synacrypt.TSynaAes.html^Implementation of AES encryption^ ^0"
s[1442] = "synacrypt.TSynaAes.EncryptECB^synacrypt.TSynaAes.html#EncryptECB^^Encrypt a 128-bit block of data using the ECB method of encryption    ^0"
s[1443] = "synacrypt.TSynaAes.DecryptECB^synacrypt.TSynaAes.html#DecryptECB^^Decrypt a 128-bit block of data using the ECB method of decryption    ^0"
s[1444] = "synacrypt.BC^synacrypt.html#BC^^ ^0"
s[1445] = "synacrypt.MAXROUNDS^synacrypt.html#MAXROUNDS^^ ^0"
s[1446] = "synacrypt.TestDes^synacrypt.html#TestDes^^Call internal test of all DES encryptions. Returns <code>True</code> if all is OK.    ^0"
s[1447] = "synacrypt.Test3Des^synacrypt.html#Test3Des^^Call internal test of all 3DES encryptions. Returns <code>True</code> if all is OK.    ^0"
s[1448] = "synacrypt.TestAes^synacrypt.html#TestAes^^Call internal test of all AES encryptions. Returns <code>True</code> if all is OK.    ^0"
s[1449] = "synacrypt.TDesKeyData^synacrypt.html#TDesKeyData^Datatype for holding one DES key data^    <p>This data type is used internally. ^0"
s[1450] = "synadbg^synadbg.html^Socket debug tools^    <p>Routines for help with debugging of events on the Sockets. ^0"
s[1451] = "synadbg.TSynaDebug^synadbg.TSynaDebug.html^^ ^0"
s[1452] = "synadbg.TSynaDebug.HookStatus^synadbg.TSynaDebug.html#HookStatus^^    ^0"
s[1453] = "synadbg.TSynaDebug.HookMonitor^synadbg.TSynaDebug.html#HookMonitor^^    ^0"
s[1454] = "synadbg.AppendToLog^synadbg.html#AppendToLog^^    ^0"
s[1455] = "synadbg.LogFile^synadbg.html#LogFile^^ ^0"
s[1456] = "synafpc^synafpc.html^^ ^0"
s[1457] = "synafpc.Sleep^synafpc.html#Sleep^^    ^0"
s[1458] = "synafpc.TLibHandle^synafpc.html#TLibHandle^^ ^0"
s[1459] = "synafpc.PtrInt^synafpc.html#PtrInt^^ ^0"
s[1460] = "synaicnv^synaicnv.html^LibIconv support^    <p>This unit is Pascal interface to LibIconv library for charset translations. LibIconv is loaded dynamicly on-demand. If this library is not found in system, requested LibIconv function just return errorcode. ^0"
s[1461] = "synaicnv.DLLIconvName^synaicnv.html#DLLIconvName^^ ^0"
s[1462] = "synaicnv.ICONV_TRIVIALP^synaicnv.html#ICONV_TRIVIALP^^ ^0"
s[1463] = "synaicnv.ICONV_GET_TRANSLITERATE^synaicnv.html#ICONV_GET_TRANSLITERATE^^ ^0"
s[1464] = "synaicnv.ICONV_SET_TRANSLITERATE^synaicnv.html#ICONV_SET_TRANSLITERATE^^ ^0"
s[1465] = "synaicnv.ICONV_GET_DISCARD_ILSEQ^synaicnv.html#ICONV_GET_DISCARD_ILSEQ^^ ^0"
s[1466] = "synaicnv.ICONV_SET_DISCARD_ILSEQ^synaicnv.html#ICONV_SET_DISCARD_ILSEQ^^ ^0"
s[1467] = "synaicnv.SynaIconvOpen^synaicnv.html#SynaIconvOpen^^    ^0"
s[1468] = "synaicnv.SynaIconvOpenTranslit^synaicnv.html#SynaIconvOpenTranslit^^    ^0"
s[1469] = "synaicnv.SynaIconvOpenIgnore^synaicnv.html#SynaIconvOpenIgnore^^    ^0"
s[1470] = "synaicnv.SynaIconv^synaicnv.html#SynaIconv^^    ^0"
s[1471] = "synaicnv.SynaIconvClose^synaicnv.html#SynaIconvClose^^    ^0"
s[1472] = "synaicnv.SynaIconvCtl^synaicnv.html#SynaIconvCtl^^    ^0"
s[1473] = "synaicnv.IsIconvloaded^synaicnv.html#IsIconvloaded^^    ^0"
s[1474] = "synaicnv.InitIconvInterface^synaicnv.html#InitIconvInterface^^    ^0"
s[1475] = "synaicnv.DestroyIconvInterface^synaicnv.html#DestroyIconvInterface^^    ^0"
s[1476] = "synaicnv.size_t^synaicnv.html#size_t^^ ^0"
s[1477] = "synaicnv.iconv_t^synaicnv.html#iconv_t^^ ^0"
s[1478] = "synaicnv.argptr^synaicnv.html#argptr^^ ^0"
s[1479] = "synaicnv.iconvLibHandle^synaicnv.html#iconvLibHandle^^ ^0"
s[1480] = "synaip^synaip.html^IP adress support procedures and functions^ ^0"
s[1481] = "synaip.IsIP^synaip.html#IsIP^^Returns <code>True</code>, if &quot;Value&quot; is a valid IPv4 address. Cannot be a symbolic Name!    ^0"
s[1482] = "synaip.IsIP6^synaip.html#IsIP6^^Returns <code>True</code>, if &quot;Value&quot; is a valid IPv6 address. Cannot be a symbolic Name!    ^0"
s[1483] = "synaip.IPToID^synaip.html#IPToID^^Returns a string with the &quot;Host&quot; ip address converted to binary form.    ^0"
s[1484] = "synaip.StrToIp6^synaip.html#StrToIp6^^Convert IPv6 address from their string form to binary byte array.    ^0"
s[1485] = "synaip.Ip6ToStr^synaip.html#Ip6ToStr^^Convert IPv6 address from binary byte array to string form.    ^0"
s[1486] = "synaip.StrToIp^synaip.html#StrToIp^^Convert IPv4 address from their string form to binary.    ^0"
s[1487] = "synaip.IpToStr^synaip.html#IpToStr^^Convert IPv4 address from binary to string form.    ^0"
s[1488] = "synaip.ReverseIP^synaip.html#ReverseIP^^Convert IPv4 address to reverse form.    ^0"
s[1489] = "synaip.ReverseIP6^synaip.html#ReverseIP6^^Convert IPv6 address to reverse form.    ^0"
s[1490] = "synaip.ExpandIP6^synaip.html#ExpandIP6^^Expand short form of IPv6 address to long form.    ^0"
s[1491] = "synaip.TIp6Bytes^synaip.html#TIp6Bytes^^binary form of IPv6 adress (for string conversion routines) ^0"
s[1492] = "synaip.TIp6Words^synaip.html#TIp6Words^^binary form of IPv6 adress (for string conversion routines) ^0"
s[1493] = "synamisc^synamisc.html^^ ^0"
s[1494] = "synamisc.TProxySetting^synamisc.TProxySetting.html^This record contains information about proxy setting.^ ^0"
s[1495] = "synamisc.TProxySetting.Host^synamisc.TProxySetting.html#Host^^ ^0"
s[1496] = "synamisc.TProxySetting.Port^synamisc.TProxySetting.html#Port^^ ^0"
s[1497] = "synamisc.TProxySetting.Bypass^synamisc.TProxySetting.html#Bypass^^ ^0"
s[1498] = "synamisc.WakeOnLan^synamisc.html#WakeOnLan^^By this function you can turn-on computer on network, if this computer supporting Wake-on-lan feature. You need MAC number (network card indentifier) of computer for turn-on. You can also assign target IP addres. If you not specify it, then is used broadcast for delivery magic wake-on packet. However broadcasts workinh only on your local network. When you need to wake-up computer on another network, you must specify any existing IP addres on same network segment as targeting computer.    ^0"
s[1499] = "synamisc.GetDNS^synamisc.html#GetDNS^^Autodetect current DNS servers used by system. If is defined more then one DNS server, then result is comma-delimited.    ^0"
s[1500] = "synamisc.GetIEProxy^synamisc.html#GetIEProxy^^Autodetect InternetExplorer proxy setting for given protocol. This function working only on windows!    ^0"
s[1501] = "synamisc.GetLocalIPs^synamisc.html#GetLocalIPs^^Return all known IP addresses on local system. Addresses are divided by comma.    ^0"
s[1502] = "synaser^synaser.html^^ ^0"
s[1503] = "synaser.ESynaSerError^synaser.ESynaSerError.html^Exception type for SynaSer errors^ ^0"
s[1504] = "synaser.ESynaSerError.ErrorCode^synaser.ESynaSerError.html#ErrorCode^^ ^0"
s[1505] = "synaser.ESynaSerError.ErrorMessage^synaser.ESynaSerError.html#ErrorMessage^^ ^0"
s[1506] = "synaser.TBlockSerial^synaser.TBlockSerial.html^Main class implementing all communication routines^ ^0"
s[1507] = "synaser.TBlockSerial.DCB^synaser.TBlockSerial.html#DCB^^data Control Block with communication parameters. Usable only when you need to call API directly. ^0"
s[1508] = "synaser.TBlockSerial.Create^synaser.TBlockSerial.html#Create^^Object constructor.    ^0"
s[1509] = "synaser.TBlockSerial.Destroy^synaser.TBlockSerial.html#Destroy^^Object destructor.    ^0"
s[1510] = "synaser.TBlockSerial.GetVersion^synaser.TBlockSerial.html#GetVersion^^Returns a string containing the version number of the library.    ^0"
s[1511] = "synaser.TBlockSerial.CloseSocket^synaser.TBlockSerial.html#CloseSocket^^Destroy handle in use. It close connection to serial port.    ^0"
s[1512] = "synaser.TBlockSerial.Config^synaser.TBlockSerial.html#Config^^Reconfigure communication parameters on the fly. You must be connected to port before!        baud Define connection speed. Baud rate can be from 50 to 4000000 bits per second. (it depends on your hardware!) bits Number of bits in communication. parity Define communication parity (N - None, O - Odd, E - Even, M - Mark or S - Space). stop Define number of stopbits. Use constants <a class=\"normal\" href=\"synaser.html#SB1\">SB1</a>, <a class=\"normal\" href=\"synaser.html#SB1andHalf\">SB1andHalf</a> and <a class=\"normal\" href=\"synaser.html#SB2\">SB2</a>. softflow Enable XON/XOFF handshake. hardflow Enable CTS/RTS handshake.  ^0"
s[1513] = "synaser.TBlockSerial.Connect^synaser.TBlockSerial.html#Connect^^Connects to the port indicated by comport. Comport can be used in Windows style (COM2), or in Linux style (/dev/ttyS1). When you use windows style in Linux, then it will be converted to Linux name. And vice versa! However you can specify any device name! (other device names then standart is not converted!)    <p>After successfull connection the DTR signal is set (if you not set hardware handshake, then the RTS signal is set, too!)    <p>Connection parameters is predefined by your system configuration. If you need use another parameters, then you can use Config method after. Notes:    <p>- Remember, the commonly used serial Laplink cable does not support hardware handshake.    <p>- Before setting any handshake you must be sure that it is supported by your hardware.    <p>- Some serial devices are slow. In some cases you must wait up to a few seconds after connection for the device to respond.    <p>- when you connect to a modem device, then is best to test it by an empty AT command. (call ATCommand('AT'))    ^0"
s[1514] = "synaser.TBlockSerial.SetCommState^synaser.TBlockSerial.html#SetCommState^^Set communication parameters from the DCB structure (the DCB structure is simulated under Linux).    ^0"
s[1515] = "synaser.TBlockSerial.GetCommState^synaser.TBlockSerial.html#GetCommState^^Read communication parameters into the DCB structure (DCB structure is simulated under Linux).    ^0"
s[1516] = "synaser.TBlockSerial.SendBuffer^synaser.TBlockSerial.html#SendBuffer^^Sends Length bytes of data from Buffer through the connected port.    ^0"
s[1517] = "synaser.TBlockSerial.SendByte^synaser.TBlockSerial.html#SendByte^^One data BYTE is sent.    ^0"
s[1518] = "synaser.TBlockSerial.SendString^synaser.TBlockSerial.html#SendString^^Send the string in the data parameter. No terminator is appended by this method. If you need to send a string with CR/LF terminator, you must append the CR/LF characters to the data string!    <p>Since no terminator is appended, you can use this function for sending binary data too.    ^0"
s[1519] = "synaser.TBlockSerial.SendInteger^synaser.TBlockSerial.html#SendInteger^^send four bytes as integer.    ^0"
s[1520] = "synaser.TBlockSerial.SendBlock^synaser.TBlockSerial.html#SendBlock^^send data as one block. Each block begins with integer value with Length of block.    ^0"
s[1521] = "synaser.TBlockSerial.SendStreamRaw^synaser.TBlockSerial.html#SendStreamRaw^^send content of stream from current position    ^0"
s[1522] = "synaser.TBlockSerial.SendStream^synaser.TBlockSerial.html#SendStream^^send content of stream as block. see <a class=\"normal\" href=\"synaser.TBlockSerial.html#SendBlock\">SendBlock</a>    ^0"
s[1523] = "synaser.TBlockSerial.SendStreamIndy^synaser.TBlockSerial.html#SendStreamIndy^^send content of stream as block, but this is compatioble with Indy library. (it have swapped lenght of block). See <a class=\"normal\" href=\"synaser.TBlockSerial.html#SendStream\">SendStream</a>    ^0"
s[1524] = "synaser.TBlockSerial.RecvBuffer^synaser.TBlockSerial.html#RecvBuffer^^Waits until the allocated buffer is filled by received data. Returns number of data bytes received, which equals to the Length value under normal operation. If it is not equal, the communication channel is possibly broken.    <p>This method not using any internal buffering, like all others receiving methods. You cannot freely combine this method with all others receiving methods!    ^0"
s[1525] = "synaser.TBlockSerial.RecvBufferEx^synaser.TBlockSerial.html#RecvBufferEx^^Method waits until data is received. If no data is received within the Timeout (in milliseconds) period, <a class=\"normal\" href=\"synaser.TBlockSerial.html#LastError\">LastError</a> is set to <a class=\"normal\" href=\"synaser.html#ErrTimeout\">ErrTimeout</a>. This method is used to read any amount of data (e. g. 1MB), and may be freely combined with all receviving methods what have Timeout parameter, like the <a class=\"normal\" href=\"synaser.TBlockSerial.html#Recvstring\">Recvstring</a>, <a class=\"normal\" href=\"synaser.TBlockSerial.html#RecvByte\">RecvByte</a> or <a class=\"normal\" href=\"synaser.TBlockSerial.html#RecvTerminated\">RecvTerminated</a> methods.    ^0"
s[1526] = "synaser.TBlockSerial.RecvBufferStr^synaser.TBlockSerial.html#RecvBufferStr^^It is like recvBufferEx, but data is readed to dynamicly allocated binary string.    ^0"
s[1527] = "synaser.TBlockSerial.RecvPacket^synaser.TBlockSerial.html#RecvPacket^^Read all available data and return it in the function result string. This function may be combined with <a class=\"normal\" href=\"synaser.TBlockSerial.html#Recvstring\">Recvstring</a>, <a class=\"normal\" href=\"synaser.TBlockSerial.html#RecvByte\">RecvByte</a> or related methods.    ^0"
s[1528] = "synaser.TBlockSerial.RecvByte^synaser.TBlockSerial.html#RecvByte^^Waits until one data byte is received which is returned as the function result. If no data is received within the Timeout (in milliseconds) period, <a class=\"normal\" href=\"synaser.TBlockSerial.html#LastError\">LastError</a> is set to <a class=\"normal\" href=\"synaser.html#ErrTimeout\">ErrTimeout</a>.    ^0"
s[1529] = "synaser.TBlockSerial.RecvTerminated^synaser.TBlockSerial.html#RecvTerminated^^This method waits until a terminated data string is received. This string is terminated by the Terminator string. The resulting string is returned without this termination string! If no data is received within the Timeout (in milliseconds) period, <a class=\"normal\" href=\"synaser.TBlockSerial.html#LastError\">LastError</a> is set to <a class=\"normal\" href=\"synaser.html#ErrTimeout\">ErrTimeout</a>.    ^0"
s[1530] = "synaser.TBlockSerial.Recvstring^synaser.TBlockSerial.html#Recvstring^^This method waits until a terminated data string is received. The string is terminated by a CR/LF sequence. The resulting string is returned without the terminator (CR/LF)! If no data is received within the Timeout (in milliseconds) period, <a class=\"normal\" href=\"synaser.TBlockSerial.html#LastError\">LastError</a> is set to <a class=\"normal\" href=\"synaser.html#ErrTimeout\">ErrTimeout</a>.    <p>If <a class=\"normal\" href=\"synaser.TBlockSerial.html#ConvertLineEnd\">ConvertLineEnd</a> is used, then the CR/LF sequence may not be exactly CR/LF. See the description of <a class=\"normal\" href=\"synaser.TBlockSerial.html#ConvertLineEnd\">ConvertLineEnd</a>.    <p>This method serves for line protocol implementation and uses its own buffers to maximize performance. Therefore do NOT use this method with the <a class=\"normal\" href=\"synaser.TBlockSerial.html#RecvBuffer\">RecvBuffer</a> method to receive data as it may cause data loss.    ^0"
s[1531] = "synaser.TBlockSerial.RecvInteger^synaser.TBlockSerial.html#RecvInteger^^Waits until four data bytes are received which is returned as the function integer result. If no data is received within the Timeout (in milliseconds) period, <a class=\"normal\" href=\"synaser.TBlockSerial.html#LastError\">LastError</a> is set to <a class=\"normal\" href=\"synaser.html#ErrTimeout\">ErrTimeout</a>.    ^0"
s[1532] = "synaser.TBlockSerial.RecvBlock^synaser.TBlockSerial.html#RecvBlock^^Waits until one data block is received. See <a class=\"normal\" href=\"synaser.TBlockSerial.html#SendBlock\">SendBlock</a>. If no data is received within the Timeout (in milliseconds) period, <a class=\"normal\" href=\"synaser.TBlockSerial.html#LastError\">LastError</a> is set to <a class=\"normal\" href=\"synaser.html#ErrTimeout\">ErrTimeout</a>.    ^0"
s[1533] = "synaser.TBlockSerial.RecvStreamRaw^synaser.TBlockSerial.html#RecvStreamRaw^^Receive all data to stream, until some error occured. (for example timeout)    ^0"
s[1534] = "synaser.TBlockSerial.RecvStreamSize^synaser.TBlockSerial.html#RecvStreamSize^^receive requested count of bytes to stream    ^0"
s[1535] = "synaser.TBlockSerial.RecvStream^synaser.TBlockSerial.html#RecvStream^^receive block of data to stream. (Data can be sended by <a class=\"normal\" href=\"synaser.TBlockSerial.html#SendStream\">SendStream</a>    ^0"
s[1536] = "synaser.TBlockSerial.RecvStreamIndy^synaser.TBlockSerial.html#RecvStreamIndy^^receive block of data to stream. (Data can be sended by <a class=\"normal\" href=\"synaser.TBlockSerial.html#SendStreamIndy\">SendStreamIndy</a>    ^0"
s[1537] = "synaser.TBlockSerial.WaitingData^synaser.TBlockSerial.html#WaitingData^^Returns the number of received bytes waiting for reading. 0 is returned when there is no data waiting.    ^0"
s[1538] = "synaser.TBlockSerial.WaitingDataEx^synaser.TBlockSerial.html#WaitingDataEx^^Same as <a class=\"normal\" href=\"synaser.TBlockSerial.html#WaitingData\">WaitingData</a>, but in respect to data in the internal <a class=\"normal\" href=\"synaser.TBlockSerial.html#LineBuffer\">LineBuffer</a>.    ^0"
s[1539] = "synaser.TBlockSerial.SendingData^synaser.TBlockSerial.html#SendingData^^Returns the number of bytes waiting to be sent in the output buffer. 0 is returned when the output buffer is empty.    ^0"
s[1540] = "synaser.TBlockSerial.EnableRTSToggle^synaser.TBlockSerial.html#EnableRTSToggle^^Enable or disable RTS driven communication (half-duplex). It can be used to communicate with RS485 converters, or other special equipment. If you enable this feature, the system automatically controls the RTS signal.    <p>Notes:    <p>- On Windows NT (or higher) ir RTS signal driven by system driver.    <p>- On Win9x family is used special code for waiting until last byte is sended from your UART.    <p>- On Linux you must have kernel 2.1 or higher!    ^0"
s[1541] = "synaser.TBlockSerial.Flush^synaser.TBlockSerial.html#Flush^^Waits until all data to is sent and buffers are emptied. Warning: On Windows systems is this method returns when all buffers are flushed to the serial port controller, before the last byte is sent!    ^0"
s[1542] = "synaser.TBlockSerial.Purge^synaser.TBlockSerial.html#Purge^^Unconditionally empty all buffers. It is good when you need to interrupt communication and for cleanups.    ^0"
s[1543] = "synaser.TBlockSerial.CanRead^synaser.TBlockSerial.html#CanRead^^Returns <code>True</code>, if you can from read any data from the port. Status is tested for a period of time given by the Timeout parameter (in milliseconds). If the value of the Timeout parameter is 0, the status is tested only once and the function returns immediately. If the value of the Timeout parameter is set to -1, the function returns only after it detects data on the port (this may cause the process to hang).    ^0"
s[1544] = "synaser.TBlockSerial.CanWrite^synaser.TBlockSerial.html#CanWrite^^Returns <code>True</code>, if you can write any data to the port (this function is not sending the contents of the buffer). Status is tested for a period of time given by the Timeout parameter (in milliseconds). If the value of the Timeout parameter is 0, the status is tested only once and the function returns immediately. If the value of the Timeout parameter is set to -1, the function returns only after it detects that it can write data to the port (this may cause the process to hang).    ^0"
s[1545] = "synaser.TBlockSerial.CanReadEx^synaser.TBlockSerial.html#CanReadEx^^Same as <a class=\"normal\" href=\"synaser.TBlockSerial.html#CanRead\">CanRead</a>, but the test is against data in the internal <a class=\"normal\" href=\"synaser.TBlockSerial.html#LineBuffer\">LineBuffer</a> too.    ^0"
s[1546] = "synaser.TBlockSerial.ModemStatus^synaser.TBlockSerial.html#ModemStatus^^Returns the status word of the modem. Decoding the status word could yield the status of carrier detect signaland other signals. This method is used internally by the modem status reading properties. You usually do not need to call this method directly.    ^0"
s[1547] = "synaser.TBlockSerial.SetBreak^synaser.TBlockSerial.html#SetBreak^^Send a break signal to the communication device for Duration milliseconds.    ^0"
s[1548] = "synaser.TBlockSerial.ATCommand^synaser.TBlockSerial.html#ATCommand^^This function is designed to send AT commands to the modem. The AT command is sent in the Value parameter and the response is returned in the function return value (may contain multiple lines!). If the AT command is processed successfully (modem returns OK), then the <a class=\"normal\" href=\"synaser.TBlockSerial.html#ATResult\">ATResult</a> property is set to True.    <p>This function is designed only for AT commands that return OK or ERROR response! To call connection commands the <a class=\"normal\" href=\"synaser.TBlockSerial.html#ATConnect\">ATConnect</a> method. Remember, when you connect to a modem device, it is in AT command mode. Now you can send AT commands to the modem. If you need to transfer data to the modem on the other side of the line, you must first switch to data mode using the <a class=\"normal\" href=\"synaser.TBlockSerial.html#ATConnect\">ATConnect</a> method.    ^0"
s[1549] = "synaser.TBlockSerial.ATConnect^synaser.TBlockSerial.html#ATConnect^^This function is used to send connect type AT commands to the modem. It is for commands to switch to connected state. (ATD, ATA, ATO,...) It sends the AT command in the Value parameter and returns the modem's response (may be multiple lines - usually with connection parameters info). If the AT command is processed successfully (the modem returns CONNECT), then the ATResult property is set to <code>True</code>.    <p>This function is designed only for AT commands which respond by CONNECT, BUSY, NO DIALTONE NO CARRIER or ERROR. For other AT commands use the <a class=\"normal\" href=\"synaser.TBlockSerial.html#ATCommand\">ATCommand</a> method.    <p>The connect timeout is 90*<a class=\"normal\" href=\"synaser.TBlockSerial.html#AtTimeout\">AtTimeout</a>. If this command is successful (<a class=\"normal\" href=\"synaser.TBlockSerial.html#ATResult\">ATResult</a> is <code>True</code>), then the modem is in data state. When you now send or receive some data, it is not to or from your modem, but from the modem on other side of the line. Now you can transfer your data. If the connection attempt failed (<a class=\"normal\" href=\"synaser.TBlockSerial.html#ATResult\">ATResult</a> is <code>False</code>), then the modem is still in AT command mode.    ^0"
s[1550] = "synaser.TBlockSerial.SerialCheck^synaser.TBlockSerial.html#SerialCheck^^If you &quot;manually&quot; call API functions, forward their return code in the SerialResult parameter to this function, which evaluates it and sets <a class=\"normal\" href=\"synaser.TBlockSerial.html#LastError\">LastError</a> and <a class=\"normal\" href=\"synaser.TBlockSerial.html#LastErrorDesc\">LastErrorDesc</a>.    ^0"
s[1551] = "synaser.TBlockSerial.ExceptCheck^synaser.TBlockSerial.html#ExceptCheck^^If <a class=\"normal\" href=\"synaser.TBlockSerial.html#LastError\">LastError</a> is not 0 and exceptions are enabled, then this procedure raises an exception. This method is used internally. You may need it only in special cases.    ^0"
s[1552] = "synaser.TBlockSerial.SetSynaError^synaser.TBlockSerial.html#SetSynaError^^Set Synaser to error state with ErrNumber code. Usually used by internal routines.    ^0"
s[1553] = "synaser.TBlockSerial.RaiseSynaError^synaser.TBlockSerial.html#RaiseSynaError^^Raise Synaser error with ErrNumber code. Usually used by internal routines.    ^0"
s[1554] = "synaser.TBlockSerial.GetErrorDesc^synaser.TBlockSerial.html#GetErrorDesc^^Returns the descriptive text associated with ErrorCode. You need this method only in special cases. Description of LastError is now accessible through the LastErrorDesc property.    ^0"
s[1555] = "synaser.TBlockSerial.Device^synaser.TBlockSerial.html#Device^^True device name of currently used port ^0"
s[1556] = "synaser.TBlockSerial.LastError^synaser.TBlockSerial.html#LastError^^Error code of last operation. Value is defined by the host operating system, but value 0 is always OK. ^0"
s[1557] = "synaser.TBlockSerial.LastErrorDesc^synaser.TBlockSerial.html#LastErrorDesc^^Human readable description of LastError code. ^0"
s[1558] = "synaser.TBlockSerial.ATResult^synaser.TBlockSerial.html#ATResult^^Indicates if the last <a class=\"normal\" href=\"synaser.TBlockSerial.html#ATCommand\">ATCommand</a> or <a class=\"normal\" href=\"synaser.TBlockSerial.html#ATConnect\">ATConnect</a> method was successful ^0"
s[1559] = "synaser.TBlockSerial.RTS^synaser.TBlockSerial.html#RTS^^Read the value of the RTS signal. ^0"
s[1560] = "synaser.TBlockSerial.CTS^synaser.TBlockSerial.html#CTS^^Indicates the presence of the CTS signal ^0"
s[1561] = "synaser.TBlockSerial.DTR^synaser.TBlockSerial.html#DTR^^Use this property to set the value of the DTR signal. ^0"
s[1562] = "synaser.TBlockSerial.DSR^synaser.TBlockSerial.html#DSR^^Exposes the status of the DSR signal. ^0"
s[1563] = "synaser.TBlockSerial.Carrier^synaser.TBlockSerial.html#Carrier^^Indicates the presence of the Carrier signal ^0"
s[1564] = "synaser.TBlockSerial.Ring^synaser.TBlockSerial.html#Ring^^Reflects the status of the Ring signal. ^0"
s[1565] = "synaser.TBlockSerial.InstanceActive^synaser.TBlockSerial.html#InstanceActive^^indicates if this instance of SynaSer is active. (Connected to some port) ^0"
s[1566] = "synaser.TBlockSerial.MaxSendBandwidth^synaser.TBlockSerial.html#MaxSendBandwidth^^Defines maximum bandwidth for all sending operations in bytes per second. If this value is set to 0 (default), bandwidth limitation is not used. ^0"
s[1567] = "synaser.TBlockSerial.MaxRecvBandwidth^synaser.TBlockSerial.html#MaxRecvBandwidth^^Defines maximum bandwidth for all receiving operations in bytes per second. If this value is set to 0 (default), bandwidth limitation is not used. ^0"
s[1568] = "synaser.TBlockSerial.MaxBandwidth^synaser.TBlockSerial.html#MaxBandwidth^^Defines maximum bandwidth for all sending and receiving operations in bytes per second. If this value is set to 0 (default), bandwidth limitation is not used. ^0"
s[1569] = "synaser.TBlockSerial.SizeRecvBuffer^synaser.TBlockSerial.html#SizeRecvBuffer^^Size of the Windows internal receive buffer. Default value is usually 4096 bytes. Note: Valid only in Windows versions! ^0"
s[1570] = "synaser.TBlockSerial.Tag^synaser.TBlockSerial.html#Tag^^Freely usable property ^0"
s[1571] = "synaser.TBlockSerial.Handle^synaser.TBlockSerial.html#Handle^^Contains the handle of the open communication port. You may need this value to directly call communication functions outside SynaSer. ^0"
s[1572] = "synaser.TBlockSerial.LineBuffer^synaser.TBlockSerial.html#LineBuffer^^Internally used read buffer. ^0"
s[1573] = "synaser.TBlockSerial.RaiseExcept^synaser.TBlockSerial.html#RaiseExcept^^If <code>True</code>, communication errors raise exceptions. If <code>False</code> (default), only the <a class=\"normal\" href=\"synaser.TBlockSerial.html#LastError\">LastError</a> value is set. ^0"
s[1574] = "synaser.TBlockSerial.OnStatus^synaser.TBlockSerial.html#OnStatus^^This event is triggered when the communication status changes. It can be used to monitor communication status. ^0"
s[1575] = "synaser.TBlockSerial.TestDSR^synaser.TBlockSerial.html#TestDSR^^If you set this property to <code>True</code>, then the value of the DSR signal is tested before every data transfer. It can be used to detect the presence of a communications device. ^0"
s[1576] = "synaser.TBlockSerial.TestCTS^synaser.TBlockSerial.html#TestCTS^^If you set this property to <code>True</code>, then the value of the CTS signal is tested before every data transfer. It can be used to detect the presence of a communications device. Warning: This property cannot be used if you need hardware handshake! ^0"
s[1577] = "synaser.TBlockSerial.MaxLineLength^synaser.TBlockSerial.html#MaxLineLength^^Use this property you to limit the maximum size of LineBuffer (as a protection against unlimited memory allocation for LineBuffer). Default value is 0 - no limit. ^0"
s[1578] = "synaser.TBlockSerial.DeadlockTimeout^synaser.TBlockSerial.html#DeadlockTimeout^^This timeout value is used as deadlock protection when trying to send data to (or receive data from) a device that stopped communicating during data transmission (e.g. by physically disconnecting the device). The timeout value is in milliseconds. The default value is 30,000 (30 seconds). ^0"
s[1579] = "synaser.TBlockSerial.LinuxLock^synaser.TBlockSerial.html#LinuxLock^^If set to <code>True</code> (default value), port locking is enabled (under Linux only). WARNING: To use this feature, the application must run by a user with full permission to the /var/lock directory! ^0"
s[1580] = "synaser.TBlockSerial.ConvertLineEnd^synaser.TBlockSerial.html#ConvertLineEnd^^Indicates if non-standard line terminators should be converted to a CR/LF pair (standard DOS line terminator). If <code>True</code>, line terminators CR, single LF or LF/CR are converted to CR/LF. Defaults to <code>False</code>. This property has effect only on the behavior of the RecvString method. ^0"
s[1581] = "synaser.TBlockSerial.AtTimeout^synaser.TBlockSerial.html#AtTimeout^^Timeout for AT modem based operations ^0"
s[1582] = "synaser.TBlockSerial.InterPacketTimeout^synaser.TBlockSerial.html#InterPacketTimeout^^If <code>True</code> (default), then all timeouts is timeout between two characters. If <code>False</code>, then timeout is overall for whoole reading operation. ^0"
s[1583] = "synaser.CR^synaser.html#CR^^ ^0"
s[1584] = "synaser.LF^synaser.html#LF^^ ^0"
s[1585] = "synaser.CRLF^synaser.html#CRLF^^ ^0"
s[1586] = "synaser.cSerialChunk^synaser.html#cSerialChunk^^ ^0"
s[1587] = "synaser.LockfileDirectory^synaser.html#LockfileDirectory^^ ^0"
s[1588] = "synaser.PortIsClosed^synaser.html#PortIsClosed^^ ^0"
s[1589] = "synaser.ErrAlreadyOwned^synaser.html#ErrAlreadyOwned^^ ^0"
s[1590] = "synaser.ErrAlreadyInUse^synaser.html#ErrAlreadyInUse^^ ^0"
s[1591] = "synaser.ErrWrongParameter^synaser.html#ErrWrongParameter^^ ^0"
s[1592] = "synaser.ErrPortNotOpen^synaser.html#ErrPortNotOpen^^ ^0"
s[1593] = "synaser.ErrNoDeviceAnswer^synaser.html#ErrNoDeviceAnswer^^ ^0"
s[1594] = "synaser.ErrMaxBuffer^synaser.html#ErrMaxBuffer^^ ^0"
s[1595] = "synaser.ErrTimeout^synaser.html#ErrTimeout^^ ^0"
s[1596] = "synaser.ErrNotRead^synaser.html#ErrNotRead^^ ^0"
s[1597] = "synaser.ErrFrame^synaser.html#ErrFrame^^ ^0"
s[1598] = "synaser.ErrOverrun^synaser.html#ErrOverrun^^ ^0"
s[1599] = "synaser.ErrRxOver^synaser.html#ErrRxOver^^ ^0"
s[1600] = "synaser.ErrRxParity^synaser.html#ErrRxParity^^ ^0"
s[1601] = "synaser.ErrTxFull^synaser.html#ErrTxFull^^ ^0"
s[1602] = "synaser.dcb_Binary^synaser.html#dcb_Binary^^ ^0"
s[1603] = "synaser.dcb_ParityCheck^synaser.html#dcb_ParityCheck^^ ^0"
s[1604] = "synaser.dcb_OutxCtsFlow^synaser.html#dcb_OutxCtsFlow^^ ^0"
s[1605] = "synaser.dcb_OutxDsrFlow^synaser.html#dcb_OutxDsrFlow^^ ^0"
s[1606] = "synaser.dcb_DtrControlMask^synaser.html#dcb_DtrControlMask^^ ^0"
s[1607] = "synaser.dcb_DtrControlDisable^synaser.html#dcb_DtrControlDisable^^ ^0"
s[1608] = "synaser.dcb_DtrControlEnable^synaser.html#dcb_DtrControlEnable^^ ^0"
s[1609] = "synaser.dcb_DtrControlHandshake^synaser.html#dcb_DtrControlHandshake^^ ^0"
s[1610] = "synaser.dcb_DsrSensivity^synaser.html#dcb_DsrSensivity^^ ^0"
s[1611] = "synaser.dcb_TXContinueOnXoff^synaser.html#dcb_TXContinueOnXoff^^ ^0"
s[1612] = "synaser.dcb_OutX^synaser.html#dcb_OutX^^ ^0"
s[1613] = "synaser.dcb_InX^synaser.html#dcb_InX^^ ^0"
s[1614] = "synaser.dcb_ErrorChar^synaser.html#dcb_ErrorChar^^ ^0"
s[1615] = "synaser.dcb_NullStrip^synaser.html#dcb_NullStrip^^ ^0"
s[1616] = "synaser.dcb_RtsControlMask^synaser.html#dcb_RtsControlMask^^ ^0"
s[1617] = "synaser.dcb_RtsControlDisable^synaser.html#dcb_RtsControlDisable^^ ^0"
s[1618] = "synaser.dcb_RtsControlEnable^synaser.html#dcb_RtsControlEnable^^ ^0"
s[1619] = "synaser.dcb_RtsControlHandshake^synaser.html#dcb_RtsControlHandshake^^ ^0"
s[1620] = "synaser.dcb_RtsControlToggle^synaser.html#dcb_RtsControlToggle^^ ^0"
s[1621] = "synaser.dcb_AbortOnError^synaser.html#dcb_AbortOnError^^ ^0"
s[1622] = "synaser.dcb_Reserveds^synaser.html#dcb_Reserveds^^ ^0"
s[1623] = "synaser.SB1^synaser.html#SB1^^stopbit value for 1 stopbit ^0"
s[1624] = "synaser.SB1andHalf^synaser.html#SB1andHalf^^stopbit value for 1.5 stopbit ^0"
s[1625] = "synaser.SB2^synaser.html#SB2^^stopbit value for 2 stopbits ^0"
s[1626] = "synaser.sOK^synaser.html#sOK^^ ^0"
s[1627] = "synaser.sErr^synaser.html#sErr^^ ^0"
s[1628] = "synaser.GetSerialPortNames^synaser.html#GetSerialPortNames^^Returns list of existing computer serial ports. Working properly only in Windows!    ^0"
s[1629] = "synaser.THookSerialReason^synaser.html#THookSerialReason^^Possible status event types for <a class=\"normal\" href=\"synaser.html#THookSerialStatus\">THookSerialStatus</a>  HR_SerialClose    HR_Connect    HR_CanRead    HR_CanWrite    HR_ReadCount    HR_WriteCount    HR_Wait   ^0"
s[1630] = "synaser.THookSerialStatus^synaser.html#THookSerialStatus^^procedural prototype for status event hooking    ^0"
s[1631] = "synautil^synautil.html^^ ^0"
s[1632] = "synautil.TimeZoneBias^synautil.html#TimeZoneBias^^Return your timezone bias from UTC time in minutes.    ^0"
s[1633] = "synautil.TimeZone^synautil.html#TimeZone^^Return your timezone bias from UTC time in string representation like &quot;+0200&quot;.    ^0"
s[1634] = "synautil.Rfc822DateTime^synautil.html#Rfc822DateTime^^Returns current time in format defined in RFC-822. Useful for SMTP messages, but other protocols use this time format as well. Results contains the timezone specification. Four digit year is used to break any Y2K concerns. (Example 'Fri, 15 Oct 1999 21:14:56 +0200')    ^0"
s[1635] = "synautil.CDateTime^synautil.html#CDateTime^^Returns date and time in format defined in C compilers in format &quot;mmm dd hh:nn:ss&quot;    ^0"
s[1636] = "synautil.SimpleDateTime^synautil.html#SimpleDateTime^^Returns date and time in format defined in format 'yymmdd hhnnss'    ^0"
s[1637] = "synautil.AnsiCDateTime^synautil.html#AnsiCDateTime^^Returns date and time in format defined in ANSI C compilers in format &quot;ddd mmm d hh:nn:ss yyyy&quot;    ^0"
s[1638] = "synautil.GetMonthNumber^synautil.html#GetMonthNumber^^Decode three-letter string with name of month to their month number. If string not match any month name, then is returned 0. For parsing are used predefined names for English, French and German and names from system locale too.    ^0"
s[1639] = "synautil.GetTimeFromStr^synautil.html#GetTimeFromStr^^Return decoded time from given string. Time must be witch separator ':'. You can use &quot;hh:mm&quot; or &quot;hh:mm:ss&quot;.    ^0"
s[1640] = "synautil.GetDateMDYFromStr^synautil.html#GetDateMDYFromStr^^Decode string in format &quot;m-d-y&quot; to TDateTime type.    ^0"
s[1641] = "synautil.DecodeRfcDateTime^synautil.html#DecodeRfcDateTime^^Decode various string representations of date and time to Tdatetime type. This function do all timezone corrections too! This function can decode lot of formats like: </p>    <pre class=\"longcode\">   ddd, d mmm yyyy hh:mm:ss   ddd, d mmm yy hh:mm:ss   ddd, mmm d yyyy hh:mm:ss   ddd mmm dd hh:mm:ss yyyy</pre>    <p>    <p>and more with lot of modifications, include: </p>    <pre class=\"longcode\">  Sun, <span class=\"pascal_numeric\">06</span> Nov <span class=\"pascal_numeric\">1994</span> 08:<span class=\"pascal_numeric\">49</span>:37 GMT    ; RFC <span class=\"pascal_numeric\">822</span>, updated by RFC <span class=\"pascal_numeric\">1123</span>  Sunday, <span class=\"pascal_numeric\">06</span>-Nov-<span class=\"pascal_numeric\">94</span> 08:<span class=\"pascal_numeric\">49</span>:37 GMT   ; RFC <span class=\"pascal_numeric\">850</span>, obsoleted by RFC <span class=\"pascal_numeric\">1036</span>  Sun Nov  <span class=\"pascal_numeric\">6</span> 08:<span class=\"pascal_numeric\">49</span>:37 <span class=\"pascal_numeric\">1994</span>         ; ANSI C</pre>    <p> Timezone corrections known lot of symbolic timezone names (like CEST, EDT, etc.) or numeric representation (like +0200). By convention defined in RFC timezone +0000 is GMT and -0000 is current your system timezone.    ^0"
s[1642] = "synautil.GetUTTime^synautil.html#GetUTTime^^Return current system date and time in UTC timezone.    ^0"
s[1643] = "synautil.SetUTTime^synautil.html#SetUTTime^^Set Newdt as current system date and time in UTC timezone. This function work only if you have administrator rights!    ^0"
s[1644] = "synautil.GetTick^synautil.html#GetTick^^Return current value of system timer with precizion 1 millisecond. Good for measure time difference.    ^0"
s[1645] = "synautil.TickDelta^synautil.html#TickDelta^^Return difference between two timestamps. It working fine only for differences smaller then maxint. (difference must be smaller then 24 days.)    ^0"
s[1646] = "synautil.CodeInt^synautil.html#CodeInt^^Return two characters, which ordinal values represents the value in byte format. (High-endian)    ^0"
s[1647] = "synautil.DecodeInt^synautil.html#DecodeInt^^Decodes two characters located at &quot;Index&quot; offset position of the &quot;Value&quot; string to Word values.    ^0"
s[1648] = "synautil.CodeLongInt^synautil.html#CodeLongInt^^Return four characters, which ordinal values represents the value in byte format. (High-endian)    ^0"
s[1649] = "synautil.DecodeLongInt^synautil.html#DecodeLongInt^^Decodes four characters located at &quot;Index&quot; offset position of the &quot;Value&quot; string to LongInt values.    ^0"
s[1650] = "synautil.DumpStr^synautil.html#DumpStr^^Dump binary buffer stored in a string to a result string.    ^0"
s[1651] = "synautil.DumpExStr^synautil.html#DumpExStr^^Dump binary buffer stored in a string to a result string. All bytes with code of character is written as character, not as hexadecimal value.    ^0"
s[1652] = "synautil.Dump^synautil.html#Dump^^Dump binary buffer stored in a string to a file with DumpFile filename.    ^0"
s[1653] = "synautil.DumpEx^synautil.html#DumpEx^^Dump binary buffer stored in a string to a file with DumpFile filename. All bytes with code of character is written as character, not as hexadecimal value.    ^0"
s[1654] = "synautil.TrimSPLeft^synautil.html#TrimSPLeft^^Like TrimLeft, but remove only spaces, not control characters!    ^0"
s[1655] = "synautil.TrimSPRight^synautil.html#TrimSPRight^^Like TrimRight, but remove only spaces, not control characters!    ^0"
s[1656] = "synautil.TrimSP^synautil.html#TrimSP^^Like Trim, but remove only spaces, not control characters!    ^0"
s[1657] = "synautil.SeparateLeft^synautil.html#SeparateLeft^^Returns a portion of the &quot;Value&quot; string located to the left of the &quot;Delimiter&quot; string. If a delimiter is not found, results is original string.    ^0"
s[1658] = "synautil.SeparateRight^synautil.html#SeparateRight^^Returns the portion of the &quot;Value&quot; string located to the right of the &quot;Delimiter&quot; string. If a delimiter is not found, results is original string.    ^0"
s[1659] = "synautil.GetParameter^synautil.html#GetParameter^^Returns parameter value from string in format: parameter1=&quot;value1&quot;; parameter2=value2    ^0"
s[1660] = "synautil.ParseParametersEx^synautil.html#ParseParametersEx^^parse value string with elements differed by Delimiter into stringlist.    ^0"
s[1661] = "synautil.ParseParameters^synautil.html#ParseParameters^^parse value string with elements differed by ';' into stringlist.    ^0"
s[1662] = "synautil.IndexByBegin^synautil.html#IndexByBegin^^Index of string in stringlist with same beginning as Value is returned.    ^0"
s[1663] = "synautil.GetEmailAddr^synautil.html#GetEmailAddr^^Returns only the e-mail portion of an address from the full address format. i.e. returns 'nobody@somewhere.com' from '&quot;someone&quot; &lt;nobody@somewhere.com&gt;'    ^0"
s[1664] = "synautil.GetEmailDesc^synautil.html#GetEmailDesc^^Returns only the description part from a full address format. i.e. returns 'someone' from '&quot;someone&quot; &lt;nobody@somewhere.com&gt;'    ^0"
s[1665] = "synautil.StrToHex^synautil.html#StrToHex^^Returns a string with hexadecimal digits representing the corresponding values of the bytes found in &quot;Value&quot; string.    ^0"
s[1666] = "synautil.IntToBin^synautil.html#IntToBin^^Returns a string of binary &quot;Digits&quot; representing &quot;Value&quot;.    ^0"
s[1667] = "synautil.BinToInt^synautil.html#BinToInt^^Returns an integer equivalent of the binary string in &quot;Value&quot;. (i.e. ('10001010') returns 138)    ^0"
s[1668] = "synautil.ParseURL^synautil.html#ParseURL^^Parses a URL to its various components.    ^0"
s[1669] = "synautil.ReplaceString^synautil.html#ReplaceString^^Replaces all &quot;Search&quot; string values found within &quot;Value&quot; string, with the &quot;Replace&quot; string value.    ^0"
s[1670] = "synautil.RPosEx^synautil.html#RPosEx^^It is like RPos, but search is from specified possition.    ^0"
s[1671] = "synautil.RPos^synautil.html#RPos^^It is like POS function, but from right side of Value string.    ^0"
s[1672] = "synautil.FetchBin^synautil.html#FetchBin^^Like <a class=\"normal\" href=\"synautil.html#Fetch\">Fetch</a>, but working with binary strings, not with text.    ^0"
s[1673] = "synautil.Fetch^synautil.html#Fetch^^Fetch string from left of Value string.    ^0"
s[1674] = "synautil.FetchEx^synautil.html#FetchEx^^Fetch string from left of Value string. This function ignore delimitesr inside quotations.    ^0"
s[1675] = "synautil.IsBinaryString^synautil.html#IsBinaryString^^If string is binary string (contains non-printable characters), then is returned true.    ^0"
s[1676] = "synautil.PosCRLF^synautil.html#PosCRLF^^return position of string terminator in string. If terminator found, then is returned in terminator parameter. Possible line terminators are: CRLF, LFCR, CR, LF    ^0"
s[1677] = "synautil.StringsTrim^synautil.html#StringsTrim^^Delete empty strings from end of stringlist.    ^0"
s[1678] = "synautil.PosFrom^synautil.html#PosFrom^^Like Pos function, buf from given string possition.    ^0"
s[1679] = "synautil.IncPoint^synautil.html#IncPoint^^Increase pointer by value.    ^0"
s[1680] = "synautil.GetBetween^synautil.html#GetBetween^^Get string between PairBegin and PairEnd. This function respect nesting. For example: </p>    <pre class=\"longcode\">   Value <span class=\"pascal_keyword\">is</span>: <span class=\"pascal_string\">'Hi! (hello(yes!))'</span>   pairbegin <span class=\"pascal_keyword\">is</span>: <span class=\"pascal_string\">'('</span>   pairend <span class=\"pascal_keyword\">is</span>: <span class=\"pascal_string\">')'</span>   <span class=\"pascal_keyword\">In</span> this <span class=\"pascal_keyword\">case</span> result <span class=\"pascal_keyword\">is</span>: <span class=\"pascal_string\">'hello(yes!)'</span></pre>    <p>    ^0"
s[1681] = "synautil.CountOfChar^synautil.html#CountOfChar^^Return count of Chr in Value string.    ^0"
s[1682] = "synautil.UnquoteStr^synautil.html#UnquoteStr^^Remove quotation from Value string. If Value is not quoted, then return same string without any modification.    ^0"
s[1683] = "synautil.QuoteStr^synautil.html#QuoteStr^^Quote Value string. If Value contains some Quote chars, then it is doubled.    ^0"
s[1684] = "synautil.HeadersToList^synautil.html#HeadersToList^^Convert lines in stringlist from 'name: value' form to 'name=value' form.    ^0"
s[1685] = "synautil.ListToHeaders^synautil.html#ListToHeaders^^Convert lines in stringlist from 'name=value' form to 'name: value' form.    ^0"
s[1686] = "synautil.SwapBytes^synautil.html#SwapBytes^^swap bytes in integer.    ^0"
s[1687] = "synautil.ReadStrFromStream^synautil.html#ReadStrFromStream^^read string with requested length form stream.    ^0"
s[1688] = "synautil.WriteStrToStream^synautil.html#WriteStrToStream^^write string to stream.    ^0"
s[1689] = "synautil.GetTempFile^synautil.html#GetTempFile^^Return filename of new temporary file in Dir (if empty, then default temporary directory is used) and with optional filename prefix.    ^0"
s[1690] = "synautil.PadString^synautil.html#PadString^^Return padded string. If length is greater, string is truncated. If length is smaller, string is padded by Pad character.    ^0"
s[1691] = "synautil.XorString^synautil.html#XorString^^XOR each byte in the strings    ^0"
s[1692] = "synautil.NormalizeHeader^synautil.html#NormalizeHeader^^Read header from &quot;Value&quot; stringlist beginning at &quot;Index&quot; position. If header is Splitted into multiple lines, then this procedure de-split it into one line.    ^0"
s[1693] = "synautil.SearchForLineBreak^synautil.html#SearchForLineBreak^^Search for one of line terminators CR, LF or NUL. Return position of the line beginning and length of text.    ^0"
s[1694] = "synautil.SkipLineBreak^synautil.html#SkipLineBreak^^Skip both line terminators CR LF (if any). Move APtr position forward.    ^0"
s[1695] = "synautil.SkipNullLines^synautil.html#SkipNullLines^^Skip all blank lines in a buffer starting at APtr and move APtr position forward.    ^0"
s[1696] = "synautil.CopyLinesFromStreamUntilNullLine^synautil.html#CopyLinesFromStreamUntilNullLine^^Copy all lines from a buffer starting at APtr to ALines until empty line or end of the buffer is reached. Move APtr position forward).    ^0"
s[1697] = "synautil.CopyLinesFromStreamUntilBoundary^synautil.html#CopyLinesFromStreamUntilBoundary^^Copy all lines from a buffer starting at APtr to ALines until ABoundary or end of the buffer is reached. Move APtr position forward).    ^0"
s[1698] = "synautil.SearchForBoundary^synautil.html#SearchForBoundary^^Search ABoundary in a buffer starting at APtr. Return beginning of the ABoundary. Move APtr forward behind a trailing CRLF if any).    ^0"
s[1699] = "synautil.MatchBoundary^synautil.html#MatchBoundary^^Compare a text at position ABOL with ABoundary and return position behind the match (including a trailing CRLF if any).    ^0"
s[1700] = "synautil.MatchLastBoundary^synautil.html#MatchLastBoundary^^Compare a text at position ABOL with ABoundary + the last boundary suffix and return position behind the match (including a trailing CRLF if any).    ^0"
s[1701] = "synautil.BuildStringFromBuffer^synautil.html#BuildStringFromBuffer^^Copy data from a buffer starting at position APtr and delimited by AEtx position into ANSIString.    ^0"
s[1702] = "synautil.CustomMonthNames^synautil.html#CustomMonthNames^^can be used for your own months strings for <a class=\"normal\" href=\"synautil.html#GetMonthNumber\">GetMonthNumber</a> ^0"
s[1703] = "tlntsend^tlntsend.html^Telnet script client^    <p>Used RFC: RFC-854 ^0"
s[1704] = "tlntsend.TTelnetSend^tlntsend.TTelnetSend.html^Class with implementation of Telnet/SSH script client.^    <p>Note: Are you missing properties for specify server address and port? Look to parent <a class=\"normal\" href=\"blcksock.TSynaClient.html\">TSynaClient</a> too! ^0"
s[1705] = "tlntsend.TTelnetSend.Create^tlntsend.TTelnetSend.html#Create^^    ^0"
s[1706] = "tlntsend.TTelnetSend.Destroy^tlntsend.TTelnetSend.html#Destroy^^    ^0"
s[1707] = "tlntsend.TTelnetSend.Login^tlntsend.TTelnetSend.html#Login^^Connects to Telnet server.    ^0"
s[1708] = "tlntsend.TTelnetSend.SSHLogin^tlntsend.TTelnetSend.html#SSHLogin^^Connects to SSH2 server and login by Username and Password properties.    <p>You must use some of SSL plugins with SSH support. For exammple CryptLib.    ^0"
s[1709] = "tlntsend.TTelnetSend.Logout^tlntsend.TTelnetSend.html#Logout^^Logout from telnet server.    ^0"
s[1710] = "tlntsend.TTelnetSend.Send^tlntsend.TTelnetSend.html#Send^^Send this data to telnet server.    ^0"
s[1711] = "tlntsend.TTelnetSend.WaitFor^tlntsend.TTelnetSend.html#WaitFor^^Reading data from telnet server until Value is readed. If it is not readed until timeout, result is <code>False</code>. Otherwise result is <code>True</code>.    ^0"
s[1712] = "tlntsend.TTelnetSend.RecvTerminated^tlntsend.TTelnetSend.html#RecvTerminated^^Read data terminated by terminator from telnet server.    ^0"
s[1713] = "tlntsend.TTelnetSend.RecvString^tlntsend.TTelnetSend.html#RecvString^^Read string from telnet server.    ^0"
s[1714] = "tlntsend.TTelnetSend.Sock^tlntsend.TTelnetSend.html#Sock^^Socket object used for TCP/IP operation. Good for seting OnStatus hook, etc. ^0"
s[1715] = "tlntsend.TTelnetSend.SessionLog^tlntsend.TTelnetSend.html#SessionLog^^all readed datas in this session (from connect) is stored in this large string. ^0"
s[1716] = "tlntsend.TTelnetSend.TermType^tlntsend.TTelnetSend.html#TermType^^Terminal type indentification. By default is 'SYNAPSE'. ^0"
s[1717] = "tlntsend.cTelnetProtocol^tlntsend.html#cTelnetProtocol^^ ^0"
s[1718] = "tlntsend.cSSHProtocol^tlntsend.html#cSSHProtocol^^ ^0"
s[1719] = "tlntsend.TLNT_EOR^tlntsend.html#TLNT_EOR^^ ^0"
s[1720] = "tlntsend.TLNT_SE^tlntsend.html#TLNT_SE^^ ^0"
s[1721] = "tlntsend.TLNT_NOP^tlntsend.html#TLNT_NOP^^ ^0"
s[1722] = "tlntsend.TLNT_DATA_MARK^tlntsend.html#TLNT_DATA_MARK^^ ^0"
s[1723] = "tlntsend.TLNT_BREAK^tlntsend.html#TLNT_BREAK^^ ^0"
s[1724] = "tlntsend.TLNT_IP^tlntsend.html#TLNT_IP^^ ^0"
s[1725] = "tlntsend.TLNT_AO^tlntsend.html#TLNT_AO^^ ^0"
s[1726] = "tlntsend.TLNT_AYT^tlntsend.html#TLNT_AYT^^ ^0"
s[1727] = "tlntsend.TLNT_EC^tlntsend.html#TLNT_EC^^ ^0"
s[1728] = "tlntsend.TLNT_EL^tlntsend.html#TLNT_EL^^ ^0"
s[1729] = "tlntsend.TLNT_GA^tlntsend.html#TLNT_GA^^ ^0"
s[1730] = "tlntsend.TLNT_SB^tlntsend.html#TLNT_SB^^ ^0"
s[1731] = "tlntsend.TLNT_WILL^tlntsend.html#TLNT_WILL^^ ^0"
s[1732] = "tlntsend.TLNT_WONT^tlntsend.html#TLNT_WONT^^ ^0"
s[1733] = "tlntsend.TLNT_DO^tlntsend.html#TLNT_DO^^ ^0"
s[1734] = "tlntsend.TLNT_DONT^tlntsend.html#TLNT_DONT^^ ^0"
s[1735] = "tlntsend.TLNT_IAC^tlntsend.html#TLNT_IAC^^ ^0"
s[1736] = "tlntsend.TTelnetState^tlntsend.html#TTelnetState^State of telnet protocol^. Used internaly by TTelnetSend.  tsDATA    tsIAC    tsIAC_SB    tsIAC_WILL    tsIAC_DO    tsIAC_WONT    tsIAC_DONT    tsIAC_SBIAC    tsIAC_SBDATA    tsSBDATA_IAC   ^0"
